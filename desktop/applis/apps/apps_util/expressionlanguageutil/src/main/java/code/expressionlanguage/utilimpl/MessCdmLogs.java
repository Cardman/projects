package code.expressionlanguage.utilimpl;
import code.expressionlanguage.analyze.errors.AnalysisMessages;
import code.sml.util.*;
public final class MessCdmLogs{
private MessCdmLogs(){}

public static TranslationsFile en(){
TranslationsFile en_=new TranslationsFile();
en_.add(AnalysisMessages.DUPLICATE_MERGED_METHOD,"DuplicateMergedMethod=the merged method name {0}:{1} is duplicated.");
en_.add(AnalysisMessages.DUPLICATE_FIELD,"DuplicateField=the field name {0} is duplicated.");
en_.add(AnalysisMessages.DUPLICATE_VAR_TYPE,"DuplicateVarType=the variable type {0} is duplicated.");
en_.add(AnalysisMessages.EMPTY_PKG_REF_TYPE,"EmptyPkgRefType={0}:{1} does not belong to a package.");
en_.add(AnalysisMessages.PRIMITIVE_KEY_WORD,"PrimitiveKeyWord=the primitive {0}:{1} is a duplicate string of a key word.");
en_.add(AnalysisMessages.DEFAULT_PKG_REF_TYPE,"DefaultPkgRefType={0} match the default package {1}.");
en_.add(AnalysisMessages.REF_TYPE_KEY_WORD,"RefTypeKeyWord=the reference type {0}:{1} contains a duplicate string of a key word.");
en_.add(AnalysisMessages.DIGIT_FIRST_PRIMITIVE,"DigitFirstPrimitive={0} starts with {1} that is digit.");
en_.add(AnalysisMessages.ILLEGAL_FIRST_CHAR,"IllegalFirstChar=the key word number {0} starts with {1} that is illegal as first character");
en_.add(AnalysisMessages.EMPTY_PRIMITIVE,"EmptyPrimitive={0} has an empty primitive value.");
en_.add(AnalysisMessages.NOT_WORD_CHAR_PRIMITIVE,"NotWordCharPrimitive={0} contains a character {1} that is not a character of a word.");
en_.add(AnalysisMessages.NOT_WORD_CHAR_REF_TYPE,"NotWordCharRefType={0} contains a character {1} that is not a character of a word.");
en_.add(AnalysisMessages.EMPTY_REF_TYPE_IN,"EmptyRefTypeIn={0} has an empty reference string between dots {1}.");
en_.add(AnalysisMessages.REF_TYPE_PRIMITIVE,"RefTypePrimitive=the reference type {0}:{1} contains a duplicate string of a primitive.");
en_.add(AnalysisMessages.DIGIT_FIRST_REF_TYPE,"DigitFirstRefType={0} starts with {1} that is digit.");
en_.add(AnalysisMessages.DUPLICATE_PRIMTIVE,"DuplicatePrimtive=the primitive {0} is duplicated.");
en_.add(AnalysisMessages.DUPLICATE_METHOD,"DuplicateMethod=the method name {0} is duplicated.");
en_.add(AnalysisMessages.DEFAULT_PKG_NO_MATCH,"DefaultPkgNoMatch=the default package {0} has no reference type.");
en_.add(AnalysisMessages.DUPLICATE_REF_TYPE,"DuplicateRefType=the reference type {0} is duplicated.");
en_.add(AnalysisMessages.DIGIT_FIRST_METHOD,"DigitFirstMethod=the method name {0} in reference type {1} starts with {2} that is digit.");
en_.add(AnalysisMessages.NOT_WORD_CHAR_FIELD,"NotWordCharField=the field name {0} in reference type {1} contains a character {2} that is not a character of a word.");
en_.add(AnalysisMessages.NOT_WORD_CHAR_METHOD,"NotWordCharMethod=the method name {0} in reference type {1} contains a character {2} that is not a character of a word.");
en_.add(AnalysisMessages.VAR_TYPE_KEY_WORD,"VarTypeKeyWord=the variable type name {0} in reference type {1}:{2} is a duplicate string of a key word.");
en_.add(AnalysisMessages.VAR_TYPE_PRIMITIVE,"VarTypePrimitive=the variable type name {0} in reference type {1}:{2} is a duplicate string of a primitive.");
en_.add(AnalysisMessages.DIGIT_FIRST_VAR_TYPE,"DigitFirstVarType=the variable type name {0} in reference type {1} starts with {2} that is digit.");
en_.add(AnalysisMessages.DUPLICATE_NUMBER_WORD,"DuplicateNumberWord={0} is duplicated as number word.");
en_.add(AnalysisMessages.METHOD_PRIMITIVE,"MethodPrimitive=the method name {0} in reference type {1}:{2} is a duplicate string of a primitive.");
en_.add(AnalysisMessages.FIELD_PRIMITIVE,"FieldPrimitive=the field name {0} in reference type {1}:{2} is a duplicate string of a primitive.");
en_.add(AnalysisMessages.DUPLICATE_STRING_WORD,"DuplicateStringWord={0} is duplicated as escaping word string in string.");
en_.add(AnalysisMessages.DUPLICATE_KEY_WORD,"DuplicateKeyWord={0} is duplicated as key word.");
en_.add(AnalysisMessages.DIGIT_FIRST_FIELD,"DigitFirstField=the field name {0} in reference type {1} starts with {2} that is digit.");
en_.add(AnalysisMessages.DUPLICATE_STARTING_NB,"DuplicateStartingNb=the number word {0} starts with the number word {1}.");
en_.add(AnalysisMessages.DUPLICATE_STARTING_UNI,"DuplicateStartingUni=the escaping word {0} starts with the unicode escaping character {1}.");
en_.add(AnalysisMessages.DUPLICATE_STARTING,"DuplicateStarting=the escaping word {0} starts with the escaping word {1}.");
en_.add(AnalysisMessages.NOT_WORD_CHAR_VAR_TYPE,"NotWordCharVarType=the variable type name {0} in reference type {1} contains a character {2} that is not a character of a word.");
en_.add(AnalysisMessages.EMPTY_PRE_BIN,"EmptyPreBin=empty prefix binary string");
en_.add(AnalysisMessages.EMPTY_VAR_TYPE,"EmptyVarType=the variable type key {0} in reference type {1} has an empty name.");
en_.add(AnalysisMessages.EMPTY_WORD,"EmptyWord={0} has an empty key word value.");
en_.add(AnalysisMessages.EMPTY_FIELD,"EmptyField=the field key {0} in reference type {1} has an empty name.");
en_.add(AnalysisMessages.EMPTY_NB,"EmptyNb={0} has an empty key number value.");
en_.add(AnalysisMessages.NOT_WORD_CHAR,"NotWordChar={0} contains a character {1} that is not a character of a word.");
en_.add(AnalysisMessages.EMPTY_PRE_HEX,"EmptyPreHex=empty prefix hexadecimal string");
en_.add(AnalysisMessages.EMPTY_METHOD,"EmptyMethod=the method key {0} in reference type {1} has an empty name.");
en_.add(AnalysisMessages.DIGIT_FIRST,"DigitFirst={0} starts with {1} that is digit.");
en_.add(AnalysisMessages.EMPTY_BIN_EXP,"EmptyBinExp=empty binary exp string");
en_.add(AnalysisMessages.EMPTY_STRING,"EmptyString={0} has an empty key string value.");
en_.add(AnalysisMessages.ILLEGAL_CHAR,"IllegalChar=the key word number {0} contains a character {1} that is illegal");
en_.add(AnalysisMessages.METHOD_KEY_WORD,"MethodKeyWord=the method name {0} in reference type {1}:{2} is a duplicate string of a key word.");
en_.add(AnalysisMessages.EMPTY_REF_TYPE,"EmptyRefType={0} has an empty reference type value.");
en_.add(AnalysisMessages.FIELD_KEY_WORD,"FieldKeyWord=the field name {0} in reference type {1}:{2} is a duplicate string of a key word.");
en_.add(AnalysisMessages.ABSTRACT_METHOD_BODY,"AbstractMethodBody=The method {1} in the type {0} is abstract and cannot have a body.");
en_.add(AnalysisMessages.ABSTRACT_METHOD_CONC,"AbstractMethodConc=The method {1} in the concrete type {0} must not be abstract.");
en_.add(AnalysisMessages.ABSTRACT_METHOD_IMPL,"AbstractMethodImpl=The method {1} from the type {0} must be overriden in the concrete type {2}.");
en_.add(AnalysisMessages.ABSTRACT_METHOD_REF,"AbstractMethodRef=The method {1} from the type {0} must not be called directly because of abstract.");
en_.add(AnalysisMessages.INACCESSIBLE_TYPE,"InaccessibleType=The type {0} is not accessible from the type {1}.");
en_.add(AnalysisMessages.UNEXPECTED_TYPE,"UnexpectedType=The type {0} is unexpected.");
en_.add(AnalysisMessages.UNEXPECTED_RET_TYPE,"UnexpectedRetType=The return type {0} in the function {1} is unexpected.");
en_.add(AnalysisMessages.METHODS_ACCESSES,"MethodsAccesses=The method {1} from the type {0} is strictly more accessible than the method {3} from the type {2}.");
en_.add(AnalysisMessages.EMPTY_PACKAGE,"EmptyPackage=A type must have an non empty package.");
en_.add(AnalysisMessages.EMPTY_PART_CLASS_NAME,"EmptyPartClassName=The part must not be empty.");
en_.add(AnalysisMessages.BAD_PART_CLASS_NAME,"BadPartClassName=The part {0} in a type is not valid. It must be a word.");
en_.add(AnalysisMessages.KEY_WORD_PART_CLASS_NAME,"KeyWordPartClassName=The part {0} in a type is not valid. It must not be a key word.");
en_.add(AnalysisMessages.PRIM_PART_CLASS_NAME,"PrimPartClassName=The part {0} in a type is not valid. It must not a primitive type.");
en_.add(AnalysisMessages.DIGIT_PART_CLASS_NAME,"DigitPartClassName=The part {0} in a type is not valid. It must not start with a digit.");
en_.add(AnalysisMessages.BAD_PART_VAR_CLASS_NAME,"BadPartVarClassName=The part {0} in a variable type is not valid. It must be a word.");
en_.add(AnalysisMessages.KEY_WORD_PART_VAR_CLASS_NAME,"KeyWordPartVarClassName=The part {0} in a variable type is not valid. It must not be a key word.");
en_.add(AnalysisMessages.PRIM_PART_VAR_CLASS_NAME,"PrimPartVarClassName=The part {0} in a variable type is not valid. It must not a primitive type.");
en_.add(AnalysisMessages.DIGIT_PART_VAR_CLASS_NAME,"DigitPartVarClassName=The part {0} in a variable type is not valid. It must not start with a digit.");
en_.add(AnalysisMessages.DUPLICATED_PART_VAR_CLASS_NAME,"DuplicatedPartVarClassName=The part {0} in a variable type is duplicated.");
en_.add(AnalysisMessages.CALL_CTOR_END,"CallCtorEnd=The call of a constructor using implicitly the instance must be applied at the end of the instruction.");
en_.add(AnalysisMessages.CALL_CTOR,"CallCtor=The call of a constructor using implicitly the instance must be applied in a constructor.");
en_.add(AnalysisMessages.CALL_CTOR_BEFORE_BLOCK,"CallCtorBeforeBlock=The call of a constructor using implicitly the instance must be applied before a block of instructions.");
en_.add(AnalysisMessages.CALL_CTOR_FIRST_LINE,"CallCtorFirstLine=The call of a constructor of the type or the super class using implicitly the instance must be applied on the first line.");
en_.add(AnalysisMessages.CALL_CTOR_INT_FROM_SUPER_INT,"CallCtorIntFromSuperInt=The call of a constructor of interface must refer a super interface of the calling type.");
en_.add(AnalysisMessages.CALL_CTOR_INT_NOT_FROM_INT,"CallCtorIntNotFromInt=The call of a constructor of interface must not applied in a constructor of interface.");
en_.add(AnalysisMessages.CALL_CTOR_INT_AFTER_SUPER_THIS,"CallCtorIntAfterSuperThis=A call of a constructor of interface must be applied only after a call of a constructor using implicitly the instance.");
en_.add(AnalysisMessages.CALL_CTOR_INT_INHERITS,"CallCtorIntInherits=The call of a constructor of the interface {0} cannot be applied before calling the constructor of the interface {1}.");
en_.add(AnalysisMessages.CALL_CTOR_SUPER_CLASS_ENUM_SINGLETON,"CallCtorSuperClassEnumSingleton=The super constructor can be called only from a class or an enum (singleton or normal).");
en_.add(AnalysisMessages.CALL_CTOR_NO_SUPER_CLASS_ENUM,"CallCtorNoSuperClassEnum=There is no super custom type to be called from this class or an enum (singleton or normal).");
en_.add(AnalysisMessages.ANNOT_FIELD_NOT_UNIQ,"AnnotFieldNotUniq=The field of the annotatation could not be found uniquely.");
en_.add(AnalysisMessages.ANNOT_FIELD_MUST,"AnnotFieldMust=The field {0} of the annotatation is compulsory.");
en_.add(AnalysisMessages.DUP_SUPPLIED_ANNOT_FIELD,"DupSuppliedAnnotField=The field {0} of the annotatation is supplied by duplicate.");
en_.add(AnalysisMessages.BAD_EXPRESSION,"BadExpression=Unexpected character {0} at the position {1} in the expression {2}");
en_.add(AnalysisMessages.BAD_FIELD_NAME,"BadFieldName=The field name {0} is not valid. It must be a word.");
en_.add(AnalysisMessages.KEY_WORD_FIELD_NAME,"KeyWordFieldName=The field name {0} is not valid. It must not be a key word.");
en_.add(AnalysisMessages.PRIM_FIELD_NAME,"PrimFieldName=The field name {0} is not valid. It must not a primitive type.");
en_.add(AnalysisMessages.DIGIT_FIELD_NAME,"DigitFieldName=The field name {0} is not valid. It must not start with a digit.");
en_.add(AnalysisMessages.NOT_RETRIEVED_FIELDS,"NotRetrievedFields=No field could be retrieved.");
en_.add(AnalysisMessages.BAD_NB_FORMAT,"BadNbFormat=Bad number {0}");
en_.add(AnalysisMessages.BAD_CHAR_FORMAT,"BadCharFormat=Bad character format {0}");
en_.add(AnalysisMessages.BAD_IMPLICIT_CAST,"BadImplicitCast=The type {0} cannot be implicitly cast to {1}");
en_.add(AnalysisMessages.NOT_PRIMITIVE_WRAPPER,"NotPrimitiveWrapper=The type {0} is not a primitive type or a wrapper type.");
en_.add(AnalysisMessages.VOID_TYPE,"VoidType=The type cannot be the key word {0}.");
en_.add(AnalysisMessages.BAD_INDEX_IN_PARSER,"BadIndexInParser=Bad index by parsing.");
en_.add(AnalysisMessages.ILLEGAL_CHARACTER,"IllegalCharacter=The characters ascii {0} are illegal.");
en_.add(AnalysisMessages.CALL_INT_INHERITS,"CallIntInherits=Initializing the interface {0} cannot be applied before initializing the interface {1}.");
en_.add(AnalysisMessages.CALL_INT_NO_NEED,"CallIntNoNeed=Initializing a type from the interface {0} is not needed.");
en_.add(AnalysisMessages.CALL_INT_NO_NEED_TYPE,"CallIntNoNeedType=Initializing the interface {0} from the type {1} is not needed.");
en_.add(AnalysisMessages.CALL_INT_NEED_TYPE,"CallIntNeedType=Initializing the interface {0} from the type {1} is needed.");
en_.add(AnalysisMessages.CALL_INT_ONLY,"CallIntOnly=The type {0} is not an interface.");
en_.add(AnalysisMessages.BAD_INHERITS_TYPE,"BadInheritsType=The type {0} cannot have the type {1} as super type.");
en_.add(AnalysisMessages.BAD_INHERITS_TYPE_INN,"BadInheritsTypeInn=The type {0} cannot have the type {1} as super type because {1} is instance type.");
en_.add(AnalysisMessages.BAD_INHERITS_TYPE_AS_INN,"BadInheritsTypeAsInn=The type {0} cannot have the type {1} as super type because {0} has {2} parents types and {1} has {3} parents types.");
en_.add(AnalysisMessages.BAD_INHERITS_TYPE_INT,"BadInheritsTypeInt=The type {0} cannot have the type {1} as super type because {1} is not an interface.");
en_.add(AnalysisMessages.FINAL_TYPE,"FinalType=The type {0} cannot have the type {1} as super type because {1} is final.");
en_.add(AnalysisMessages.DUPLICATE_SUPER,"DuplicateSuper=The type {0} cannot have the type {1} duplicated as super type {2} times.");
en_.add(AnalysisMessages.RESERVED_TYPE,"ReservedType=The type {0} cannot have explicitly the type {1} as super type because {1} is reserved.");
en_.add(AnalysisMessages.SUPER_CLASS,"SuperClass=The class {0} cannot have more than one super class ({1} times).");
en_.add(AnalysisMessages.UNKNOWN_SUPER_TYPE,"UnknownSuperType=The super types of the static type {0} could not be found.");
en_.add(AnalysisMessages.CYCLIC_INHERITS,"CyclicInherits=The type {0} belongs to a cyclic inheriting.");
en_.add(AnalysisMessages.ANNOTATION_PARAM,"AnnotationParam=The annotation {0} cannot be parameterized.");
en_.add(AnalysisMessages.CYCLIC_MAPPING,"CyclicMapping=The type variables of the type {0} have a cyclic inheriting.");
en_.add(AnalysisMessages.ABS_MAPPING,"AbsMapping=There are {0} abstract types as upper bounds.");
en_.add(AnalysisMessages.FINAL_MAPPING,"FinalMapping=There is at least one final type as upper bound ({0} times).");
en_.add(AnalysisMessages.MUST_CALL_INT_CTOR,"MustCallIntCtor=The type {0} must have a constructor because of implementing interfaces with instance elements.");
en_.add(AnalysisMessages.MUST_NOT_CALL_INT_CTOR_AFTER_THIS,"MustNotCallIntCtorAfterThis=There must not be have constructor call after an alternate constructor call.");
en_.add(AnalysisMessages.MUST_CALL_INT_CTOR_NEED,"MustCallIntCtorNeed=A constructor of the type {0} must be called in the constructor.");
en_.add(AnalysisMessages.MUST_CALL_INT_CTOR_NOT_NEED,"MustCallIntCtorNotNeed=A constructor of the type {0} must not be called in the constructor.");
en_.add(AnalysisMessages.BAD_LABEL,"BadLabel=A label must be a word (included characters dollars).");
en_.add(AnalysisMessages.DUPLICATED_LABEL,"DuplicatedLabel=The label is duplicated.");
en_.add(AnalysisMessages.BAD_METHOD_NAME,"BadMethodName=The method name {0} is not valid. It must be a word.");
en_.add(AnalysisMessages.KEY_WORD_METHOD_NAME,"KeyWordMethodName=The method name {0} is not valid. It must not be a key word.");
en_.add(AnalysisMessages.PRIM_METHOD_NAME,"PrimMethodName=The method name {0} is not valid. It must not a primitive type.");
en_.add(AnalysisMessages.DIGIT_METHOD_NAME,"DigitMethodName=The method name {0} is not valid. It must not start with a digit.");
en_.add(AnalysisMessages.BAD_OPERATOR_NAME,"BadOperatorName=The operator symbol {0} is not valid.");
en_.add(AnalysisMessages.BAD_ACCESS,"BadAccess=The method {0} must be public.");
en_.add(AnalysisMessages.BAD_RETURN_TYPE,"BadReturnType=The method {0} must have {1} as return type.");
en_.add(AnalysisMessages.BAD_PARAMS,"BadParams=The method {0} must have one parameter.");
en_.add(AnalysisMessages.BAD_METHOD_MODIFIER,"BadMethodModifier=The method {0} must be static.");
en_.add(AnalysisMessages.BAD_METHOD_VARARG,"BadMethodVararg=The method {0} must not be variable argument.");
en_.add(AnalysisMessages.BAD_INDEXER_PARAMS,"BadIndexerParams=The indexer {0} must have at least one parameter.");
en_.add(AnalysisMessages.BAD_INDEXER_MODIFIER,"BadIndexerModifier=The indexer {0} must not be static.");
en_.add(AnalysisMessages.BAD_INDEXER_MODIFIERS,"BadIndexerModifiers=The indexers {0} get and set must have the same modifier.");
en_.add(AnalysisMessages.BAD_INDEXER_ACCESSES,"BadIndexerAccesses=The indexers {0} get and set must have the same access.");
en_.add(AnalysisMessages.BAD_INDEXER_PAIR_GET,"BadIndexerPairGet=The indexer {0} get must be defined.");
en_.add(AnalysisMessages.BAD_INDEXER_PAIR_SET,"BadIndexerPairSet=The indexer {0} set must be defined.");
en_.add(AnalysisMessages.DUPLICATE_CUSTOM_METHOD,"DuplicateCustomMethod=The method {0} is duplicated.");
en_.add(AnalysisMessages.RESERVED_CUSTOM_METHOD,"ReservedCustomMethod=The method {0} is reserved.");
en_.add(AnalysisMessages.DUPLICATE_INDEXER,"DuplicateIndexer=The indexer {0} is duplicated.");
en_.add(AnalysisMessages.DUPLICATE_OPERATOR,"DuplicateOperator=The operator {0} is duplicated.");
en_.add(AnalysisMessages.FUNCTIONAL_APPLY_NB_DIFF,"FunctionalApplyNbDiff=The number of required arguments {0} is different from the number of supplied arguments {1} for the method of the elliptic type {2}");
en_.add(AnalysisMessages.FUNCTIONAL_APPLY_ONLY,"FunctionalApplyOnly=Only the method {0} can ne used for the elliptic type {1}");
en_.add(AnalysisMessages.OPERATOR_NB_DIFF,"OperatorNbDiff=The number of required operands {0} is different from the number of supplied arguments {1} for the operator {2}");
en_.add(AnalysisMessages.SPLIT_COMA,"SplitComa=The number of required splitted parts by comas {0} is greater than the number of supplied splitted parts by comas {1}.");
en_.add(AnalysisMessages.SPLIT_COMA_LOW,"SplitComaLow=The number of required splitted parts by comas {0} is lower than the number of supplied splitted parts by comas {1}.");
en_.add(AnalysisMessages.SPLIT_DIFF,"SplitDiff=The number of required operands {0} is different from the number of supplied arguments {1}.");
en_.add(AnalysisMessages.BAD_DOTTED,"BadDotted=The code part following the dot operator cannot be used.");
en_.add(AnalysisMessages.BAD_PARAM_NAME,"BadParamName=The parameter method name {0} is not valid. It must be a word.");
en_.add(AnalysisMessages.KEY_WORD_PARAM_NAME,"KeyWordParamName=The parameter method name {0} is not valid. It must not be a key word.");
en_.add(AnalysisMessages.PRIM_PARAM_NAME,"PrimParamName=The parameter method name {0} is not valid. It must not a primitive type.");
en_.add(AnalysisMessages.DIGIT_PARAM_NAME,"DigitParamName=The parameter method name {0} is not valid. It must not start with a digit.");
en_.add(AnalysisMessages.RESERVED_PARAM_NAME,"ReservedParamName=The parameter method name {0} is reserved for indexer set.");
en_.add(AnalysisMessages.DUPLICATED_PARAM_NAME,"DuplicatedParamName=The parameter function name {0} is duplicated.");
en_.add(AnalysisMessages.BAD_RETURN_TYPE_INHERIT,"BadReturnTypeInherit=The return type {0} of the method {1} of the type {2} is not sub type of the return type {3} of the method {4} of the type {5}");
en_.add(AnalysisMessages.BAD_RETURN_TYPE_INDEXER,"BadReturnTypeIndexer=The return type {0} of the indexer {1} of the type {2} is not the return type {3} of the indexer {4} of the type {5}");
en_.add(AnalysisMessages.DUPLICATED_OVERRIDING,"DuplicatedOverriding=The type {0} inherits a function {1} that is duplicated.");
en_.add(AnalysisMessages.TWO_FINAL,"TwoFinal=The type {0} inherits two final functions with key {1}.");
en_.add(AnalysisMessages.FINAL_NOT_SUB_RETURN_TYPE,"FinalNotSubReturnType=The return type {0} of the final method {1} of the type {2} is not sub type of the return type {3} of the method {4} of the type {5}");
en_.add(AnalysisMessages.TWO_RETURN_TYPES,"TwoReturnTypes=The merged methods with key {0} of the types {1} have the sub types {2} as return types.");
en_.add(AnalysisMessages.RETURN_TYPES,"ReturnTypes=The indexers with key {0} of the types {1} have the types {2} as return types.");
en_.add(AnalysisMessages.BAD_VARIABLE_NAME,"BadVariableName=The variable name {0} is not valid. It must be a word.");
en_.add(AnalysisMessages.KEY_WORD_VARIABLE_NAME,"KeyWordVariableName=The variable name {0} is not valid. It must not be a key word.");
en_.add(AnalysisMessages.PRIM_VARIABLE_NAME,"PrimVariableName=The variable name {0} is not valid. It must not a primitive type.");
en_.add(AnalysisMessages.DIGIT_VARIABLE_NAME,"DigitVariableName=The variable name {0} is not valid. It must not start with a digit.");
en_.add(AnalysisMessages.DUPLICATED_VARIABLE_NAME,"DuplicatedVariableName=The variable name {0} is not valid. It must not be the name of an other variable of the scope.");
en_.add(AnalysisMessages.CYCLIC_CTOR_CALL,"CyclicCtorCall=The constructors {0} of the type {1} belong to cyclic calls.");
en_.add(AnalysisMessages.DEAD_CODE,"DeadCode=The code is unreachable in the function {0}");
en_.add(AnalysisMessages.DEAD_CODE_TERNARY,"DeadCodeTernary=A part of code is unreachable in this ternary operation.");
en_.add(AnalysisMessages.UNUSED_PARAM_STATIC,"UnusedParamStatic=The parameter {0} is unused.");
en_.add(AnalysisMessages.DUPLICATED_CTOR,"DuplicatedCtor=The constructor {0} is duplicated.");
en_.add(AnalysisMessages.DUPLICATED_GENERIC_SUPER_TYPES,"DuplicatedGenericSuperTypes=The generic super types {0} are duplicated.");
en_.add(AnalysisMessages.DUPLICATED_INNER_TYPE,"DuplicatedInnerType=The inner type simple name {0} is duplicated.");
en_.add(AnalysisMessages.DUPLICATED_TYPE,"DuplicatedType=The type name {0} is duplicated with an other custom type.");
en_.add(AnalysisMessages.DUPLICATED_TYPE_PRIM,"DuplicatedTypePrim=The type name {0} is duplicated with a primitive type.");
en_.add(AnalysisMessages.DUPLICATED_TYPE_STD,"DuplicatedTypeStd=The type name {0} is duplicated with a standard type.");
en_.add(AnalysisMessages.DUPLICATED_TYPE_PKG,"DuplicatedTypePkg=The type name {0} is shadowed by the package {1}.");
en_.add(AnalysisMessages.EMPTY_EXPRESSION_PART,"EmptyExpressionPart=The expression part is empty.");
en_.add(AnalysisMessages.DO_WHILE_NOT_EMPTY,"DoWhileNotEmpty=The {0} block associated to a {1} block must be empty.");
en_.add(AnalysisMessages.DUPLICATED_FINAL,"DuplicatedFinal=The function {0} of the type {1} is final. So overriding it is forbidden.");
en_.add(AnalysisMessages.ILLEGAL_CTOR_ENUM,"IllegalCtorEnum=A constructor of a enum cannot be called explicitly.");
en_.add(AnalysisMessages.ILLEGAL_GENERIC_SUPER_TYPE_BOUND,"IllegalGenericSuperTypeBound=The argument {0} of the generic super type {1} is bound. It cannot be used in generic super type.");
en_.add(AnalysisMessages.ILLEGAL_CTOR_ANNOTATION,"IllegalCtorAnnotation=After @ the type {0} is not an annotation.");
en_.add(AnalysisMessages.ILLEGAL_CTOR_ABSTRACT,"IllegalCtorAbstract=The type {0} cannot be instantiated because of abstract.");
en_.add(AnalysisMessages.ILLEGAL_CTOR_BOUND,"IllegalCtorBound=The argument {0} of the type {1} is bound. It cannot be used in constructor call.");
en_.add(AnalysisMessages.ILLEGAL_CTOR_ARRAY,"IllegalCtorArray=The type {0} is an array type. It cannot be used as previous dotted argument for instancing.");
en_.add(AnalysisMessages.ILLEGAL_CTOR_UNKNOWN,"IllegalCtorUnknown=The type {0} is not resolved for instancing.");
en_.add(AnalysisMessages.MISSING_ABRUPT,"MissingAbrupt=A {0} block or a {1} block is missing for the method {2}.");
en_.add(AnalysisMessages.NOT_INIT_CLASS,"NotInitClass=The type {0} is not initialized.");
en_.add(AnalysisMessages.NULL_VALUE,"NullValue=The value must not be null because of possible {0}.");
en_.add(AnalysisMessages.BAD_PARAME_TYPE_FOR_ID,"BadParameTypeForId=The parameter type {0} is not resolved for getting identity function.");
en_.add(AnalysisMessages.NOT_RESOLVED_OWNER,"NotResolvedOwner=The owner for the type {0} is not resolved for instancing.");
en_.add(AnalysisMessages.UNDEFINED_ACCESSIBLE_FIELD,"UndefinedAccessibleField=There is no accessible field named {0} from the type {1} in this context.");
en_.add(AnalysisMessages.STATIC_ACCESS,"StaticAccess=The context is static. The key word {0} cannot be used in this context.");
en_.add(AnalysisMessages.STATIC_ACCESS_PREV,"StaticAccessPrev=A type must be used to access the key word {0}.");
en_.add(AnalysisMessages.UNASSIGNED_FINAL_FIELD,"UnassignedFinalField=The field {0} of the type {1} is not assigned with a constant.");
en_.add(AnalysisMessages.UNASSIGNED_INFERING_TYPE,"UnassignedInferingType=The inferring type {0} is not defined for the variables {1}.");
en_.add(AnalysisMessages.UNDEFINED_CTOR,"UndefinedCtor=The constructor {0} is undefined.");
en_.add(AnalysisMessages.UNDEFINED_METHOD,"UndefinedMethod=The function {0} is undefined.");
en_.add(AnalysisMessages.ARRAY_CLONE_ONLY,"ArrayCloneOnly=Only the method {0} can ne used for the array type {1}");
en_.add(AnalysisMessages.UNDEFINED_SUPER_CTOR,"UndefinedSuperCtor=No super constructor with implicit call is defined and accessible. There must be at least one constructor for the type {0}");
en_.add(AnalysisMessages.UNDEFINED_SUPER_CTOR_CALL,"UndefinedSuperCtorCall=No super constructor with implicit call is defined and accessible. The explicit call of a super constructor is required for the constructor {0}.");
en_.add(AnalysisMessages.UNDEFINED_VARIABLE,"UndefinedVariable=The variable {0} is undefined in this context.");
en_.add(AnalysisMessages.UNEXPECTED_AFFECT,"UnexpectedAffect=The assignment operator {0} is unexpected.");
en_.add(AnalysisMessages.FINAL_FIELD,"FinalField=The field {0} is already assigned.");
en_.add(AnalysisMessages.BAD_OPERATOR_REF,"BadOperatorRef=The string {0} is not an operator reference.");
en_.add(AnalysisMessages.UNEXPECTED_CATCH_ELSE_FINALLY,"UnexpectedCatchElseFinally=The {0} block must be preceded by one of the blocks {1}.");
en_.add(AnalysisMessages.UNEXPECTED_ABRUPT,"UnexpectedAbrupt=The {0} block must be inner of the blocks {1}.");
en_.add(AnalysisMessages.UNEXPECTED_ABRUPT_LAB,"UnexpectedAbruptLab=The {0} block with label {1} must be inner of a labelled with {2} block.");
en_.add(AnalysisMessages.UNEXPECTED_CASE_DEF,"UnexpectedCaseDef=The {0} block with expression {1} must be child of a block {2}.");
en_.add(AnalysisMessages.UNEXPECTED_CASE_VAR,"UnexpectedCaseVar=The {0} block with expression {1} is not constant.");
en_.add(AnalysisMessages.UNEXPECTED_CASE_VALUE,"UnexpectedCaseValue=The {0} block with value {1} is not a sub type of {2}.");
en_.add(AnalysisMessages.UNEXPECTED_CASE_DUP,"UnexpectedCaseDup=The {0} block with value {1} is duplicated in the parent {2} block.");
en_.add(AnalysisMessages.UNEXPECTED_DEF_DUP,"UnexpectedDefDup=The {0} block is duplicated in the parent {1} block.");
en_.add(AnalysisMessages.UNEXPECTED_DO_TRY,"UnexpectedDoTry=The {0} block must be followed by one of the blocks {1}.");
en_.add(AnalysisMessages.UNEXPECTED_SWITCH,"UnexpectedSwitch=The {0} block must contain only one of the blocks {1}.");
en_.add(AnalysisMessages.UNEXPECTED_MEMBER_INST,"UnexpectedMemberInst=The instance type {0} must contain only instance types and instance initilizing blocks.");
en_.add(AnalysisMessages.UNEXPECTED_BLOCK_EXP,"UnexpectedBlockExp=The block is unexpected.");
en_.add(AnalysisMessages.UNEXPECTED_OPERAND_TYPES,"UnexpectedOperandTypes=The operands types {0} for the operator {1} are unexpected.");
en_.add(AnalysisMessages.UNKNOWN_TYPE,"UnknownType=The type {0} is unknown.");
en_.add(AnalysisMessages.EMPTY_TYPE,"EmptyType=There must be a type.");
en_.add(AnalysisMessages.BAD_PARAMERIZED_TYPE,"BadParamerizedType=The type {0} is not parameterized correctly.");
en_.add(AnalysisMessages.UNEXPECTED_TYPE_BOUND,"UnexpectedTypeBound=The type {0} is unexpected for bound.");
en_.add(AnalysisMessages.UNEXPECTED_VARARG,"UnexpectedVararg=The three dots are unexpected here.");
en_.add(AnalysisMessages.UNEXPECTED_LEAF,"UnexpectedLeaf=The key word {0} is unexpected here.");
en_.add(AnalysisMessages.CASE_TYPE_VAR,"CaseTypeVar=This case block must be constant.");
en_.add(AnalysisMessages.EMPTY_PART,"EmptyPart=There must be an expression.");
return en_;
}

public static TranslationsFile fr(){
TranslationsFile fr_=new TranslationsFile();
fr_.add(AnalysisMessages.DUPLICATE_MERGED_METHOD,"DuplicateMergedMethod=le nom de méthode fusionné {0}:{1} est dupliqué.");
fr_.add(AnalysisMessages.DUPLICATE_FIELD,"DuplicateField=le nom de champ {0} est dupliqué.");
fr_.add(AnalysisMessages.DUPLICATE_VAR_TYPE,"DuplicateVarType=le nom de type variable {0} est dupliqué.");
fr_.add(AnalysisMessages.EMPTY_PKG_REF_TYPE,"EmptyPkgRefType={0}:{1} n''appartient pas à un paquetage.");
fr_.add(AnalysisMessages.PRIMITIVE_KEY_WORD,"PrimitiveKeyWord=la primitive {0}:{1} est une chaine doublon d''un mot clé.");
fr_.add(AnalysisMessages.DEFAULT_PKG_REF_TYPE,"DefaultPkgRefType={0} correspond au paquetage par défaut {1}.");
fr_.add(AnalysisMessages.REF_TYPE_KEY_WORD,"RefTypeKeyWord=le type référence {0}:{1} contient une chaine doublon d''un mot clé.");
fr_.add(AnalysisMessages.DIGIT_FIRST_PRIMITIVE,"DigitFirstPrimitive={0} commence par {1} qui est un chiffre.");
fr_.add(AnalysisMessages.ILLEGAL_FIRST_CHAR,"IllegalFirstChar=le mot clé numérique {0} commence par {1} qui est illégal en tant que premier caractère");
fr_.add(AnalysisMessages.EMPTY_PRIMITIVE,"EmptyPrimitive={0} a une valeur de type primitive vide.");
fr_.add(AnalysisMessages.NOT_WORD_CHAR_PRIMITIVE,"NotWordCharPrimitive={0} contient un caractère {1} qui n''est pas un caractère de mot.");
fr_.add(AnalysisMessages.NOT_WORD_CHAR_REF_TYPE,"NotWordCharRefType={0} contient un caractère {1} qui n''est pas un caractère de mot.");
fr_.add(AnalysisMessages.EMPTY_REF_TYPE_IN,"EmptyRefTypeIn={0} a une valeur de type référence vide entre deux points {1}.");
fr_.add(AnalysisMessages.REF_TYPE_PRIMITIVE,"RefTypePrimitive=le type référence {0}:{1} contient une chaine doublon d''une primitive.");
fr_.add(AnalysisMessages.DIGIT_FIRST_REF_TYPE,"DigitFirstRefType={0} commence par {1} qui est un chiffre.");
fr_.add(AnalysisMessages.DUPLICATE_PRIMTIVE,"DuplicatePrimtive=la primitive {0} est dupliqué.");
fr_.add(AnalysisMessages.DUPLICATE_METHOD,"DuplicateMethod=le nom de méthode {0} est dupliqué.");
fr_.add(AnalysisMessages.DEFAULT_PKG_NO_MATCH,"DefaultPkgNoMatch=le paquetage par défaut {0} n''a pas de type référence.");
fr_.add(AnalysisMessages.DUPLICATE_REF_TYPE,"DuplicateRefType=le type référence {0} est dupliqué.");
fr_.add(AnalysisMessages.DIGIT_FIRST_METHOD,"DigitFirstMethod=le nom de méthode {0} dans le type référence {1} commence par {2} qui est un chiffre.");
fr_.add(AnalysisMessages.NOT_WORD_CHAR_FIELD,"NotWordCharField=le nom de champ {0} dans le type référence {1} contient a caractère {2} qui n''est pas un caractère de mot.");
fr_.add(AnalysisMessages.NOT_WORD_CHAR_METHOD,"NotWordCharMethod=le nom de méthode {0} dans le type référence {1} contient un caractère {2} qui n''est pas un caractère de mot.");
fr_.add(AnalysisMessages.VAR_TYPE_KEY_WORD,"VarTypeKeyWord=le nom de type variable {0} dans le type référence {1}:{2} est une chaine doublon d''un mot clé.");
fr_.add(AnalysisMessages.VAR_TYPE_PRIMITIVE,"VarTypePrimitive=le nom de type variable {0} dans le type référence {1}:{2} est une chaine doublon d''une primitive.");
fr_.add(AnalysisMessages.DIGIT_FIRST_VAR_TYPE,"DigitFirstVarType=le nom de type variable {0} dans le type référence {1} commence par {2} qui est un chiffre.");
fr_.add(AnalysisMessages.DUPLICATE_NUMBER_WORD,"DuplicateNumberWord={0} est dupliqué en tant que mot dans un nombre.");
fr_.add(AnalysisMessages.METHOD_PRIMITIVE,"MethodPrimitive=le nom de méthode {0} dans le type référence {1}:{2} est une chaine doublon d''une primitive.");
fr_.add(AnalysisMessages.FIELD_PRIMITIVE,"FieldPrimitive=le nom de champ {0} dans le type référence {1}:{2} est une chaine doublon d''une primitive.");
fr_.add(AnalysisMessages.DUPLICATE_STRING_WORD,"DuplicateStringWord={0} est dupliqué en tant que échappement dans une chaine.");
fr_.add(AnalysisMessages.DUPLICATE_KEY_WORD,"DuplicateKeyWord={0} est dupliqué en tant que mot clé.");
fr_.add(AnalysisMessages.DIGIT_FIRST_FIELD,"DigitFirstField=le nom de champ {0} dans le type référence {1} commence par {2} qui est un chiffre.");
fr_.add(AnalysisMessages.DUPLICATE_STARTING_NB,"DuplicateStartingNb=le mot dans un nombre {0} commence par le mot dans un nombre {1}.");
fr_.add(AnalysisMessages.DUPLICATE_STARTING_UNI,"DuplicateStartingUni=le mot d''échappement {0} commence par le caractère unicode d''échappement {1}.");
fr_.add(AnalysisMessages.DUPLICATE_STARTING,"DuplicateStarting=le mot d''échappement {0} commence par le mot d''échappement {1}.");
fr_.add(AnalysisMessages.NOT_WORD_CHAR_VAR_TYPE,"NotWordCharVarType=le nom de type variable {0} dans le type référence {1} contient a caractère {2} qui n''est pas un caractère de mot.");
fr_.add(AnalysisMessages.EMPTY_PRE_BIN,"EmptyPreBin=préfixe binaire vide");
fr_.add(AnalysisMessages.EMPTY_VAR_TYPE,"EmptyVarType=le type variable clé {0} dans le type référence {1} a un nom vide.");
fr_.add(AnalysisMessages.EMPTY_WORD,"EmptyWord={0} a un mot clé vide.");
fr_.add(AnalysisMessages.EMPTY_FIELD,"EmptyField=le champ clé {0} dans le type référence {1} a un nom vide.");
fr_.add(AnalysisMessages.EMPTY_NB,"EmptyNb={0} a un mot clé vide spécifique aux nombres.");
fr_.add(AnalysisMessages.NOT_WORD_CHAR,"NotWordChar={0} contient un caractère {1} qui n''est pas un caractère de mot.");
fr_.add(AnalysisMessages.EMPTY_PRE_HEX,"EmptyPreHex=préfixe hexadécimal vide");
fr_.add(AnalysisMessages.EMPTY_METHOD,"EmptyMethod=la méthode clé {0} dans le type référence {1} a un nom vide.");
fr_.add(AnalysisMessages.DIGIT_FIRST,"DigitFirst={0} commence par {1} qui est un chiffre.");
fr_.add(AnalysisMessages.EMPTY_BIN_EXP,"EmptyBinExp=exponentielle binaire vide");
fr_.add(AnalysisMessages.EMPTY_STRING,"EmptyString={0} a un mot clé vide spécifique aux chaines.");
fr_.add(AnalysisMessages.ILLEGAL_CHAR,"IllegalChar=le mot clé numérique {0} contient un caractère {1} qui est illégal.");
fr_.add(AnalysisMessages.METHOD_KEY_WORD,"MethodKeyWord=le nom de méthode {0} dans le type référence {1}:{2} est une chaine doublon d''un mot clé.");
fr_.add(AnalysisMessages.EMPTY_REF_TYPE,"EmptyRefType={0} a une valeur de type référence vide.");
fr_.add(AnalysisMessages.FIELD_KEY_WORD,"FieldKeyWord=le nom de champ {0} dans le type référence {1}:{2} est une chaine doublon d''un mot clé.");
fr_.add(AnalysisMessages.ABSTRACT_METHOD_BODY,"AbstractMethodBody=La méthode {1} dans le type {0} est abstraite et ne peut pas avoir de corps.");
fr_.add(AnalysisMessages.ABSTRACT_METHOD_CONC,"AbstractMethodConc=La méthode {1} dans le type concret {0} ne doit pas être abstraite.");
fr_.add(AnalysisMessages.ABSTRACT_METHOD_IMPL,"AbstractMethodImpl=La méthode {1} provenant du type {0} doit être redéfinie dans le type concret {2}.");
fr_.add(AnalysisMessages.ABSTRACT_METHOD_REF,"AbstractMethodRef=La méthode {1} provenant du type {0} ne doit pas être appelée directement à de son abstraction.");
fr_.add(AnalysisMessages.INACCESSIBLE_TYPE,"InaccessibleType=Le type {0} n''est pas accessible depuis le type {1}.");
fr_.add(AnalysisMessages.UNEXPECTED_TYPE,"UnexpectedType=Le type {0} est inattendu.");
fr_.add(AnalysisMessages.UNEXPECTED_RET_TYPE,"UnexpectedRetType=Le type de retour {0} dans la fonction {1} est inattendu.");
fr_.add(AnalysisMessages.METHODS_ACCESSES,"MethodsAccesses=La méthode {1} provenant du type {0} est strictement plus accessible que la méthode {3} provenant du type {2}.");
fr_.add(AnalysisMessages.EMPTY_PACKAGE,"EmptyPackage=Un type doit avoir un paquetage non vide.");
fr_.add(AnalysisMessages.EMPTY_PART_CLASS_NAME,"EmptyPartClassName=La partie ne doit pas être vide.");
fr_.add(AnalysisMessages.BAD_PART_CLASS_NAME,"BadPartClassName=La partie {0} dans un type n''est pas valide. Elle doit être un mot.");
fr_.add(AnalysisMessages.KEY_WORD_PART_CLASS_NAME,"KeyWordPartClassName=La partie {0} dans un type n''est pas valide. Elle ne doit pas être un mot clé.");
fr_.add(AnalysisMessages.PRIM_PART_CLASS_NAME,"PrimPartClassName=La partie {0} dans un type n''est pas valide. Elle ne doit pas être un type primitif.");
fr_.add(AnalysisMessages.DIGIT_PART_CLASS_NAME,"DigitPartClassName=La partie {0} dans un type n''est pas valide. Elle ne doit pas commencer par un chiffre.");
fr_.add(AnalysisMessages.BAD_PART_VAR_CLASS_NAME,"BadPartVarClassName=La partie {0} dans un type variable n''est pas valide. Elle doit être un mot.");
fr_.add(AnalysisMessages.KEY_WORD_PART_VAR_CLASS_NAME,"KeyWordPartVarClassName=La partie {0} dans un type variable n''est pas valide. Elle ne doit pas être un mot clé.");
fr_.add(AnalysisMessages.PRIM_PART_VAR_CLASS_NAME,"PrimPartVarClassName=La partie {0} dans un type variable n''est pas valide. Elle ne doit pas être un type primitif.");
fr_.add(AnalysisMessages.DIGIT_PART_VAR_CLASS_NAME,"DigitPartVarClassName=La partie {0} dans un type variable n''est pas valide. Elle ne doit pas commencer par un chiffre.");
fr_.add(AnalysisMessages.DUPLICATED_PART_VAR_CLASS_NAME,"DuplicatedPartVarClassName=La partie {0} dans un type variable est dupliquée.");
fr_.add(AnalysisMessages.CALL_CTOR_END,"CallCtorEnd=L''appel d''un constructeur passant l''instance implicitement doit être effectué à la fin de l''instruction.");
fr_.add(AnalysisMessages.CALL_CTOR,"CallCtor=L''appel d''un constructeur passant l''instance implicitement doit être effectué dans un constructeur.");
fr_.add(AnalysisMessages.CALL_CTOR_BEFORE_BLOCK,"CallCtorBeforeBlock=L''appel d''un constructeur passant l''instance implicitement doit être effectué avant un bloc d''instructions.");
fr_.add(AnalysisMessages.CALL_CTOR_FIRST_LINE,"CallCtorFirstLine=L''appel d''un constructeur du type ou de la super classe passant l''instance implicitement doit être effectué sur la première ligne.");
fr_.add(AnalysisMessages.CALL_CTOR_INT_FROM_SUPER_INT,"CallCtorIntFromSuperInt=L''appel d''un constructeur d''interface doit référencer une super interface du type appelant.");
fr_.add(AnalysisMessages.CALL_CTOR_INT_NOT_FROM_INT,"CallCtorIntNotFromInt=L''appel d''un constructeur d''interface ne doit pas être fait dans un constructeur d''interface.");
fr_.add(AnalysisMessages.CALL_CTOR_INT_AFTER_SUPER_THIS,"CallCtorIntAfterSuperThis=Un appel d''un constructeur d''interface ne peut être effectué qu''après un appel de constructeur passant l''instance implicitement.");
fr_.add(AnalysisMessages.CALL_CTOR_INT_INHERITS,"CallCtorIntInherits=L''appel du constructeur de l''interface {0} ne peut pas être effectué avant l''appel du constructeur de l''interface {1}.");
fr_.add(AnalysisMessages.CALL_CTOR_SUPER_CLASS_ENUM_SINGLETON,"CallCtorSuperClassEnumSingleton=Le super constructeur ne peut être appelé que depuis une classe ou une enumération (singleton ou normale).");
fr_.add(AnalysisMessages.CALL_CTOR_NO_SUPER_CLASS_ENUM,"CallCtorNoSuperClassEnum=Il n''y a pas de type utilisateur à être appelé depuis cette classe ou énumération (singleton or normale).");
fr_.add(AnalysisMessages.ANNOT_FIELD_NOT_UNIQ,"AnnotFieldNotUniq=Le champ de l''annotatation n''a pas être trouvé de manière unique.");
fr_.add(AnalysisMessages.ANNOT_FIELD_MUST,"AnnotFieldMust=Le champ {0} de l''annotatation est obligatoire.");
fr_.add(AnalysisMessages.DUP_SUPPLIED_ANNOT_FIELD,"DupSuppliedAnnotField=Le champ {0} de l''annotatation est fourni en doublon.");
fr_.add(AnalysisMessages.BAD_EXPRESSION,"BadExpression=Caractère inattendu {0} à la position {1} dans l''expression {2}");
fr_.add(AnalysisMessages.BAD_FIELD_NAME,"BadFieldName=Le nom de champ {0} n''est pas valide. Il doit être un mot.");
fr_.add(AnalysisMessages.KEY_WORD_FIELD_NAME,"KeyWordFieldName=Le nom de champ {0} n''est pas valide. Il ne doit pas être un mot clé.");
fr_.add(AnalysisMessages.PRIM_FIELD_NAME,"PrimFieldName=Le nom de champ {0} n''est pas valide. Il ne doit pas être un type primitif.");
fr_.add(AnalysisMessages.DIGIT_FIELD_NAME,"DigitFieldName=Le nom de champ {0} n''est pas valide. Il ne doit pas commencer par un chiffre.");
fr_.add(AnalysisMessages.NOT_RETRIEVED_FIELDS,"NotRetrievedFields=Aucun champ n''a pas être récupéré.");
fr_.add(AnalysisMessages.BAD_NB_FORMAT,"BadNbFormat=Mauvais format de nombre {0}");
fr_.add(AnalysisMessages.BAD_CHAR_FORMAT,"BadCharFormat=Mauvais format de caractère {0}");
fr_.add(AnalysisMessages.BAD_IMPLICIT_CAST,"BadImplicitCast=Le type {0} ne peut pas être implicitement converti en {1}");
fr_.add(AnalysisMessages.NOT_PRIMITIVE_WRAPPER,"NotPrimitiveWrapper=Le type {0} n''est pas un type primitive ou un type enveloppeur.");
fr_.add(AnalysisMessages.VOID_TYPE,"VoidType=Le type ne peut pas être le mot clé {0}.");
fr_.add(AnalysisMessages.BAD_INDEX_IN_PARSER,"BadIndexInParser=Mauvais indice en parsant.");
fr_.add(AnalysisMessages.ILLEGAL_CHARACTER,"IllegalCharacter=Les caractères ascii {0} sont illégaux.");
fr_.add(AnalysisMessages.CALL_INT_INHERITS,"CallIntInherits=Initialiser l''interface {0} ne peut pas être effectué avant d''initialiser l''interface {1}.");
fr_.add(AnalysisMessages.CALL_INT_NO_NEED,"CallIntNoNeed=Initialiser un type depuis l''interface {0} n''est pas nécessaire.");
fr_.add(AnalysisMessages.CALL_INT_NO_NEED_TYPE,"CallIntNoNeedType=Initialiser l''interface {0} depuis le type {1} n''est pas nécessaire.");
fr_.add(AnalysisMessages.CALL_INT_NEED_TYPE,"CallIntNeedType=Initialiser l''interface {0} depuis le type {1} est nécessaire.");
fr_.add(AnalysisMessages.CALL_INT_ONLY,"CallIntOnly=Le type {0} n''est pas une interface.");
fr_.add(AnalysisMessages.BAD_INHERITS_TYPE,"BadInheritsType=Le type {0} ne peut pas avoir le type {1} en tant que super type.");
fr_.add(AnalysisMessages.BAD_INHERITS_TYPE_INN,"BadInheritsTypeInn=Le type {0} ne peut pas avoir le type {1} en tant que super type parce que {1} est un type d''instance.");
fr_.add(AnalysisMessages.BAD_INHERITS_TYPE_AS_INN,"BadInheritsTypeAsInn=Le type {0} ne peut pas avoir le type {1} en tant que super type parce que {1} est un type d''instance.");
fr_.add(AnalysisMessages.BAD_INHERITS_TYPE_INT,"BadInheritsTypeInt=Le type {0} ne peut pas avoir le type {1} en tant que super type parce que {1} n''est pas une interface.");
fr_.add(AnalysisMessages.FINAL_TYPE,"FinalType=Le type {0} ne peut pas avoir le type {1} en tant que super type parce que {1} est final.");
fr_.add(AnalysisMessages.DUPLICATE_SUPER,"DuplicateSuper=Le type {0} ne peut pas avoir le type {1} dupliqué en tant que super type {2} fois.");
fr_.add(AnalysisMessages.RESERVED_TYPE,"ReservedType=Le type {0} ne peut pas avoir explicitement le the type {1} en tant que super type parce que {1} est réservé.");
fr_.add(AnalysisMessages.SUPER_CLASS,"SuperClass=La classe {0} ne peut pas avoir plus d''une super classe ({1} fois).");
fr_.add(AnalysisMessages.UNKNOWN_SUPER_TYPE,"UnknownSuperType=Les super types du type static {0} n''ont pas pu être trouvés.");
fr_.add(AnalysisMessages.CYCLIC_INHERITS,"CyclicInherits=Le type {0} appartient à un héritage cyclique.");
fr_.add(AnalysisMessages.ANNOTATION_PARAM,"AnnotationParam=L''annotation {0} ne peut pas être paramétrée.");
fr_.add(AnalysisMessages.CYCLIC_MAPPING,"CyclicMapping=Les types variables du type {0} ont un héritage cyclique.");
fr_.add(AnalysisMessages.ABS_MAPPING,"AbsMapping=Il y a {0} types abstraits en tant que bornes supérieures.");
fr_.add(AnalysisMessages.FINAL_MAPPING,"FinalMapping=Il y a au moins un type final en tant que borne supérieure ({0} fois).");
fr_.add(AnalysisMessages.MUST_CALL_INT_CTOR,"MustCallIntCtor=Le type {0} doit avoir un constructeur vu l''implementation d''interfaces avec des éléments d''instance.");
fr_.add(AnalysisMessages.MUST_NOT_CALL_INT_CTOR_AFTER_THIS,"MustNotCallIntCtorAfterThis=Il ne doit pas y avoir un appel de constructor après un appel de constructor alternatif.");
fr_.add(AnalysisMessages.MUST_CALL_INT_CTOR_NEED,"MustCallIntCtorNeed=Un constructor du type {0} doit être appelé dans le constructeur.");
fr_.add(AnalysisMessages.MUST_CALL_INT_CTOR_NOT_NEED,"MustCallIntCtorNotNeed=Un constructor du type {0} ne doit pas être appelé dans le constructeur.");
fr_.add(AnalysisMessages.BAD_LABEL,"BadLabel=Un étiquette doit être un mot (pouvant inclure des caractères dollars).");
fr_.add(AnalysisMessages.DUPLICATED_LABEL,"DuplicatedLabel=L''étiquette est dupliquée.");
fr_.add(AnalysisMessages.BAD_METHOD_NAME,"BadMethodName=Le nom de méthode {0} n''est pas valide. Il doit être un mot.");
fr_.add(AnalysisMessages.KEY_WORD_METHOD_NAME,"KeyWordMethodName=Le nom de méthode {0} n''est pas valide. Il ne doit pas être un mot clé.");
fr_.add(AnalysisMessages.PRIM_METHOD_NAME,"PrimMethodName=Le nom de méthode {0} n''est pas valide. Il ne doit pas être un type primitif.");
fr_.add(AnalysisMessages.DIGIT_METHOD_NAME,"DigitMethodName=Le nom de méthode {0} n''est pas valide. Il ne doit pas commencer par un chiffre.");
fr_.add(AnalysisMessages.BAD_OPERATOR_NAME,"BadOperatorName=Le symbole d''opérateur {0} n''est pas valide.");
fr_.add(AnalysisMessages.BAD_ACCESS,"BadAccess=La méthode {0} doit être publique.");
fr_.add(AnalysisMessages.BAD_RETURN_TYPE,"BadReturnType=La méthode {0} doit avoir {1} as return type.");
fr_.add(AnalysisMessages.BAD_PARAMS,"BadParams=La méthode {0} doit avoir un paramètre.");
fr_.add(AnalysisMessages.BAD_METHOD_MODIFIER,"BadMethodModifier=La méthode {0} doit être statique.");
fr_.add(AnalysisMessages.BAD_METHOD_VARARG,"BadMethodVararg=La méthode {0} ne doit pas être avec un nombre d''argument variable.");
fr_.add(AnalysisMessages.BAD_INDEXER_PARAMS,"BadIndexerParams=L''indexeur {0} doit avoir au moins un paramètre.");
fr_.add(AnalysisMessages.BAD_INDEXER_MODIFIER,"BadIndexerModifier=L''indexeur {0} ne doit pas être static.");
fr_.add(AnalysisMessages.BAD_INDEXER_MODIFIERS,"BadIndexerModifiers=Les indexeurs {0} lecture et écriture doivent avoir le même modificateur.");
fr_.add(AnalysisMessages.BAD_INDEXER_ACCESSES,"BadIndexerAccesses=Les indexeurs {0} lecture et écriture doivent avoir le même accès.");
fr_.add(AnalysisMessages.BAD_INDEXER_PAIR_GET,"BadIndexerPairGet=L''indexeur {0} lecture doit être defini.");
fr_.add(AnalysisMessages.BAD_INDEXER_PAIR_SET,"BadIndexerPairSet=L''indexeur {0} écriture doit être defini.");
fr_.add(AnalysisMessages.DUPLICATE_CUSTOM_METHOD,"DuplicateCustomMethod=La méthode {0} est dupliquée.");
fr_.add(AnalysisMessages.RESERVED_CUSTOM_METHOD,"ReservedCustomMethod=La méthode {0} est réservée.");
fr_.add(AnalysisMessages.DUPLICATE_INDEXER,"DuplicateIndexer=L''indexeur {0} est dupliqué.");
fr_.add(AnalysisMessages.DUPLICATE_OPERATOR,"DuplicateOperator=L''opérateur {0} est dupliqué.");
fr_.add(AnalysisMessages.FUNCTIONAL_APPLY_NB_DIFF,"FunctionalApplyNbDiff=Le nombre d''arguments obligatoires {0} est différent du nombre d''arguments fournis {1} pour la méthode du type elliptique {2}");
fr_.add(AnalysisMessages.FUNCTIONAL_APPLY_ONLY,"FunctionalApplyOnly=Seule la méthode {0} peut être utilisée pour le type elliptique {1}");
fr_.add(AnalysisMessages.OPERATOR_NB_DIFF,"OperatorNbDiff=Le nombre d''opérandes obligatoires {0} est différent du nombre d''opérandes fournis {1} pour l''opérateur {2}");
fr_.add(AnalysisMessages.SPLIT_COMA,"SplitComa=Le nombre de parties obligatoires séparées par virgules {0} est supérieur au nombre de parties fournies séparées par virgules {1}.");
fr_.add(AnalysisMessages.SPLIT_COMA_LOW,"SplitComaLow=Le nombre de parties obligatoires séparées par virgules {0} est inférieur au nombre de parties fournies séparées par virgules {1}.");
fr_.add(AnalysisMessages.SPLIT_DIFF,"SplitDiff=Le nombre d''opérandes obligatoires {0} est différent du nombre d''opérandes fournis {1}.");
fr_.add(AnalysisMessages.BAD_DOTTED,"BadDotted=La partie de code suivant l''opérateur point ne peut pas être utilisée.");
fr_.add(AnalysisMessages.BAD_PARAM_NAME,"BadParamName=Le nom de paramètre méthode {0} n''est pas valide. Il doit être un mot.");
fr_.add(AnalysisMessages.KEY_WORD_PARAM_NAME,"KeyWordParamName=Le nom de paramètre méthode {0} n''est pas valide. Il ne doit pas être un mot clé.");
fr_.add(AnalysisMessages.PRIM_PARAM_NAME,"PrimParamName=Le nom de paramètre méthode {0} n''est pas valide. Il ne doit pas être un type primitif.");
fr_.add(AnalysisMessages.DIGIT_PARAM_NAME,"DigitParamName=Le nom de paramètre méthode {0} n''est pas valide. Il ne doit pas commencer par un chiffre.");
fr_.add(AnalysisMessages.RESERVED_PARAM_NAME,"ReservedParamName=Le nom de paramètre méthode {0} est réservé pour un indexeur écriture.");
fr_.add(AnalysisMessages.DUPLICATED_PARAM_NAME,"DuplicatedParamName=Le nom de paramètre fonction {0} est dupliqué.");
fr_.add(AnalysisMessages.BAD_RETURN_TYPE_INHERIT,"BadReturnTypeInherit=Le type de retour {0} de la méthode {1} du type {2} n''est pas sous type du type de retour {3} de la méthode {4} du type {5}");
fr_.add(AnalysisMessages.BAD_RETURN_TYPE_INDEXER,"BadReturnTypeIndexer=Le type de retour {0} de l''indexer {1} du type {2} n''est pas le type de retour {3} de l''indexer {4} du type {5}");
fr_.add(AnalysisMessages.DUPLICATED_OVERRIDING,"DuplicatedOverriding=Le type {0} hérite une fonction {1} qui est dupliquée.");
fr_.add(AnalysisMessages.TWO_FINAL,"TwoFinal=Le type {0} hérite deux fonctions finales de clé {1}.");
fr_.add(AnalysisMessages.FINAL_NOT_SUB_RETURN_TYPE,"FinalNotSubReturnType=Le type de retour {0} de la méthode finale {1} du type {2} n''est pas sous type du type de retour {3} de la méthode {4} du type {5}");
fr_.add(AnalysisMessages.TWO_RETURN_TYPES,"TwoReturnTypes=Les méthodes fusionnées avec pour clé {0} des types {1} ont pour sous types {2} en tant que types de retour.");
fr_.add(AnalysisMessages.RETURN_TYPES,"ReturnTypes=Les indexeurs avec pour clé {0} des types {1} ont pour types {2} en tant que types de retour.");
fr_.add(AnalysisMessages.BAD_VARIABLE_NAME,"BadVariableName=Le nom de variable {0} n''est pas valide. Il doit être un mot.");
fr_.add(AnalysisMessages.KEY_WORD_VARIABLE_NAME,"KeyWordVariableName=Le nom de variable {0} n''est pas valide. Il ne doit pas être un mot clé.");
fr_.add(AnalysisMessages.PRIM_VARIABLE_NAME,"PrimVariableName=Le nom de variable {0} n''est pas valide. Il ne doit pas être un type primitif.");
fr_.add(AnalysisMessages.DIGIT_VARIABLE_NAME,"DigitVariableName=Le nom de variable {0} n''est pas valide. Il ne doit pas commencer par un chiffre.");
fr_.add(AnalysisMessages.DUPLICATED_VARIABLE_NAME,"DuplicatedVariableName=Le nom de variable {0} n''est pas valide. Il ne doit pas être le nom d''une autre variable du scope.");
fr_.add(AnalysisMessages.CYCLIC_CTOR_CALL,"CyclicCtorCall=Les constructeurs {0} du type {1} appartiennent à des appels cycliques.");
fr_.add(AnalysisMessages.DEAD_CODE,"DeadCode=Le code est inatteignable dans la fonction {0}");
fr_.add(AnalysisMessages.DEAD_CODE_TERNARY,"DeadCodeTernary=Une partie du code est inatteignable dans cette opération ternaire.");
fr_.add(AnalysisMessages.UNUSED_PARAM_STATIC,"UnusedParamStatic=Le paramètre {0} est inutilisé.");
fr_.add(AnalysisMessages.DUPLICATED_CTOR,"DuplicatedCtor=Le constructeur {0} est dupliqué.");
fr_.add(AnalysisMessages.DUPLICATED_GENERIC_SUPER_TYPES,"DuplicatedGenericSuperTypes=Les super types génériques {0} sont dupliqués.");
fr_.add(AnalysisMessages.DUPLICATED_INNER_TYPE,"DuplicatedInnerType=Le simple nom du type interne {0} est dupliqué.");
fr_.add(AnalysisMessages.DUPLICATED_TYPE,"DuplicatedType=Le nom du type {0} est dupliqué avec un autre type client.");
fr_.add(AnalysisMessages.DUPLICATED_TYPE_PRIM,"DuplicatedTypePrim=Le nom du type {0} est dupliqué avec un type primitif.");
fr_.add(AnalysisMessages.DUPLICATED_TYPE_STD,"DuplicatedTypeStd=Le nom du type {0} est dupliqué avec un type standard.");
fr_.add(AnalysisMessages.DUPLICATED_TYPE_PKG,"DuplicatedTypePkg=Le nom du type {0} est masqué par le paquetage {1}.");
fr_.add(AnalysisMessages.EMPTY_EXPRESSION_PART,"EmptyExpressionPart=La partie d''expression est vide.");
fr_.add(AnalysisMessages.DO_WHILE_NOT_EMPTY,"DoWhileNotEmpty=Le bloc {0} associé à un bloc {1} doit être vide.");
fr_.add(AnalysisMessages.DUPLICATED_FINAL,"DuplicatedFinal=La fonction {0} du type {1} est finale. Donc la redéfinir est interdit.");
fr_.add(AnalysisMessages.ILLEGAL_CTOR_ENUM,"IllegalCtorEnum=Un constructeur d''une énumération ne peut pas être appelée explicitement.");
fr_.add(AnalysisMessages.ILLEGAL_GENERIC_SUPER_TYPE_BOUND,"IllegalGenericSuperTypeBound=L''argument {0} du super type générique {1} est une borne. Il ne peut pas être utilisé dans un super type générique.");
fr_.add(AnalysisMessages.ILLEGAL_CTOR_ANNOTATION,"IllegalCtorAnnotation=Après @ le type {0} n''est pas une annotation.");
fr_.add(AnalysisMessages.ILLEGAL_CTOR_ABSTRACT,"IllegalCtorAbstract=Le type {0} ne peut pas être instancié étant donné son abstraction.");
fr_.add(AnalysisMessages.ILLEGAL_CTOR_BOUND,"IllegalCtorBound=L''argument {0} du type {1} est une borne. Il ne peut pas être utilisé dans un appel de constructeur.");
fr_.add(AnalysisMessages.ILLEGAL_CTOR_ARRAY,"IllegalCtorArray=Le type {0} is an array type. Il ne peut pas être utilisé en tant qu''argument précéde d''un point pour instancier.");
fr_.add(AnalysisMessages.ILLEGAL_CTOR_UNKNOWN,"IllegalCtorUnknown=Le type {0} n''est pas résolu pour instancier.");
fr_.add(AnalysisMessages.MISSING_ABRUPT,"MissingAbrupt=Un bloc {0} ou un bloc {1} est manquant pour la méthode {2}.");
fr_.add(AnalysisMessages.NOT_INIT_CLASS,"NotInitClass=Le type {0} n''est pas initialisé.");
fr_.add(AnalysisMessages.NULL_VALUE,"NullValue=La valeur ne doit pas être nulle à de possibles {0}.");
fr_.add(AnalysisMessages.BAD_PARAME_TYPE_FOR_ID,"BadParameTypeForId=Le type de paramètre {0} n''est pas résolu pour obtenir l''identité d''une fonction.");
fr_.add(AnalysisMessages.NOT_RESOLVED_OWNER,"NotResolvedOwner=Le possesseur pour le type {0} n''est pas résolu pour instancier.");
fr_.add(AnalysisMessages.UNDEFINED_ACCESSIBLE_FIELD,"UndefinedAccessibleField=Il n''y pas de champ accessible nommé {0} depuis le type {1} dans ce contexte.");
fr_.add(AnalysisMessages.STATIC_ACCESS,"StaticAccess=Le context est statique. Le mot clé {0} ne peut pas être utilisé dans ce contexte.");
fr_.add(AnalysisMessages.STATIC_ACCESS_PREV,"StaticAccessPrev=Un type doit être utilisé pour accéder au mot clé {0}.");
fr_.add(AnalysisMessages.UNASSIGNED_FINAL_FIELD,"UnassignedFinalField=Le champ {0} du type {1} n''est pas assigné par une constante.");
fr_.add(AnalysisMessages.UNASSIGNED_INFERING_TYPE,"UnassignedInferingType=Le type d''inférence type {0} n''est pas défini pour les variables {1}.");
fr_.add(AnalysisMessages.UNDEFINED_CTOR,"UndefinedCtor=Le constructeur {0} est indéfini.");
fr_.add(AnalysisMessages.UNDEFINED_METHOD,"UndefinedMethod=La méthode {0} est indéfinie.");
fr_.add(AnalysisMessages.ARRAY_CLONE_ONLY,"ArrayCloneOnly=Seule la méthode {0} peut être utilisée pour le type tableau {1}");
fr_.add(AnalysisMessages.UNDEFINED_SUPER_CTOR,"UndefinedSuperCtor=Aucun super constructeur &agrave appel implicite n''est defin&eacute; et accessible. Il doit y avoir au moins un constructeur pour le type {0}");
fr_.add(AnalysisMessages.UNDEFINED_SUPER_CTOR_CALL,"UndefinedSuperCtorCall=Aucun super constructeur &agrave appel implicite n''est defin&eacute; et accessible. L''appel explicite d''un super constructeur est obligatoir pour le constructeur {0}.");
fr_.add(AnalysisMessages.UNDEFINED_VARIABLE,"UndefinedVariable=La variable {0} est indéfinie dans ce contexte.");
fr_.add(AnalysisMessages.UNEXPECTED_AFFECT,"UnexpectedAffect=L''opérateur d''assignement {0} est inattendu.");
fr_.add(AnalysisMessages.FINAL_FIELD,"FinalField=Le champ {0} est déjà assigné.");
fr_.add(AnalysisMessages.BAD_OPERATOR_REF,"BadOperatorRef=La chaine {0} n''est pas une référence d''opérateur.");
fr_.add(AnalysisMessages.UNEXPECTED_CATCH_ELSE_FINALLY,"UnexpectedCatchElseFinally=Le bloc {0} doit être précédé par un des blocs {1}.");
fr_.add(AnalysisMessages.UNEXPECTED_ABRUPT,"UnexpectedAbrupt=Le bloc {0} doit être interne aux blocs {1}.");
fr_.add(AnalysisMessages.UNEXPECTED_ABRUPT_LAB,"UnexpectedAbruptLab=Le bloc {0} avec étiquette {1} doit être interne à un bloc étiqueté avec {2}.");
fr_.add(AnalysisMessages.UNEXPECTED_CASE_DEF,"UnexpectedCaseDef=Le bloc {0} avec expression {1} doit être un enfant d''un bloc {2}.");
fr_.add(AnalysisMessages.UNEXPECTED_CASE_VAR,"UnexpectedCaseVar=Le bloc {0} avec expression {1} n''est pas constant.");
fr_.add(AnalysisMessages.UNEXPECTED_CASE_VALUE,"UnexpectedCaseValue=Le bloc {0} avec valeur {1} n''est pas un sous type de {2}.");
fr_.add(AnalysisMessages.UNEXPECTED_CASE_DUP,"UnexpectedCaseDup=Le bloc {0} avec valeur {1} est dupliqué in the parent {2} block.");
fr_.add(AnalysisMessages.UNEXPECTED_DEF_DUP,"UnexpectedDefDup=Le bloc {0} est dupliqué dans le bloc parent {1}.");
fr_.add(AnalysisMessages.UNEXPECTED_DO_TRY,"UnexpectedDoTry=Le bloc {0} doit être suivi d''un des blocs {1}.");
fr_.add(AnalysisMessages.UNEXPECTED_SWITCH,"UnexpectedSwitch=Le bloc {0} doit contenir seulement un des blocs {1}.");
fr_.add(AnalysisMessages.UNEXPECTED_MEMBER_INST,"UnexpectedMemberInst=Le type d''instance {0} doit contenir seulement des types d''instance et des blocs initialisateurs d''instance.");
fr_.add(AnalysisMessages.UNEXPECTED_BLOCK_EXP,"UnexpectedBlockExp=Le bloc est inattendu.");
fr_.add(AnalysisMessages.UNEXPECTED_OPERAND_TYPES,"UnexpectedOperandTypes=Les types {0} des opérandes pour l''opérateur {1} sont inattendus.");
fr_.add(AnalysisMessages.UNKNOWN_TYPE,"UnknownType=Le type {0} est inconnu.");
fr_.add(AnalysisMessages.EMPTY_TYPE,"EmptyType=Il doit y avoir un type.");
fr_.add(AnalysisMessages.BAD_PARAMERIZED_TYPE,"BadParamerizedType=Le type {0} n''est pas correctement paramétré.");
fr_.add(AnalysisMessages.UNEXPECTED_TYPE_BOUND,"UnexpectedTypeBound=Le type {0} est inattendu pour une borne.");
fr_.add(AnalysisMessages.UNEXPECTED_VARARG,"UnexpectedVararg=Les trois points sont inattendu ici.");
fr_.add(AnalysisMessages.UNEXPECTED_LEAF,"UnexpectedLeaf=Le mot clé {0} est inattendu ici.");
fr_.add(AnalysisMessages.CASE_TYPE_VAR,"CaseTypeVar=Ce bloc cas doit être constant.");
fr_.add(AnalysisMessages.EMPTY_PART,"EmptyPart=Il doit y avoir une expression.");
return fr_;
}
}
