EmptyWord={0} has an empty key word value.
NotWordChar={0} contains a character {1} that is not a character of a word.
DigitFirst={0} starts with {1} that is digit.
EmptyString={0} has an empty key string value.
EmptyNb={0} has an empty key number value.
EmptyBinExp=empty binary exp string
EmptyPreBin=empty prefix binary string
EmptyPreHex=empty prefix hexadecimal string
IllegalChar=the key word number {0} contains a character {1} that is illegal
IllegalFirstChar=the key word number {0} starts with {1} that is illegal as first character
EmptyPrimitive={0} has an empty primitive value.
NotWordCharPrimitive={0} contains a character {1} that is not a character of a word.
PrimitiveKeyWord=the primitive {0}:{1} is a duplicate string of a key word.
DigitFirstPrimitive={0} starts with {1} that is digit.
EmptyRefType={0} has an empty reference type value.
EmptyRefTypeIn={0} has an empty reference string between dots {1}.
NotWordCharRefType={0} contains a character {1} that is not a character of a word.
RefTypeKeyWord=the reference type {0}:{1} contains a duplicate string of a key word.
RefTypePrimitive=the reference type {0}:{1} contains a duplicate string of a primitive.
DigitFirstRefType={0} starts with {1} that is digit.
EmptyPkgRefType={0}:{1} does not belong to a package.
DefaultPkgRefType={0} match the default package {1}.
DefaultPkgNoMatch=the default package {0} has no reference type.
EmptyMethod=the method key {0} in reference type {1} has an empty name.
NotWordCharMethod=the method name {0} in reference type {1} contains a character {2} that is not a character of a word.
MethodKeyWord=the method name {0} in reference type {1}:{2} is a duplicate string of a key word.
MethodPrimitive=the method name {0} in reference type {1}:{2} is a duplicate string of a primitive.
DigitFirstMethod=the method name {0} in reference type {1} starts with {2} that is digit.
EmptyField=the field key {0} in reference type {1} has an empty name.
NotWordCharField=the field name {0} in reference type {1} contains a character {2} that is not a character of a word.
FieldKeyWord=the field name {0} in reference type {1}:{2} is a duplicate string of a key word.
FieldPrimitive=the field name {0} in reference type {1}:{2} is a duplicate string of a primitive.
DigitFirstField=the field name {0} in reference type {1} starts with {2} that is digit.
EmptyVarType=the variable type key {0} in reference type {1} has an empty name.
NotWordCharVarType=the variable type name {0} in reference type {1} contains a character {2} that is not a character of a word.
VarTypeKeyWord=the variable type name {0} in reference type {1}:{2} is a duplicate string of a key word.
VarTypePrimitive=the variable type name {0} in reference type {1}:{2} is a duplicate string of a primitive.
DigitFirstVarType=the variable type name {0} in reference type {1} starts with {2} that is digit.
DuplicateKeyWord={0} is duplicated as key word.
DuplicateStringWord={0} is duplicated as escaping word string in string.
DuplicateStarting=the escaping word {0} starts with the escaping word {1}.
DuplicateStartingUni=the escaping word {0} starts with the unicode escaping character {1}.
DuplicateNumberWord={0} is duplicated as number word.
DuplicateStartingNb=the number word {0} starts with the number word {1}.
DuplicatePrimtive=the primitive {0} is duplicated.
DuplicateRefType=the reference type {0} is duplicated.
DuplicateMethod=the method name {0} is duplicated.
DuplicateField=the field name {0} is duplicated.
DuplicateVarType=the variable type {0} is duplicated.
DuplicateMergedMethod=the merged method name {0}:{1} is duplicated.
AbstractMethodBody=The method {1} in the type {0} is abstract and cannot have a body.
AbstractMethodConc=The method {1} in the concrete type {0} must not be abstract.
AbstractMethodImpl=The method {1} from the type {0} must be overriden in the concrete type {2}.
AbstractMethodRef=The method {1} from the type {0} must not be called directly because of abstract.
InaccessibleType=The type {0} is not accessible from the type {1}.
UnexpectedType=The type {0} is unexpected.
MethodsAccesses=The method {1} from the type {0} is strictly more accessible than the method {3} from the type {2}.
EmptyPackage=A type must have an non empty package.
EmptyPartClassName=The part must not be empty.
BadPartClassName=The part {0} in a type is not valid. It must be a word that is not a key word, not a primitive type. Besides, it must not start with a digit.
BadPartVarClassName=The part {0} in a variable type is not valid. It must be a word that is not a key word, not a primitive type. Besides, it must not start with a digit.
CallCtorEnd=The call of a constructor using implicitly the instance must be applied at the end of the instruction.
CallCtor=The call of a constructor using implicitly the instance must be applied in a constructor.
CallCtorBeforeBlock=The call of a constructor using implicitly the instance must be applied before a block of instructions.
CallCtorFirstLine=The call of a constructor of the type or the super class using implicitly the instance must be applied on the first line.
CallCtorIntFromSuperInt=The call of a constructor of interface must refer a super interface of the calling type.
CallCtorIntNotFromInt=The call of a constructor of interface must not applied in a constructor of interface.
CallCtorIntAfterSuperThis=A call of a constructor of interface must be applied only after a call of a constructor using implicitly the instance.
CallCtorIntInherits=The call of a constructor of the interface {0} cannot be applied before calling the constructor of the interface {1}.
CallCtorSuperClassEnumSingleton=The super constructor can be called only from a class or an enum (singleton or normal).
AnnotFieldNotUniq=The field of the annotatation could not be found uniquely.
AnnotFieldMust=The field {0} of the annotatation is compulsory.
DupSuppliedAnnotField=The field {0} of the annotatation is supplied by duplicate.
BadExpression=Unexpected character {0} at the position {1} in the expression {2}
BadFieldName=The field name {0} is not valid. It must be a word that is not a key word, not a primitive type. Besides, it must not start with a digit.
NotRetrievedFields=No field could be retrieved.
BadNbFormat=Bad number {0}
BadCharFormat=Bad character format {0}
BadImplicitCast=The type {0} cannot be implicitly cast to {1}
NotPrimitiveWrapper=The type {0} is not a primitive type or a wrapper type.
VoidType=The type cannot be the key word {0}.
BadIndexInParser=Bad index by parsing.
IllegalCharacter=The characters ascii {0} are illegal.
CallIntInherits=Initializing the interface {0} cannot be applied before initializing the interface {1}.
CallIntNoNeed=Initializing a type from the interface {0} is not needed.
CallIntNoNeedType=Initializing the interface {0} from the type {1} is not needed.
CallIntNeedType=Initializing the interface {0} from the type {1} is needed.
CallIntOnly=The type {0} is not an interface.
BadInheritsType=The type {0} cannot have the type {1} as super type.
BadInheritsTypeInn=The type {0} cannot have the type {1} as super type because {1} is instance type.
BadInheritsTypeAsInn=The type {0} cannot have the type {1} as super type because {0} has {2} parents types and {1} has {3} parents types.
BadInheritsTypeInt=The type {0} cannot have the type {1} as super type because {1} is not an interface.
FinalType=The type {0} cannot have the type {1} as super type because {1} is final.
DuplicateSuper=The type {0} cannot have the type {1} duplicated as super type {2} times.
ReservedType=The type {0} cannot have explicitly the type {1} as super type because {1} is reserved.
SuperClass=The class {0} cannot have more than one super class ({1} times).
UnknownSuperType=The super types of the static type {0} could not be found.
CyclicInherits=The type {0} belongs to a cyclic inheriting.
AnnotationParam=The annotation {0} cannot be parameterized.
CyclicMapping=The type variables of the type {0} have a cyclic inheriting.
AbsMapping=There are {0} abstract types as upper bounds.
FinalMapping=There is at least one final type as upper bound ({0} times).
MustCallIntCtor=The type {0} must have a constructor because of implementing interfaces with instance elements.
MustNotCallIntCtorAfterThis=There must not be have constructor call after an alternate constructor call.
MustCallIntCtorNeed=A constructor of the type {0} must be called in the constructor.
MustCallIntCtorNotNeed=A constructor of the type {0} must not be called in the constructor.
BadLabel=A label must be a word (included characters dollars).
DuplicatedLabel=The label is duplicated.
BadMethodName=The method name {0} is not valid. It must be a word that is not a key word, not a primitive type. Besides, it must not start with a digit.
BadOperatorName=The operator symbol {0} is not valid.
BadAccess=The method {0} must be public.
BadReturnType=The method {0} must have {1} as return type.
BadParams=The method {0} must have one parameter.
BadMethodModifier=The method {0} must be static.
BadMethodVararg=The method {0} must not be variable argument.
BadIndexerParams=The indexer {0} must have at least one parameter.
BadIndexerModifier=The indexer {0} must not be static.
BadIndexerModifiers=The indexers {0} get and set must have the same modifier.
BadIndexerAccesses=The indexers {0} get and set must have the same access.
BadIndexerPairGet=The indexer {0} get must be defined.
BadIndexerPairSet=The indexer {0} set must be defined.
DuplicateCustomMethod=The method {0} is duplicated.
ReservedCustomMethod=The method {0} is reserved.
DuplicateIndexer=The indexer {0} is duplicated.
DuplicateOperator=The operator {0} is duplicated.
FunctionalApplyNbDiff=The number of required arguments {0} is different from the number of supplied arguments {1} for the method of the elliptic type {2}
FunctionalApplyOnly=Only the method {0} can ne used for the elliptic type {1}
OperatorNbDiff=The number of required operands {0} is different from the number of supplied arguments {1} for the operator {2}
SplitComa=The number of required splitted parts by comas {0} is greater than the number of supplied splitted parts by comas {1}.
SplitComaLow=The number of required splitted parts by comas {0} is lower than the number of supplied splitted parts by comas {1}.
SplitDiff=The number of required operands {0} is different from the number of supplied arguments {1}.
BadDotted=The code part following the dot operator cannot be used.
BadParamName=The parameter method name {0} is not valid. It must be a word that is not a key word, not a primitive type. Besides, it must not start with a digit.
ReservedParamName=The parameter method name {0} is reserved for indexer set.
DuplicatedParamName=The parameter function name {0} is duplicated.
BadReturnTypeInherit=The return type {0} of the method {1} of the type {2} is not sub type of the return type {3} of the method {4} of the type {5}
BadReturnTypeIndexer=The return type {0} of the indexer {1} of the type {2} is not the return type {3} of the indexer {4} of the type {5}
DuplicatedOverriding=The type {0} inherits a function {1} that is duplicated.
TwoFinal=The type {0} inherits two final functions with key {1}.
FinalNotSubReturnType=The return type {0} of the final method {1} of the type {2} is not sub type of the return type {3} of the method {4} of the type {5}
TwoReturnTypes=The merged methods with key {0} of the types {1} have the sub types {2} as return types.
ReturnTypes=The indexers with key {0} of the types {1} have the types {2} as return types.
BadVariableName=The variable name {0} is not valid. It must be a word that is not a key word, not a primitive type. Besides, it must not start with a digit. It must not be the name of an other variable of the scope.
CyclicCtorCall=The constructors {0} of the type {1} belong to cyclic calls.
DeadCode=The code is unreachable in the function {0}
DuplicatedCtor=The constructor {0} is duplicated.
DuplicatedGenericSuperTypes=The generic super types {0} are duplicated.
DuplicatedInnerType=The inner type simple name {0} is duplicated.
DuplicatedType=The type name {0} is duplicated with an other custom type.
DuplicatedTypePrim=The type name {0} is duplicated with a primitive type.
DuplicatedTypeStd=The type name {0} is duplicated with a standard type.
DuplicatedTypePkg=The type name {0} is shadowed by the package {1}.
EmptyExpressionPart=The expression part is empty.
DoWhileNotEmpty=The {0} block associated to a {1} block must be empty.
DuplicatedFinal=The function {0} of the type {1} is final. So overriding it is forbidden.
IllegalCtorEnum=A constructor of a enum cannot be called explicitly.
IllegalGenericSuperTypeBound=The argument {0} of the generic super type {1} is bound. It cannot be used in generic super type.
IllegalCtorAnnotation=After @ the type {0} is not an annotation.
IllegalCtorAbstract=The type {0} cannot be instantiated because of abstract.
IllegalCtorBound=The argument {0} of the type {1} is bound. It cannot be used in constructor call.
IllegalCtorArray=The type {0} is an array type. It cannot be used as previous dotted argument for instancing.
IllegalCtorUnknown=The type {0} is not resolved for instancing.
MissingAbrupt=A {0} block or a {1} block is missing for the method {2}.
NotInitClass=The type {0} is not initialized.
NullValue=The value must not be null because of possible {0}.
BadParameTypeForId=The parameter type {0} is not resolved for getting identity function.
NotResolvedOwner=The owner for the type {0} is not resolved for instancing.
UndefinedAccessibleField=There is no accessible field named {0} from the type {1} in this context.
StaticAccess=The context is static. The key word {0} cannot be used in this context.
StaticAccessPrev=A type must be used to access the key word {0}.
UnassignedFinalField=The field {0} of the type {1} is not assigned with a constant.
UnassignedInferingType=The inferring type {0} is not defined for the variables {1}.
UndefinedCtor=The constructor {0} is undefined.
UndefinedMethod=The function {0} is undefined.
ArrayCloneOnly=Only the method {0} can ne used for the array type {1}
UndefinedSuperCtor=No super constructor with implicit call is defined and accessible. There must be at least one constructor for the type {0}
UndefinedSuperCtorCall=No super constructor with implicit call is defined and accessible. The explicit call of a super constructor is required for the constructor {0}.
UndefinedVariable=The variable {0} is undefined in this context.
UnexpectedAffect=The assignment operator {0} is unexpected.
FinalField=The field {0} is already assigned.
BadOperatorRef=The string {0} is not an operator reference.
UnexpectedCatchElseFinally=The {0} block must be preceded by one of the blocks {1}.
UnexpectedAbrupt=The {0} block must be inner of the blocks {1}.
UnexpectedAbruptLab=The {0} block with label {1} must be inner of a labelled with {2} block.
UnexpectedCaseDef=The {0} block with expression {1} must be child of a block {2}.
UnexpectedCaseVar=The {0} block with expression {1} is not constant.
UnexpectedCaseValue=The {0} block with value {1} is not a sub type of {2}.
UnexpectedCaseDup=The {0} block with value {1} is duplicated in the parent {2} block.
UnexpectedDefDup=The {0} block is duplicated in the parent {1} block.
UnexpectedDoTry=The {0} block must be followed by one of the blocks {1}.
UnexpectedSwitch=The {0} block must contain only one of the blocks {1}.
UnexpectedMemberInst=The instance type {0} must contain only instance types and instance initilizing blocks.
UnexpectedBlockExp=The block is unexpected.
UnexpectedOperandTypes=The operands types {0} for the operator {1} are unexpected.
UnknownType=The type {0} is unknown.
BadParamerizedType=The type {0} is not parameterized correctly.
UnexpectedTypeBound=The type {0} is unexpected for bound.
UnexpectedVararg=The three dots are unexpected here.
UnexpectedLeaf=The key word {0} is unexpected here.
EmptyPart=There must be an expression.