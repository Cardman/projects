package code.scripts.messages.gui;
import code.util.*;
public final class MessCdmBaseGr{
private MessCdmBaseGr(){}
public static StringMap<String> ms(){
StringMap<String> m = new StringMap<String>();
m.addEntry("resources_lg/aliases/comments.properties",resourcesLgAliasesComments());
m.addEntry("resources_lg/aliases/en/keywords.properties",resourcesLgAliasesEnKeywords());
m.addEntry("resources_lg/aliases/en/messages.properties",resourcesLgAliasesEnMessages());
m.addEntry("resources_lg/aliases/en/types.properties",resourcesLgAliasesEnTypes());
m.addEntry("resources_lg/aliases/fr/keywords.properties",resourcesLgAliasesFrKeywords());
m.addEntry("resources_lg/aliases/fr/messages.properties",resourcesLgAliasesFrMessages());
m.addEntry("resources_lg/aliases/fr/types.properties",resourcesLgAliasesFrTypes());
m.addEntry("resources_lg/collections/list.txt",resourcesLgCollectionsList());
m.addEntry("resources_lg/collections/table.txt",resourcesLgCollectionsTable());
m.addEntry("resources_lg/tests/run.txt",resourcesLgTestsRun());
m.addEntry("resources_lg/threads/formatting.txt",resourcesLgThreadsFormatting());
m.addEntry("resources_lg/threads/runnable.txt",resourcesLgThreadsRunnable());
return m;
}
static String resourcesLgAliasesComments(){
String f="comments=\\u005c*,*\\u005c;\\u005c\\u005c,\\n;\\u005c<html>,</html>;\\u005c>,\\n\n";
return f;
}
static String resourcesLgAliasesEnKeywords(){
String f="Interfaces=interfaces\n";
f+="Finally=finally\n";
f+="Default=default\n";
f+="Parent=$parent\n";
f+="EscFeed=r\n";
f+="EscLine=n\n";
f+="Package=package\n";
f+="Operator=operator\n";
f+="EscForm=f\n";
f+="EscBound=b\n";
f+="EscUnicode=u\n";
f+="DefaultValue=defaultValue\n";
f+="Protected=protected\n";
f+="NbExpDec=e\n";
f+="Foreach=foreach\n";
f+="NbExpBin=p\n";
f+="Thisaccess=thisaccess\n";
f+="ValueOf=$valueOf\n";
f+="Superaccess=superaccess\n";
f+="Firstopt=$firstopt\n";
f+="Classchoice=classchoice\n";
f+="Switch=switch\n";
f+="Normal=normal\n";
f+="Enum=enum\n";
f+="Case=case\n";
f+="EscSpace=s\n";
f+="EscTab=t\n";
f+="Do=do\n";
f+="Id=$id\n";
f+="Lambda=$lambda\n";
f+="Intern=$intern\n";
f+="Super=super\n";
f+="NbBin=b\n";
f+="Values=$values\n";
f+="Vararg=$vararg\n";
f+="Bool=bool\n";
f+="NbHex=x\n";
f+="NbHexEnd=x\n";
f+="That=that\n";
f+="Abstract=abstract\n";
f+="Continue=continue\n";
f+="Instanceof=instanceof\n";
f+="Interface=interface\n";
f+="New=new\n";
f+="If=if\n";
f+="While=while\n";
f+="Return=return\n";
f+="Class=class\n";
f+="Null=null\n";
f+="Elseif=elseif\n";
f+="Public=public\n";
f+="Var=var\n";
f+="Cast=$\n";
f+="Explicit=explicit\n";
f+="True=true\n";
f+="False=false\n";
f+="Break=break\n";
f+="Static=static\n";
f+="StaticCall=staticCall\n";
f+="Final=final\n";
f+="For=for\n";
f+="Value=value\n";
f+="Iter=iter\n";
f+="Try=try\n";
f+="Throw=throw\n";
f+="Catch=catch\n";
f+="Else=else\n";
f+="This=this\n";
f+="Annotation=annotation\n";
f+="Private=private\n";
f+="ToString=$toString\n";
f+="NbSufDoublePrim=d\n";
f+="NbSufDouble=D\n";
f+="NbSufFloatPrim=f\n";
f+="NbSufFloat=F\n";
f+="NbSufLongPrim=l\n";
f+="NbSufLong=L\n";
f+="NbSufIntegerPrim=i\n";
f+="NbSufInteger=I\n";
f+="NbSufCharacterPrim=c\n";
f+="NbSufCharacter=C\n";
f+="NbSufShortPrim=s\n";
f+="NbSufShort=S\n";
f+="NbSufBytePrim=y\n";
f+="NbSufByte=Y\n";
return f;
}
static String resourcesLgAliasesEnMessages(){
String f="EmptyWord={0} has an empty key word value.\n";
f+="NotWordChar={0} contains a character {1} that is not a character of a word.\n";
f+="DigitFirst={0} starts with {1} that is digit.\n";
f+="EmptyString={0} has an empty key string value.\n";
f+="EmptyNb={0} has an empty key number value.\n";
f+="EmptyBinExp=empty binary exp string\n";
f+="EmptyPreBin=empty prefix binary string\n";
f+="EmptyPreHex=empty prefix hexadecimal string\n";
f+="IllegalChar=the key word number {0} contains a character {1} that is illegal\n";
f+="IllegalFirstChar=the key word number {0} starts with {1} that is illegal as first character\n";
f+="EmptyPrimitive={0} has an empty primitive value.\n";
f+="NotWordCharPrimitive={0} contains a character {1} that is not a character of a word.\n";
f+="PrimitiveKeyWord=the primitive {0}:{1} is a duplicate string of a key word.\n";
f+="DigitFirstPrimitive={0} starts with {1} that is digit.\n";
f+="EmptyRefType={0} has an empty reference type value.\n";
f+="EmptyRefTypeIn={0} has an empty reference string between dots {1}.\n";
f+="NotWordCharRefType={0} contains a character {1} that is not a character of a word.\n";
f+="RefTypeKeyWord=the reference type {0}:{1} contains a duplicate string of a key word.\n";
f+="RefTypePrimitive=the reference type {0}:{1} contains a duplicate string of a primitive.\n";
f+="DigitFirstRefType={0} starts with {1} that is digit.\n";
f+="EmptyPkgRefType={0}:{1} does not belong to a package.\n";
f+="DefaultPkgRefType={0} match the default package {1}.\n";
f+="DefaultPkgNoMatch=the default package {0} has no reference type.\n";
f+="EmptyMethod=the method key {0} in reference type {1} has an empty name.\n";
f+="NotWordCharMethod=the method name {0} in reference type {1} contains a character {2} that is not a character of a word.\n";
f+="MethodKeyWord=the method name {0} in reference type {1}:{2} is a duplicate string of a key word.\n";
f+="MethodPrimitive=the method name {0} in reference type {1}:{2} is a duplicate string of a primitive.\n";
f+="DigitFirstMethod=the method name {0} in reference type {1} starts with {2} that is digit.\n";
f+="EmptyField=the field key {0} in reference type {1} has an empty name.\n";
f+="NotWordCharField=the field name {0} in reference type {1} contains a character {2} that is not a character of a word.\n";
f+="FieldKeyWord=the field name {0} in reference type {1}:{2} is a duplicate string of a key word.\n";
f+="FieldPrimitive=the field name {0} in reference type {1}:{2} is a duplicate string of a primitive.\n";
f+="DigitFirstField=the field name {0} in reference type {1} starts with {2} that is digit.\n";
f+="EmptyVarType=the variable type key {0} in reference type {1} has an empty name.\n";
f+="NotWordCharVarType=the variable type name {0} in reference type {1} contains a character {2} that is not a character of a word.\n";
f+="VarTypeKeyWord=the variable type name {0} in reference type {1}:{2} is a duplicate string of a key word.\n";
f+="VarTypePrimitive=the variable type name {0} in reference type {1}:{2} is a duplicate string of a primitive.\n";
f+="DigitFirstVarType=the variable type name {0} in reference type {1} starts with {2} that is digit.\n";
f+="DuplicateKeyWord={0} is duplicated as key word.\n";
f+="DuplicateStringWord={0} is duplicated as escaping word string in string.\n";
f+="DuplicateStarting=the escaping word {0} starts with the escaping word {1}.\n";
f+="DuplicateStartingUni=the escaping word {0} starts with the unicode escaping character {1}.\n";
f+="DuplicateNumberWord={0} is duplicated as number word.\n";
f+="DuplicateStartingNb=the number word {0} starts with the number word {1}.\n";
f+="DuplicatePrimtive=the primitive {0} is duplicated.\n";
f+="DuplicateRefType=the reference type {0} is duplicated.\n";
f+="DuplicateMethod=the method name {0} is duplicated.\n";
f+="DuplicateField=the field name {0} is duplicated.\n";
f+="DuplicateVarType=the variable type {0} is duplicated.\n";
f+="DuplicateMergedMethod=the merged method name {0}:{1} is duplicated.\n";
f+="AbstractMethodBody=The method {1} in the type {0} is abstract and cannot have a body.\n";
f+="AbstractMethodConc=The method {1} in the concrete type {0} must not be abstract.\n";
f+="AbstractMethodImpl=The method {1} from the type {0} must be overriden in the concrete type {2}.\n";
f+="AbstractMethodRef=The method {1} from the type {0} must not be called directly because of abstract.\n";
f+="InaccessibleType=The type {0} is not accessible from the type {1}.\n";
f+="UnexpectedType=The type {0} is unexpected.\n";
f+="UnexpectedRetType=The return type {0} in the function {1} is unexpected.\n";
f+="MethodsAccesses=The method {1} from the type {0} is strictly more accessible than the method {3} from the type {2}.\n";
f+="EmptyPackage=A type must have an non empty package.\n";
f+="EmptyPartClassName=The part must not be empty.\n";
f+="BadPartClassName=The part {0} in a type is not valid. It must be a word.\n";
f+="KeyWordPartClassName=The part {0} in a type is not valid. It must not be a key word.\n";
f+="PrimPartClassName=The part {0} in a type is not valid. It must not a primitive type.\n";
f+="DigitPartClassName=The part {0} in a type is not valid. It must not start with a digit.\n";
f+="BadPartVarClassName=The part {0} in a variable type is not valid. It must be a word.\n";
f+="KeyWordPartVarClassName=The part {0} in a variable type is not valid. It must not be a key word.\n";
f+="PrimPartVarClassName=The part {0} in a variable type is not valid. It must not a primitive type.\n";
f+="DigitPartVarClassName=The part {0} in a variable type is not valid. It must not start with a digit.\n";
f+="DuplicatedPartVarClassName=The part {0} in a variable type is duplicated.\n";
f+="CallCtorEnd=The call of a constructor using implicitly the instance must be applied at the end of the instruction.\n";
f+="CallCtor=The call of a constructor using implicitly the instance must be applied in a constructor.\n";
f+="CallCtorBeforeBlock=The call of a constructor using implicitly the instance must be applied before a block of instructions.\n";
f+="CallCtorFirstLine=The call of a constructor of the type or the super class using implicitly the instance must be applied on the first line.\n";
f+="CallCtorIntFromSuperInt=The call of a constructor of interface must refer a super interface of the calling type.\n";
f+="CallCtorIntNotFromInt=The call of a constructor of interface must not applied in a constructor of interface.\n";
f+="CallCtorIntAfterSuperThis=A call of a constructor of interface must be applied only after a call of a constructor using implicitly the instance.\n";
f+="CallCtorIntInherits=The call of a constructor of the interface {0} cannot be applied before calling the constructor of the interface {1}.\n";
f+="CallCtorSuperClassEnumSingleton=The super constructor can be called only from a class or an enum (singleton or normal).\n";
f+="CallCtorNoSuperClassEnum=There is no super custom type to be called from this class or an enum (singleton or normal).\n";
f+="AnnotFieldNotUniq=The field of the annotatation could not be found uniquely.\n";
f+="AnnotFieldMust=The field {0} of the annotatation is compulsory.\n";
f+="DupSuppliedAnnotField=The field {0} of the annotatation is supplied by duplicate.\n";
f+="BadExpression=Unexpected character {0} at the position {1} in the expression {2}\n";
f+="BadFieldName=The field name {0} is not valid. It must be a word.\n";
f+="KeyWordFieldName=The field name {0} is not valid. It must not be a key word.\n";
f+="PrimFieldName=The field name {0} is not valid. It must not a primitive type.\n";
f+="DigitFieldName=The field name {0} is not valid. It must not start with a digit.\n";
f+="NotRetrievedFields=No field could be retrieved.\n";
f+="BadNbFormat=Bad number {0}\n";
f+="BadCharFormat=Bad character format {0}\n";
f+="BadImplicitCast=The type {0} cannot be implicitly cast to {1}\n";
f+="NotPrimitiveWrapper=The type {0} is not a primitive type or a wrapper type.\n";
f+="VoidType=The type cannot be the key word {0}.\n";
f+="BadIndexInParser=Bad index by parsing.\n";
f+="IllegalCharacter=The characters ascii {0} are illegal.\n";
f+="CallIntInherits=Initializing the interface {0} cannot be applied before initializing the interface {1}.\n";
f+="CallIntNoNeed=Initializing a type from the interface {0} is not needed.\n";
f+="CallIntNoNeedType=Initializing the interface {0} from the type {1} is not needed.\n";
f+="CallIntNeedType=Initializing the interface {0} from the type {1} is needed.\n";
f+="CallIntOnly=The type {0} is not an interface.\n";
f+="BadInheritsType=The type {0} cannot have the type {1} as super type.\n";
f+="BadInheritsTypeInn=The type {0} cannot have the type {1} as super type because {1} is instance type.\n";
f+="BadInheritsTypeAsInn=The type {0} cannot have the type {1} as super type because {0} has {2} parents types and {1} has {3} parents types.\n";
f+="BadInheritsTypeInt=The type {0} cannot have the type {1} as super type because {1} is not an interface.\n";
f+="FinalType=The type {0} cannot have the type {1} as super type because {1} is final.\n";
f+="DuplicateSuper=The type {0} cannot have the type {1} duplicated as super type {2} times.\n";
f+="ReservedType=The type {0} cannot have explicitly the type {1} as super type because {1} is reserved.\n";
f+="SuperClass=The class {0} cannot have more than one super class ({1} times).\n";
f+="UnknownSuperType=The super types of the static type {0} could not be found.\n";
f+="CyclicInherits=The type {0} belongs to a cyclic inheriting.\n";
f+="AnnotationParam=The annotation {0} cannot be parameterized.\n";
f+="CyclicMapping=The type variables of the type {0} have a cyclic inheriting.\n";
f+="AbsMapping=There are {0} abstract types as upper bounds.\n";
f+="FinalMapping=There is at least one final type as upper bound ({0} times).\n";
f+="MustCallIntCtor=The type {0} must have a constructor because of implementing interfaces with instance elements.\n";
f+="MustNotCallIntCtorAfterThis=There must not be have constructor call after an alternate constructor call.\n";
f+="MustCallIntCtorNeed=A constructor of the type {0} must be called in the constructor.\n";
f+="MustCallIntCtorNotNeed=A constructor of the type {0} must not be called in the constructor.\n";
f+="BadLabel=A label must be a word (included characters dollars).\n";
f+="DuplicatedLabel=The label is duplicated.\n";
f+="BadMethodName=The method name {0} is not valid. It must be a word.\n";
f+="KeyWordMethodName=The method name {0} is not valid. It must not be a key word.\n";
f+="PrimMethodName=The method name {0} is not valid. It must not a primitive type.\n";
f+="DigitMethodName=The method name {0} is not valid. It must not start with a digit.\n";
f+="BadOperatorName=The operator symbol {0} is not valid.\n";
f+="BadAccess=The method {0} must be public.\n";
f+="BadReturnType=The method {0} must have {1} as return type.\n";
f+="BadParams=The method {0} must have one parameter.\n";
f+="BadMethodModifier=The method {0} must be static.\n";
f+="BadMethodVararg=The method {0} must not be variable argument.\n";
f+="BadIndexerParams=The indexer {0} must have at least one parameter.\n";
f+="BadIndexerModifier=The indexer {0} must not be static.\n";
f+="BadIndexerModifiers=The indexers {0} get and set must have the same modifier.\n";
f+="BadIndexerAccesses=The indexers {0} get and set must have the same access.\n";
f+="BadIndexerPairGet=The indexer {0} get must be defined.\n";
f+="BadIndexerPairSet=The indexer {0} set must be defined.\n";
f+="DuplicateCustomMethod=The method {0} is duplicated.\n";
f+="ReservedCustomMethod=The method {0} is reserved.\n";
f+="DuplicateIndexer=The indexer {0} is duplicated.\n";
f+="DuplicateOperator=The operator {0} is duplicated.\n";
f+="FunctionalApplyNbDiff=The number of required arguments {0} is different from the number of supplied arguments {1} for the method of the elliptic type {2}\n";
f+="FunctionalApplyOnly=Only the method {0} can ne used for the elliptic type {1}\n";
f+="OperatorNbDiff=The number of required operands {0} is different from the number of supplied arguments {1} for the operator {2}\n";
f+="SplitComa=The number of required splitted parts by comas {0} is greater than the number of supplied splitted parts by comas {1}.\n";
f+="SplitComaLow=The number of required splitted parts by comas {0} is lower than the number of supplied splitted parts by comas {1}.\n";
f+="SplitDiff=The number of required operands {0} is different from the number of supplied arguments {1}.\n";
f+="BadDotted=The code part following the dot operator cannot be used.\n";
f+="BadParamName=The parameter method name {0} is not valid. It must be a word.\n";
f+="KeyWordParamName=The parameter method name {0} is not valid. It must not be a key word.\n";
f+="PrimParamName=The parameter method name {0} is not valid. It must not a primitive type.\n";
f+="DigitParamName=The parameter method name {0} is not valid. It must not start with a digit.\n";
f+="ReservedParamName=The parameter method name {0} is reserved for indexer set.\n";
f+="DuplicatedParamName=The parameter function name {0} is duplicated.\n";
f+="BadReturnTypeInherit=The return type {0} of the method {1} of the type {2} is not sub type of the return type {3} of the method {4} of the type {5}\n";
f+="BadReturnTypeIndexer=The return type {0} of the indexer {1} of the type {2} is not the return type {3} of the indexer {4} of the type {5}\n";
f+="DuplicatedOverriding=The type {0} inherits a function {1} that is duplicated.\n";
f+="TwoFinal=The type {0} inherits two final functions with key {1}.\n";
f+="FinalNotSubReturnType=The return type {0} of the final method {1} of the type {2} is not sub type of the return type {3} of the method {4} of the type {5}\n";
f+="TwoReturnTypes=The merged methods with key {0} of the types {1} have the sub types {2} as return types.\n";
f+="ReturnTypes=The indexers with key {0} of the types {1} have the types {2} as return types.\n";
f+="BadVariableName=The variable name {0} is not valid. It must be a word.\n";
f+="KeyWordVariableName=The variable name {0} is not valid. It must not be a key word.\n";
f+="PrimVariableName=The variable name {0} is not valid. It must not a primitive type.\n";
f+="DigitVariableName=The variable name {0} is not valid. It must not start with a digit.\n";
f+="DuplicatedVariableName=The variable name {0} is not valid. It must not be the name of an other variable of the scope.\n";
f+="CyclicCtorCall=The constructors {0} of the type {1} belong to cyclic calls.\n";
f+="DeadCode=The code is unreachable in the function {0}\n";
f+="DeadCodeTernary=A part of code is unreachable in this ternary operation.\n";
f+="UnusedParamStatic=The parameter {0} is unused.\n";
f+="DuplicatedCtor=The constructor {0} is duplicated.\n";
f+="DuplicatedGenericSuperTypes=The generic super types {0} are duplicated.\n";
f+="DuplicatedInnerType=The inner type simple name {0} is duplicated.\n";
f+="DuplicatedType=The type name {0} is duplicated with an other custom type.\n";
f+="DuplicatedTypePrim=The type name {0} is duplicated with a primitive type.\n";
f+="DuplicatedTypeStd=The type name {0} is duplicated with a standard type.\n";
f+="DuplicatedTypePkg=The type name {0} is shadowed by the package {1}.\n";
f+="EmptyExpressionPart=The expression part is empty.\n";
f+="DoWhileNotEmpty=The {0} block associated to a {1} block must be empty.\n";
f+="DuplicatedFinal=The function {0} of the type {1} is final. So overriding it is forbidden.\n";
f+="IllegalCtorEnum=A constructor of a enum cannot be called explicitly.\n";
f+="IllegalGenericSuperTypeBound=The argument {0} of the generic super type {1} is bound. It cannot be used in generic super type.\n";
f+="IllegalCtorAnnotation=After @ the type {0} is not an annotation.\n";
f+="IllegalCtorAbstract=The type {0} cannot be instantiated because of abstract.\n";
f+="IllegalCtorBound=The argument {0} of the type {1} is bound. It cannot be used in constructor call.\n";
f+="IllegalCtorArray=The type {0} is an array type. It cannot be used as previous dotted argument for instancing.\n";
f+="IllegalCtorUnknown=The type {0} is not resolved for instancing.\n";
f+="MissingAbrupt=A {0} block or a {1} block is missing for the method {2}.\n";
f+="NotInitClass=The type {0} is not initialized.\n";
f+="NullValue=The value must not be null because of possible {0}.\n";
f+="BadParameTypeForId=The parameter type {0} is not resolved for getting identity function.\n";
f+="NotResolvedOwner=The owner for the type {0} is not resolved for instancing.\n";
f+="UndefinedAccessibleField=There is no accessible field named {0} from the type {1} in this context.\n";
f+="StaticAccess=The context is static. The key word {0} cannot be used in this context.\n";
f+="StaticAccessPrev=A type must be used to access the key word {0}.\n";
f+="UnassignedFinalField=The field {0} of the type {1} is not assigned with a constant.\n";
f+="UnassignedInferingType=The inferring type {0} is not defined for the variables {1}.\n";
f+="UndefinedCtor=The constructor {0} is undefined.\n";
f+="UndefinedMethod=The function {0} is undefined.\n";
f+="ArrayCloneOnly=Only the method {0} can ne used for the array type {1}\n";
f+="UndefinedSuperCtor=No super constructor with implicit call is defined and accessible. There must be at least one constructor for the type {0}\n";
f+="UndefinedSuperCtorCall=No super constructor with implicit call is defined and accessible. The explicit call of a super constructor is required for the constructor {0}.\n";
f+="UndefinedVariable=The variable {0} is undefined in this context.\n";
f+="UnexpectedAffect=The assignment operator {0} is unexpected.\n";
f+="FinalField=The field {0} is already assigned.\n";
f+="BadOperatorRef=The string {0} is not an operator reference.\n";
f+="UnexpectedCatchElseFinally=The {0} block must be preceded by one of the blocks {1}.\n";
f+="UnexpectedAbrupt=The {0} block must be inner of the blocks {1}.\n";
f+="UnexpectedAbruptLab=The {0} block with label {1} must be inner of a labelled with {2} block.\n";
f+="UnexpectedCaseDef=The {0} block with expression {1} must be child of a block {2}.\n";
f+="UnexpectedCaseVar=The {0} block with expression {1} is not constant.\n";
f+="UnexpectedCaseValue=The {0} block with value {1} is not a sub type of {2}.\n";
f+="UnexpectedCaseDup=The {0} block with value {1} is duplicated in the parent {2} block.\n";
f+="UnexpectedDefDup=The {0} block is duplicated in the parent {1} block.\n";
f+="UnexpectedDoTry=The {0} block must be followed by one of the blocks {1}.\n";
f+="UnexpectedSwitch=The {0} block must contain only one of the blocks {1}.\n";
f+="UnexpectedMemberInst=The instance type {0} must contain only instance types and instance initilizing blocks.\n";
f+="UnexpectedBlockExp=The block is unexpected.\n";
f+="UnexpectedOperandTypes=The operands types {0} for the operator {1} are unexpected.\n";
f+="UnknownType=The type {0} is unknown.\n";
f+="EmptyType=There must be a type.\n";
f+="BadParamerizedType=The type {0} is not parameterized correctly.\n";
f+="UnexpectedTypeBound=The type {0} is unexpected for bound.\n";
f+="UnexpectedVararg=The three dots are unexpected here.\n";
f+="UnexpectedLeaf=The key word {0} is unexpected here.\n";
f+="EmptyPart=There must be an expression.\n";
return f;
}
static String resourcesLgAliasesEnTypes(){
String f="MIN_VALUE=MIN_VALUE\n";
f+="MAX_VALUE=MAX_VALUE\n";
f+="PLUS_INFINITY=PLUS_INFINITY\n";
f+="MINUS_INFINITY=MINUS_INFINITY\n";
f+="NAN=NAN\n";
f+="GetMessage=getMessage\n";
f+="IteratorType=$core.Iterator\n";
f+="DivisionZero=$core.DivideZero\n";
f+="BadEncode=$core.BadEncode\n";
f+="CharSequence=$core.CharSequence\n";
f+="EnumParam=$core.Enum\n";
f+="IteratorTableTypeVarFirst=T\n";
f+="IteratorTableTypeVarSecond=U\n";
f+="Digit=digit\n";
f+="Short=$core.Short\n";
f+="Integer=$core.Integer\n";
f+="Compare=compare\n";
f+="StringCompare=compare\n";
f+="Float=$core.Float\n";
f+="ParseInt=parseInt\n";
f+="IsDigit=isDigit\n";
f+="Double=$core.Double\n";
f+="IntValue=intValue\n";
f+="Byte=$core.Byte\n";
f+="PrimChar=char\n";
f+="Equals=equals\n";
f+="CharSequenceEquals=equals\n";
f+="Long=$core.Long\n";
f+="Number=$core.Number\n";
f+="PrimLong=long\n";
f+="Boolean=$core.Boolean\n";
f+="Iterable=$core.Iterable\n";
f+="Iterator=iterator\n";
f+="NullPe=$core.NullObject\n";
f+="BadIndex=$core.BadIndexException\n";
f+="BadArgNumber=$core.BadArgNumber\n";
f+="AbstractTypeErr=$core.AbstractTypeError\n";
f+="IllegalType=$core.IllegalType\n";
f+="NonInvokable=$core.NonInvokable\n";
f+="Sof=$core.StackOverFlow\n";
f+="Store=$core.BadStore\n";
f+="Void=void\n";
f+="EnumType=$core.$en\n";
f+="BadSize=$core.NegativeSize\n";
f+="Enums=$core.Enums\n";
f+="PrimByte=byte\n";
f+="Math=$core.Math\n";
f+="Error=$core.Error\n";
f+="GetCause=getCause\n";
f+="Object=$core.Object\n";
f+="CastType=$core.BadCast\n";
f+="NbFormat=$core.BadFormat\n";
f+="ParseShortOrNull=parseShortOrNull\n";
f+="ByteValue=byteValue\n";
f+="Character=$core.Character\n";
f+="ParseFloat=parseFloat\n";
f+="ParseIntOrNull=parseIntOrNull\n";
f+="ToStringMethod=toString\n";
f+="StackTraceElementToString=toString\n";
f+="CharSequenceToString=toString\n";
f+="ErrorToString=toString\n";
f+="Signum=sgn\n";
f+="Bin=bin\n";
f+="Oct=oct\n";
f+="Hex=hex\n";
f+="ParseLongOrNull=parseLongOrNull\n";
f+="PrimShort=short\n";
f+="ParseByteOrNull=parseByteOrNull\n";
f+="PrimFloat=float\n";
f+="ParseBoolean=parseBoolean\n";
f+="ParseFloatOrNull=parseFloatOrNull\n";
f+="ShortValue=shortValue\n";
f+="CompareTo=compareTo\n";
f+="CharSequenceCompareTo=compareTo\n";
f+="MinValueField=MIN_VALUE\n";
f+="PrimInteger=int\n";
f+="ParseByte=parseByte\n";
f+="PrimBoolean=boolean\n";
f+="ParseLong=parseLong\n";
f+="PrimDouble=double\n";
f+="IllegalArg=$core.IllegalArgument\n";
f+="ValueOfMethod=valueOf\n";
f+="StringValueOf=valueOf\n";
f+="StringUtilValueOf=valueOf\n";
f+="ParseShort=parseShort\n";
f+="ParseDoubleOrNull=parseDoubleOrNull\n";
f+="ParseDouble=parseDouble\n";
f+="BooleanValue=booleanValue\n";
f+="CharValue=charValue\n";
f+="LongValue=longValue\n";
f+="IsUpperCase=isUpperCase\n";
f+="DoubleValue=doubleValue\n";
f+="IsWordChar=isWordChar\n";
f+="FloatValue=floatValue\n";
f+="IsLetterOrDigit=isLetterOrDigit\n";
f+="IsWhitespace=isWhitespace\n";
f+="IsLowerCase=isLowerCase\n";
f+="Format=format\n";
f+="String=$core.String\n";
f+="GetBytes=getBytes\n";
f+="GetType=getType\n";
f+="Replace=replace\n";
f+="ReplaceString=replace\n";
f+="Split=split\n";
f+="Trim=trim\n";
f+="CharAt=charAt\n";
f+="EndsWith=endsWith\n";
f+="IndexOf=indexOf\n";
f+="IsSpace=isSpace\n";
f+="Append=append\n";
f+="IsEmpty=isEmpty\n";
f+="Capacity=capacity\n";
f+="ForDigit=forDigit\n";
f+="Length=length\n";
f+="ArrayLength=length\n";
f+="IsLetter=isLetter\n";
f+="Contains=contains\n";
f+="IsNan=isNan\n";
f+="Ordinal=ordinal\n";
f+="PairType=$core.Pair\n";
f+="Clear=clear\n";
f+="NextPair=nextPair\n";
f+="Abs=abs\n";
f+="Max=max\n";
f+="Min=min\n";
f+="Clone=clone\n";
f+="Insert=insert\n";
f+="Name=name\n";
f+="Fct=$core.Fct\n";
f+="GetFirst=getFirst\n";
f+="Next=next\n";
f+="HasNext=hasNext\n";
f+="Quot=quot\n";
f+="Delete=delete\n";
f+="Reverse=reverse\n";
f+="Same=same\n";
f+="Mod=mod\n";
f+="Call=call\n";
f+="MetaInfo=metaInfo\n";
f+="Instance=instance\n";
f+="StartsWith=startsWith\n";
f+="DeleteCharAt=deleteCharAt\n";
f+="LastIndexOf=lastIndexOf\n";
f+="ToLowerCase=toLowerCase\n";
f+="ToLowerCaseChar=toLowerCase\n";
f+="TrimToSize=trimToSize\n";
f+="IsInfinite=isInfinite\n";
f+="IteratorTable=iteratorTable\n";
f+="Substring=substring\n";
f+="StringBuilder=$core.StringBuilder\n";
f+="GetDirectionality=getDirectionality\n";
f+="ReplaceMultiple=replaceMultiple\n";
f+="SetLength=setLength\n";
f+="EnsureCapacity=ensureCapacity\n";
f+="SplitChars=splitChars\n";
f+="ToUpperCase=toUpperCase\n";
f+="ToUpperCaseChar=toUpperCase\n";
f+="SetCharAt=setCharAt\n";
f+="RegionMatches=regionMatches\n";
f+="SplitStrings=splitStrings\n";
f+="SubSequence=subSequence\n";
f+="GetCharType=getType\n";
f+="IterableTable=$core.IterableTable\n";
f+="ToCharArray=toCharArray\n";
f+="CompareToIgnoreCase=compareToIgnoreCase\n";
f+="EqualsIgnoreCase=equalsIgnoreCase\n";
f+="GetNewString=getNewString\n";
f+="Replacement=$core.Replacement\n";
f+="GetOldString=getOldString\n";
f+="HasNextPair=hasNextPair\n";
f+="ErrorInitClass=$core.DefErrorClass\n";
f+="GetSecond=getSecond\n";
f+="IteratorTableType=$core.IteratorTable\n";
f+="AnnotationType=$core.Annotation\n";
f+="IteratorTypeVar=T\n";
f+="Annotated=$core.Annotated\n";
f+="ClassType=$core.Class\n";
f+="GetDefaultValue=getDefaultValue\n";
f+="GetAnnotationsParameters=getAnnotationsParameters\n";
f+="ReadResourcesNames=readNames\n";
f+="ReadResourcesNamesLength=nbNames\n";
f+="ReadResources=readContent\n";
f+="ReadResourcesIndex=index\n";
f+="InvokeTarget=$core.InvokeTarget\n";
f+="GetVariableOwner=getVariableOwner\n";
f+="Resources=$core.Resources\n";
f+="EnumValues=values\n";
f+="EnumParamVar=T\n";
f+="GetGenericVariableOwner=getGenericVariableOwner\n";
f+="GetString=getString\n";
f+="IterableVar=T\n";
f+="EnumPredValueOf=valueOf\n";
f+="IterableTableVarFirst=T\n";
f+="IterableTableVarSecond=U\n";
f+="PairTypeVarSecond=U\n";
f+="ClassNotFoundError=$core.ClassNotFound\n";
f+="GetAnnotations=getAnnotations\n";
f+="PairTypeVarFirst=T\n";
f+="Constructor=$core.Constructor\n";
f+="GetDeclaredExplicits=getDeclaredExplicits\n";
f+="GetDeclaredImplicits=getDeclaredImplicits\n";
f+="GetDeclaredTrueOperators=getDeclaredTrueOperators\n";
f+="GetDeclaredFalseOperators=getDeclaredFalseOperators\n";
f+="GetDeclaredMethods=getDeclaredMethods\n";
f+="GetDeclaredStaticMethods=getDeclaredStaticMethods\n";
f+="GetDeclaredFields=getDeclaredFields\n";
f+="GetDeclaredAnonymousTypes=getDeclaredAnonymousTypes\n";
f+="GetDeclaredAnonymousLambda=getDeclaredAnonymousLambda\n";
f+="GetDeclaredAnonymousLambdaLocalVars=getDeclaredAnonymousLambdaLocVars\n";
f+="GetDeclaredAnonymousLambdaLocalVarsNb=getDeclaredAnonymousLambdaWrapVarsNb\n";
f+="GetDeclaredAnonymousLambdaLoopVars=getDeclaredAnonymousLambdaLoopVars\n";
f+="GetDeclaredLocalTypes=getDeclaredLocalTypes\n";
f+="GetDeclaredBlocks=getDeclaredBlocks\n";
f+="GetDeclaredSwitchMethods=getDeclaredSwitchMethods\n";
f+="MakeGeneric=makeGeneric\n";
f+="GetDeclaredConstructors=getDeclaredConstructors\n";
f+="GetAllClasses=getAllClasses\n";
f+="GetOperators=getOperators\n";
f+="ArrayGet=get\n";
f+="IsFinal=isFinal\n";
f+="Method=$core.Method\n";
f+="Invoke=invoke\n";
f+="GetName=getName\n";
f+="ForName=forName\n";
f+="SameRef=eq\n";
f+="SetField=set\n";
f+="GetField=get\n";
f+="IsPublic=isPublic\n";
f+="IsArray=isArray\n";
f+="Field=$core.Field\n";
f+="IsNormal=isNormal\n";
f+="GetClass=getClass\n";
f+="IsEnum=isEnum\n";
f+="Init=init\n";
f+="TryWrap=tryWrap\n";
f+="IsStatic=isStatic\n";
f+="IsStaticCall=isStaticCall\n";
f+="IsInstanceMethod=isInstanceMethod\n";
f+="IsClass=isClass\n";
f+="IsSpeClass=isSpeClass\n";
f+="IsSpeMuClass=isSpeClassMu\n";
f+="Xor=xor\n";
f+="Lt=lt\n";
f+="Gt=gt\n";
f+="Mult=mult\n";
f+="Ge=ge\n";
f+="BinQuot=binQuot\n";
f+="ArraySet=set\n";
f+="Or=or\n";
f+="BinMod=binMod\n";
f+="Plus=plus\n";
f+="And=and\n";
f+="NegBin=negBin\n";
f+="Minus=minus\n";
f+="Neg=neg\n";
f+="EnumName=name\n";
f+="Le=le\n";
f+="Random=random\n";
f+="NativeRandom=natRandom\n";
f+="SeedGenerator=$core.Generator\n";
f+="SeedDoubleGenerator=$core.DoubleGenerator\n";
f+="SeedGet=get\n";
f+="Seed=seed\n";
f+="SeedSpecGenerator=seedGenerator\n";
f+="SeedSpecDoubleGenerator=seedDoubleGenerator\n";
f+="EnumOrdinal=ordinal\n";
f+="StackTraceElement=$core.Stack\n";
f+="DefaultInstance=defaultInstance\n";
f+="ShiftRight=shiftRight\n";
f+="GetEnumConstants=getEnumConstants\n";
f+="GetDeclaringClass=getDeclaringClass\n";
f+="GetBounds=getBounds\n";
f+="BitShiftLeft=bitShiftLeft\n";
f+="RotateLeft=rotateLeft\n";
f+="ShiftLeft=shiftLeft\n";
f+="CurrentFullStack=currentFull\n";
f+="BitShiftRight=bitShiftRight\n";
f+="EnumValueOf=enumValueOf\n";
f+="RotateRight=rotateRight\n";
f+="GetGenericBounds=getGenericBounds\n";
f+="ArrayGetLength=getLength\n";
f+="CurrentStack=current\n";
f+="ErrorCurrentStack=current\n";
f+="ArrayNewInstance=newArrayInstance\n";
f+="StringUtil=$core.StringUtil\n";
f+="GetParent=getParent\n";
f+="GetFct=getFct\n";
f+="GetFileName=getFileName\n";
f+="GetPrettyName=getPrettyName\n";
f+="GetPrettySingleName=getPrettySingleName\n";
f+="GetParameterTypes=getParameterTypes\n";
f+="IsAbstract=isAbstract\n";
f+="GetGenericInterfaces=getGenericInterfaces\n";
f+="MakeArray=makeArray\n";
f+="GetTypeParameters=getTypeParameters\n";
f+="GetEnclosingType=getEnclosingType\n";
f+="GetDeclaredClasses=getDeclaredClasses\n";
f+="GetParameterNames=getGenericParameterTypes\n";
f+="GetGenericReturnType=getGenericReturnType\n";
f+="GetComponentType=getComponentType\n";
f+="GetGenericSuperClass=getGenericSuperClass\n";
f+="GetInterfaces=getInterfaces\n";
f+="GetReturnType=getReturnType\n";
f+="GetUpperBounds=getUpperBounds\n";
f+="Range=$core.Range\n";
f+="RangeLower=lower\n";
f+="RangeUpper=upper\n";
f+="RangeUnlimited=unlimited\n";
f+="RangeUnlimitedStep=unlimitedStep\n";
f+="ObjectsUtil=$core.ObjectsUtil\n";
f+="NewInstance=newInstance\n";
f+="SetParent=setParent\n";
f+="InvokeDirect=invokeDirect\n";
f+="GetLowerBounds=getLowerBounds\n";
f+="GetSuperClass=getSuperClass\n";
f+="IsVariable=isVariable\n";
f+="MakeWildCard=makeWildCard\n";
f+="MakeRefType=makeRefType\n";
f+="IsInstance=isInstance\n";
f+="IsAssignableFrom=isAssignableFrom\n";
f+="IsInterface=isInterface\n";
f+="GetActualTypeArguments=getActualTypeArguments\n";
f+="IsTypeVariable=isTypeVariable\n";
f+="IsPrivate=isPrivate\n";
f+="IsVarargs=isVarargs\n";
f+="IsProtected=isProtected\n";
f+="GetGenericType=getGenericType\n";
f+="IsWildCard=isWildCard\n";
f+="IsRefType=isRefType\n";
f+="IsPrimitive=isPrimitive\n";
f+="IsPackage=isPackage\n";
f+="IsAnnotation=isAnnotation\n";
f+="IllegalThreadStateException=$core.IllegalThreadState\n";
f+="TestException=exception\n";
f+="TestNullException=nullException\n";
f+="CustIterTable=$core.CustIteratorTable\n";
f+="IterTaVarSecond=U\n";
f+="ExecutedTestAnnotations=annotations\n";
f+="ExecutedTestMethod=method\n";
f+="IndexItrTa=index\n";
f+="ExecutedTestBefore=before\n";
f+="ExecuteTests=tests\n";
f+="ListClear=clear\n";
f+="GetFirstTa=getFirst\n";
f+="ListIterTable=list\n";
f+="Parameters=$core.Parameters\n";
f+="GetSecondTa=getSecond\n";
f+="TableVarSecond=U\n";
f+="ExecutedTestAfter=after\n";
f+="PairVarFirst=T\n";
f+="ExecutedTest=$core.ExecutedTest\n";
f+="ResultTime=duration\n";
f+="ResultSuccess=success\n";
f+="PairVarSecond=U\n";
f+="ResultFailMessage=failMessage\n";
f+="Difference=$core.Difference\n";
f+="EltDifference=$core.EltDifference\n";
f+="Index=index\n";
f+="AssertNot=assertNot\n";
f+="AssertNotSame=assertNotSame\n";
f+="ParametersMethod=method\n";
f+="SetFirstTa=setFirst\n";
f+="ResultParams=params\n";
f+="ExecutedTestTest=test\n";
f+="LengthItrTa=length\n";
f+="TableVarFirst=T\n";
f+="ParametersLocation=location\n";
f+="ExecuteExecute=execute\n";
f+="SetSecondTa=setSecond\n";
f+="IterTaVarFirst=T\n";
f+="GetAtomic=getValue\n";
f+="FileGetName=name\n";
f+="CurrentThread=currentThread\n";
f+="ReentrantLock=$core.ReentrantLock\n";
f+="ThreadCurrentTime=currentTime\n";
f+="ThreadCurrentNanoTime=currentTimeNanos\n";
f+="ThreadExitHook=exitHook\n";
f+="SetAtomic=setValue\n";
f+="CompareAndSetAtomic=compareAndSet\n";
f+="LazySetAtomic=lazySet\n";
f+="AddAndGetAtomic=addAndGet\n";
f+="GetAndAddAtomic=getAndAdd\n";
f+="IncrementAndGetAtomic=incrementAndGet\n";
f+="GetAndIncrementAtomic=getAndIncrement\n";
f+="DecrementAndGetAtomic=decrementAndGet\n";
f+="GetAndDecrementAtomic=getAndDecrement\n";
f+="GetAndSetAtomic=getAndSet\n";
f+="FileIsFile=isFile\n";
f+="FileRoots=roots\n";
f+="FormatType=$core.Formatting\n";
f+="GetPriority=getPriority\n";
f+="AtomicBoolean=$core.AtomicBoolean\n";
f+="AtomicLong=$core.AtomicLong\n";
f+="IsHeldByCurrentThread=isHeldByCurrentThread\n";
f+="AtomicInteger=$core.AtomicInteger\n";
f+="AppendToFile=appendToFile\n";
f+="JoinOthers=joinOthers\n";
f+="FileIsDirectory=isDirectory\n";
f+="FileGetParentPath=parentPath\n";
f+="SetPriority=setPriority\n";
f+="FileGetLength=length\n";
f+="FileListDirectories=directories\n";
f+="FileAbsolutePath=absolute\n";
f+="CustIteratorVar=T\n";
f+="SetSecond=setSecond\n";
f+="FileListFiles=files\n";
f+="FileMakeDirs=makeDirectories\n";
f+="FileLastModif=lastModification\n";
f+="CustIterator=$core.CustIterator\n";
f+="IndexItrLi=index\n";
f+="LengthItrLi=length\n";
f+="Runnable=$core.Runnable\n";
f+="Run=run\n";
f+="Sleep=sleep\n";
f+="IsAlive=isAlive\n";
f+="IsEnded=isEnded\n";
f+="End=end\n";
f+="Join=join\n";
f+="GetId=getId\n";
f+="Yield=yield\n";
f+="Lock=lock\n";
f+="Unlock=unlock\n";
f+="Thread=$core.Thread\n";
f+="ThreadSet=$core.ThreadSet\n";
f+="ThreadSetAll=all\n";
f+="ThreadSetAdd=add\n";
f+="ThreadSetContains=contains\n";
f+="ThreadSetRemove=remove\n";
f+="ThreadSetSnapshot=snapshot\n";
f+="ThreadEq=tEq\n";
f+="Start=start\n";
f+="ExecuteConvert=convert\n";
f+="AssertAssert=assert\n";
f+="AssertAssertTrue=assertTrue\n";
f+="AssertAssertFalse=assertFalse\n";
f+="DifferenceStackDiff=stackDiff\n";
f+="AssertAssertSame=assertSame\n";
f+="ExecuteSetupNoException=setupNoException\n";
f+="AssertAssertNull=assertNull\n";
f+="InfoTestCurrentClass=currentClass\n";
f+="AssertAssertNotNull=assertNotNull\n";
f+="DifferenceFoundNotTrue=foundNotTrue\n";
f+="InfoTestCurrentMethod=currentMethod\n";
f+="DifferenceFound=found\n";
f+="InfoTestCount=count\n";
f+="DifferenceFoundNull=foundNull\n";
f+="InfoTestDone=done\n";
f+="DifferenceExpected=expected\n";
f+="ConcurrentError=$core.ConcurrentError\n";
f+="InfoTestCurrentParams=currentParams\n";
f+="ExecuteSetupError=setupError\n";
f+="RemoveTa=remove\n";
f+="ListItr=list\n";
f+="List=$core.List\n";
f+="LengthLi=length\n";
f+="AddTa=add\n";
f+="SetFirst=setFirst\n";
f+="ArrayLi=array\n";
f+="File=$core.File\n";
f+="Result=$core.Result\n";
f+="Test=$core.Test\n";
f+="After=$core.After\n";
f+="Print=print\n";
f+="RemoveLi=remove\n";
f+="SizeLi=size\n";
f+="ListTa=list\n";
f+="Before=$core.Before\n";
f+="Write=write\n";
f+="Execute=$core.Execute\n";
f+="ListVar=T\n";
f+="SizeTa=size\n";
f+="First=first\n";
f+="Table=$core.Table\n";
f+="Second=second\n";
f+="Read=read\n";
f+="AddLi=add\n";
f+="CustPair=$core.PairImpl\n";
f+="GetTa=get\n";
f+="InfoTest=$core.InfoTest\n";
f+="Assert=$core.Assert\n";
f+="FileZippedBin=zippedBinary\n";
f+="FileZippedBinArray=zippedBinaryArray\n";
f+="FileZippedText=zippedText\n";
f+="FileZipBin=zipBinary\n";
f+="FileZipBinArray=zipBinaryArray\n";
f+="FileZipText=zipText\n";
f+="TableStringObject=$core.StringObjectTable\n";
f+="TableConcEmpty=emp\n";
f+="TableConcSize=size\n";
f+="TableConcKeys=keys\n";
f+="TableConcValues=values\n";
f+="TableConcHasKey=hasKey\n";
f+="TableConcHasValue=hasValue\n";
f+="TableConcPairs=pairs\n";
f+="TableConcPut=put\n";
f+="TableConcPutAbs=putAbs\n";
f+="TableConcGet=get\n";
f+="TableConcRemove=remove\n";
f+="TableConcReplace=replace\n";
f+="TableConcClear=clear\n";
f+="TableConcPutAll=putAll\n";
f+="EntryStringObject=$core.StringObjectEntry\n";
f+="TableEntryKey=key\n";
f+="TableEntryValue=value\n";
f+="TableEntryOwner=owner\n";
f+="EntryBinary=$core.BinaryEntry\n";
f+="EntryText=$core.TextEntry\n";
f+="EntryName=name\n";
f+="EntryValue=value\n";
f+="EntryTime=time\n";
f+="FileIsAbsolute=isAbsolute\n";
f+="FileReadBin=readBin\n";
f+="FileWriteBin=writeBin\n";
f+="FileDelete=delete\n";
f+="FileRename=renameTo\n";
f+="FileDir=dir\n";
f+="Eval=eval\n";
f+="DefaultPkg=$core\n";
f+="FalseString=false\n";
f+="TrueString=true\n";
f+="Infinity=Infinity\n";
f+="Nan=Nan\n";
f+="Exponent=E\n";
f+="NullString=\n";
f+="NullCoverString=null\n";
f+="NotNullCoverString=not null\n";
f+="StaticString=static\n";
f+="StaticCallString=staticCall\n";
f+="SeedGenerator0Get0=a\n";
f+="CharSequence0SubSequence0=a\n";
f+="CharSequence0SubSequence1=b\n";
f+="CharSequence0CharAt0=a\n";
f+="CharSequence0Substring0=a\n";
f+="CharSequence0Substring1=b\n";
f+="CharSequence1Substring0=a\n";
f+="CharSequence0CompareTo0=a\n";
f+="CharSequence0Contains0=a\n";
f+="CharSequence0StartsWith0=a\n";
f+="CharSequence1StartsWith0=a\n";
f+="CharSequence1StartsWith1=b\n";
f+="CharSequence0EndsWith0=a\n";
f+="CharSequence0IndexOf0=a\n";
f+="CharSequence1IndexOf0=a\n";
f+="CharSequence1IndexOf1=b\n";
f+="CharSequence2IndexOf0=a\n";
f+="CharSequence3IndexOf0=a\n";
f+="CharSequence3IndexOf1=b\n";
f+="CharSequence0LastIndexOf0=a\n";
f+="CharSequence1LastIndexOf0=a\n";
f+="CharSequence1LastIndexOf1=b\n";
f+="CharSequence2LastIndexOf0=a\n";
f+="CharSequence3LastIndexOf0=a\n";
f+="CharSequence3LastIndexOf1=b\n";
f+="CharSequence0Format0=a\n";
f+="CharSequence0Split0=a\n";
f+="CharSequence1Split0=a\n";
f+="CharSequence1Split1=b\n";
f+="CharSequence2Split0=a\n";
f+="CharSequence3Split0=a\n";
f+="CharSequence3Split1=b\n";
f+="CharSequence0SplitStrings0=a\n";
f+="CharSequence1SplitStrings0=a\n";
f+="CharSequence1SplitStrings1=b\n";
f+="CharSequence0SplitChars0=a\n";
f+="CharSequence0RegionMatches0=a\n";
f+="CharSequence0RegionMatches1=b\n";
f+="CharSequence0RegionMatches2=c\n";
f+="CharSequence0RegionMatches3=d\n";
f+="CharSequence0Equals0=a\n";
f+="CharSequence0Equals1=b\n";
f+="String0EqualsIgnoreCase0=a\n";
f+="String0Compare0=a\n";
f+="String0Compare1=b\n";
f+="String0CompareToIgnoreCase0=a\n";
f+="String0ReplaceString0=a\n";
f+="String0ReplaceString1=b\n";
f+="String1ReplaceString0=a\n";
f+="String1ReplaceString1=b\n";
f+="String0ReplaceMultiple0=a\n";
f+="String0RegionMatches0=a\n";
f+="String0RegionMatches1=b\n";
f+="String0RegionMatches2=c\n";
f+="String0RegionMatches3=d\n";
f+="String0RegionMatches4=e\n";
f+="String0ValueOfMethod0=a\n";
f+="String1ValueOfMethod0=a\n";
f+="String2ValueOfMethod0=a\n";
f+="String3ValueOfMethod0=a\n";
f+="String4ValueOfMethod0=a\n";
f+="String5ValueOfMethod0=a\n";
f+="String6ValueOfMethod0=a\n";
f+="String7ValueOfMethod0=a\n";
f+="String8ValueOfMethod0=a\n";
f+="String9ValueOfMethod0=a\n";
f+="String9ValueOfMethod1=b\n";
f+="String9ValueOfMethod2=c\n";
f+="String0String0=a\n";
f+="String1String0=a\n";
f+="String1String1=b\n";
f+="String1String2=c\n";
f+="String2String0=a\n";
f+="String3String0=a\n";
f+="String3String1=b\n";
f+="String3String2=c\n";
f+="String4String0=a\n";
f+="StringBuilder0Append0=a\n";
f+="StringBuilder1Append0=a\n";
f+="StringBuilder2Append0=a\n";
f+="StringBuilder3Append0=a\n";
f+="StringBuilder4Append0=a\n";
f+="StringBuilder5Append0=a\n";
f+="StringBuilder6Append0=a\n";
f+="StringBuilder7Append0=a\n";
f+="StringBuilder8Append0=a\n";
f+="StringBuilder9Append0=a\n";
f+="StringBuilder9Append1=b\n";
f+="StringBuilder9Append2=c\n";
f+="StringBuilder10Append0=a\n";
f+="StringBuilder11Append0=a\n";
f+="StringBuilder11Append1=b\n";
f+="StringBuilder11Append2=c\n";
f+="StringBuilder12Append0=a\n";
f+="StringBuilder13Append0=a\n";
f+="StringBuilder13Append1=b\n";
f+="StringBuilder13Append2=c\n";
f+="StringBuilder0Delete0=a\n";
f+="StringBuilder0Delete1=b\n";
f+="StringBuilder0DeleteCharAt0=a\n";
f+="StringBuilder0Insert0=a\n";
f+="StringBuilder0Insert1=b\n";
f+="StringBuilder1Insert0=a\n";
f+="StringBuilder1Insert1=b\n";
f+="StringBuilder2Insert0=a\n";
f+="StringBuilder2Insert1=b\n";
f+="StringBuilder3Insert0=a\n";
f+="StringBuilder3Insert1=b\n";
f+="StringBuilder4Insert0=a\n";
f+="StringBuilder4Insert1=b\n";
f+="StringBuilder5Insert0=a\n";
f+="StringBuilder5Insert1=b\n";
f+="StringBuilder6Insert0=a\n";
f+="StringBuilder6Insert1=b\n";
f+="StringBuilder7Insert0=a\n";
f+="StringBuilder7Insert1=b\n";
f+="StringBuilder8Insert0=a\n";
f+="StringBuilder8Insert1=b\n";
f+="StringBuilder9Insert0=a\n";
f+="StringBuilder9Insert1=b\n";
f+="StringBuilder9Insert2=c\n";
f+="StringBuilder9Insert3=d\n";
f+="StringBuilder10Insert0=a\n";
f+="StringBuilder10Insert1=b\n";
f+="StringBuilder11Insert0=a\n";
f+="StringBuilder11Insert1=b\n";
f+="StringBuilder11Insert2=c\n";
f+="StringBuilder11Insert3=d\n";
f+="StringBuilder12Insert0=a\n";
f+="StringBuilder12Insert1=b\n";
f+="StringBuilder13Insert0=a\n";
f+="StringBuilder13Insert1=b\n";
f+="StringBuilder13Insert2=c\n";
f+="StringBuilder13Insert3=d\n";
f+="StringBuilder0Replace0=a\n";
f+="StringBuilder0Replace1=b\n";
f+="StringBuilder0Replace2=c\n";
f+="StringBuilder0SetCharAt0=a\n";
f+="StringBuilder0SetCharAt1=b\n";
f+="StringBuilder0SetLength0=a\n";
f+="StringBuilder0EnsureCapacity0=a\n";
f+="StringBuilder0Same0=a\n";
f+="StringBuilder0Same1=b\n";
f+="StringBuilder0StringBuilder0=a\n";
f+="StringBuilder1StringBuilder0=a\n";
f+="StringBuilder2StringBuilder0=a\n";
f+="Replacement0Replacement0=a\n";
f+="Replacement0Replacement1=b\n";
f+="Error0CurrentStack0=a\n";
f+="Error0ToStringMethod0=a\n";
f+="Enums0Name0=a\n";
f+="Enums0Ordinal0=a\n";
f+="Range0Range0=a\n";
f+="Range0Range1=b\n";
f+="Range0UnlimitedStep0=a\n";
f+="Range0UnlimitedStep1=b\n";
f+="Range1Range0=a\n";
f+="Range2Range0=a\n";
f+="Range2Range1=b\n";
f+="Range2Range2=c\n";
f+="ObjectsUtil0SameRef0=a\n";
f+="ObjectsUtil0SameRef1=b\n";
f+="ObjectsUtil0GetParent0=a\n";
f+="ObjectsUtil0SetParent0=a\n";
f+="ObjectsUtil0SetParent1=b\n";
f+="ObjectsUtil0GetFct0=a\n";
f+="StringUtil0ValueOfMethod0=a\n";
f+="Resources0ReadResources0=a\n";
f+="Resources0ReadResourcesIndex0=a\n";
f+="Math0Abs0=a\n";
f+="Math1Abs0=a\n";
f+="Math2Abs0=a\n";
f+="Math3Abs0=a\n";
f+="Math0Max0=a\n";
f+="Math0Max1=b\n";
f+="Math1Max0=a\n";
f+="Math1Max1=b\n";
f+="Math0Min0=a\n";
f+="Math0Min1=b\n";
f+="Math1Min0=a\n";
f+="Math1Min1=b\n";
f+="Math2Max0=a\n";
f+="Math2Max1=b\n";
f+="Math3Max0=a\n";
f+="Math3Max1=b\n";
f+="Math2Min0=a\n";
f+="Math2Min1=b\n";
f+="Math3Min0=a\n";
f+="Math3Min1=b\n";
f+="Math0Quot0=a\n";
f+="Math0Quot1=b\n";
f+="Math1Quot0=a\n";
f+="Math1Quot1=b\n";
f+="Math0Mod0=a\n";
f+="Math0Mod1=b\n";
f+="Math1Mod0=a\n";
f+="Math1Mod1=b\n";
f+="Math0Plus0=a\n";
f+="Math1Plus0=a\n";
f+="Math2Plus0=a\n";
f+="Math3Plus0=a\n";
f+="Math0Minus0=a\n";
f+="Math1Minus0=a\n";
f+="Math2Minus0=a\n";
f+="Math3Minus0=a\n";
f+="Math0Neg0=a\n";
f+="Math0NegBin0=a\n";
f+="Math1NegBin0=a\n";
f+="Math4Plus0=a\n";
f+="Math4Plus1=b\n";
f+="Math5Plus0=a\n";
f+="Math5Plus1=b\n";
f+="Math6Plus0=a\n";
f+="Math6Plus1=b\n";
f+="Math7Plus0=a\n";
f+="Math7Plus1=b\n";
f+="Math4Minus0=a\n";
f+="Math4Minus1=b\n";
f+="Math5Minus0=a\n";
f+="Math5Minus1=b\n";
f+="Math6Minus0=a\n";
f+="Math6Minus1=b\n";
f+="Math7Minus0=a\n";
f+="Math7Minus1=b\n";
f+="Math0Mult0=a\n";
f+="Math0Mult1=b\n";
f+="Math1Mult0=a\n";
f+="Math1Mult1=b\n";
f+="Math2Mult0=a\n";
f+="Math2Mult1=b\n";
f+="Math3Mult0=a\n";
f+="Math3Mult1=b\n";
f+="Math0BinQuot0=a\n";
f+="Math0BinQuot1=b\n";
f+="Math1BinQuot0=a\n";
f+="Math1BinQuot1=b\n";
f+="Math2BinQuot0=a\n";
f+="Math2BinQuot1=b\n";
f+="Math3BinQuot0=a\n";
f+="Math3BinQuot1=b\n";
f+="Math0BinMod0=a\n";
f+="Math0BinMod1=b\n";
f+="Math1BinMod0=a\n";
f+="Math1BinMod1=b\n";
f+="Math2BinMod0=a\n";
f+="Math2BinMod1=b\n";
f+="Math3BinMod0=a\n";
f+="Math3BinMod1=b\n";
f+="Math0And0=a\n";
f+="Math0And1=b\n";
f+="Math1And0=a\n";
f+="Math1And1=b\n";
f+="Math2And0=a\n";
f+="Math2And1=b\n";
f+="Math0Or0=a\n";
f+="Math0Or1=b\n";
f+="Math1Or0=a\n";
f+="Math1Or1=b\n";
f+="Math2Or0=a\n";
f+="Math2Or1=b\n";
f+="Math0Xor0=a\n";
f+="Math0Xor1=b\n";
f+="Math1Xor0=a\n";
f+="Math1Xor1=b\n";
f+="Math2Xor0=a\n";
f+="Math2Xor1=b\n";
f+="Math0ShiftLeft0=a\n";
f+="Math0ShiftLeft1=b\n";
f+="Math1ShiftLeft0=a\n";
f+="Math1ShiftLeft1=b\n";
f+="Math0ShiftRight0=a\n";
f+="Math0ShiftRight1=b\n";
f+="Math1ShiftRight0=a\n";
f+="Math1ShiftRight1=b\n";
f+="Math0BitShiftLeft0=a\n";
f+="Math0BitShiftLeft1=b\n";
f+="Math1BitShiftLeft0=a\n";
f+="Math1BitShiftLeft1=b\n";
f+="Math0BitShiftRight0=a\n";
f+="Math0BitShiftRight1=b\n";
f+="Math1BitShiftRight0=a\n";
f+="Math1BitShiftRight1=b\n";
f+="Math0RotateLeft0=a\n";
f+="Math0RotateLeft1=b\n";
f+="Math1RotateLeft0=a\n";
f+="Math1RotateLeft1=b\n";
f+="Math0RotateRight0=a\n";
f+="Math0RotateRight1=b\n";
f+="Math1RotateRight0=a\n";
f+="Math1RotateRight1=b\n";
f+="Math0Le0=a\n";
f+="Math0Le1=b\n";
f+="Math0Ge0=a\n";
f+="Math0Ge1=b\n";
f+="Math0Lt0=a\n";
f+="Math0Lt1=b\n";
f+="Math0Gt0=a\n";
f+="Math0Gt1=b\n";
f+="Math1Le0=a\n";
f+="Math1Le1=b\n";
f+="Math1Ge0=a\n";
f+="Math1Ge1=b\n";
f+="Math1Lt0=a\n";
f+="Math1Lt1=b\n";
f+="Math1Gt0=a\n";
f+="Math1Gt1=b\n";
f+="Math0Random0=a\n";
f+="Math0NativeRandom0=a\n";
f+="Math0Seed0=a\n";
f+="Math0SeedSpecGenerator0=a\n";
f+="Math0SeedSpecDoubleGenerator0=a\n";
f+="Byte0ToBinString0=a\n";
f+="Byte0ToOctString0=a\n";
f+="Byte0ToHexString0=a\n";
f+="Short0ToBinString0=a\n";
f+="Short0ToOctString0=a\n";
f+="Short0ToHexString0=a\n";
f+="Integer0ToBinString0=a\n";
f+="Integer0ToOctString0=a\n";
f+="Integer0ToHexString0=a\n";
f+="Long0ToBinString0=a\n";
f+="Long0ToOctString0=a\n";
f+="Long0ToHexString0=a\n";
f+="Boolean0Compare0=a\n";
f+="Boolean0Compare1=b\n";
f+="Boolean0CompareTo0=a\n";
f+="Boolean0Equals0=a\n";
f+="Boolean0ParseBoolean0=a\n";
f+="Boolean0ToStringMethod0=a\n";
f+="Boolean0ValueOfMethod0=a\n";
f+="Boolean1ValueOfMethod0=a\n";
f+="Boolean0Boolean0=a\n";
f+="Boolean1Boolean0=a\n";
f+="Byte0ToStringMethod0=a\n";
f+="Byte0ParseByte0=a\n";
f+="Byte1ParseByte0=a\n";
f+="Byte1ParseByte1=b\n";
f+="Byte0CompareTo0=a\n";
f+="Byte0Compare0=a\n";
f+="Byte0Compare1=b\n";
f+="Byte0ParseByteOrNull0=a\n";
f+="Byte1ParseByteOrNull0=a\n";
f+="Byte1ParseByteOrNull1=b\n";
f+="Byte0Byte0=a\n";
f+="Byte1Byte0=a\n";
f+="Short0ToStringMethod0=a\n";
f+="Short0ParseShort0=a\n";
f+="Short1ParseShort0=a\n";
f+="Short1ParseShort1=b\n";
f+="Short0CompareTo0=a\n";
f+="Short0Compare0=a\n";
f+="Short0Compare1=b\n";
f+="Short0ParseShortOrNull0=a\n";
f+="Short1ParseShortOrNull0=a\n";
f+="Short1ParseShortOrNull1=b\n";
f+="Short0Short0=a\n";
f+="Short1Short0=a\n";
f+="Integer0ToStringMethod0=a\n";
f+="Integer0ParseInt0=a\n";
f+="Integer1ParseInt0=a\n";
f+="Integer1ParseInt1=b\n";
f+="Integer0CompareTo0=a\n";
f+="Integer0Compare0=a\n";
f+="Integer0Compare1=b\n";
f+="Integer0ParseIntOrNull0=a\n";
f+="Integer1ParseIntOrNull0=a\n";
f+="Integer1ParseIntOrNull1=b\n";
f+="Integer0Integer0=a\n";
f+="Integer1Integer0=a\n";
f+="Long0ToStringMethod0=a\n";
f+="Long1ToStringMethod0=a\n";
f+="Long1ToStringMethod1=b\n";
f+="Long0Signum0=a\n";
f+="Long0ParseLong0=a\n";
f+="Long1ParseLong0=a\n";
f+="Long1ParseLong1=b\n";
f+="Long0CompareTo0=a\n";
f+="Long0Compare0=a\n";
f+="Long0Compare1=b\n";
f+="Long0ParseLongOrNull0=a\n";
f+="Long1ParseLongOrNull0=a\n";
f+="Long1ParseLongOrNull1=b\n";
f+="Long0Long0=a\n";
f+="Long1Long0=a\n";
f+="Float0ToStringMethod0=a\n";
f+="Float0ParseFloat0=a\n";
f+="Float0CompareTo0=a\n";
f+="Float0Compare0=a\n";
f+="Float0Compare1=b\n";
f+="Float0ParseFloatOrNull0=a\n";
f+="Float0IsInfinite0=a\n";
f+="Float0IsNan0=a\n";
f+="Float0Float0=a\n";
f+="Float1Float0=a\n";
f+="Double0ToStringMethod0=a\n";
f+="Double0ParseDouble0=a\n";
f+="Double0CompareTo0=a\n";
f+="Double0Compare0=a\n";
f+="Double0Compare1=b\n";
f+="Double0ParseDoubleOrNull0=a\n";
f+="Double0IsInfinite0=a\n";
f+="Double0IsNan0=a\n";
f+="Double0Double0=a\n";
f+="Double1Double0=a\n";
f+="Number0ToStringMethod0=a\n";
f+="Number0Equals0=a\n";
f+="Number1Equals0=a\n";
f+="Number1Equals1=b\n";
f+="Number0CompareTo0=a\n";
f+="Number0Compare0=a\n";
f+="Number0Compare1=b\n";
f+="Character0CompareTo0=a\n";
f+="Character0Compare0=a\n";
f+="Character0Compare1=b\n";
f+="Character0Digit0=a\n";
f+="Character0Digit1=b\n";
f+="Character0ForDigit0=a\n";
f+="Character0ForDigit1=b\n";
f+="Character0GetDirectionality0=a\n";
f+="Character0GetType0=a\n";
f+="Character0IsDigit0=a\n";
f+="Character0IsLetter0=a\n";
f+="Character0IsLetterOrDigit0=a\n";
f+="Character0IsWordChar0=a\n";
f+="Character0IsWhitespace0=a\n";
f+="Character0IsLowerCase0=a\n";
f+="Character0IsUpperCase0=a\n";
f+="Character0IsSpace0=a\n";
f+="Character0ToLowerCaseChar0=a\n";
f+="Character0ToUpperCaseChar0=a\n";
f+="Character0ToStringMethod0=a\n";
f+="Character0Character0=a\n";
f+="Fct0Call0=a\n";
f+="ClassType0GetClass0=a\n";
f+="ClassType0ForName0=a\n";
f+="ClassType0ForName1=b\n";
f+="ClassType1ForName0=a\n";
f+="ClassType0IsInstance0=a\n";
f+="ClassType0IsAssignableFrom0=a\n";
f+="ClassType0DefaultInstance0=a\n";
f+="ClassType0EnumValueOf0=a\n";
f+="ClassType0GetDeclaredConstructors0=a\n";
f+="ClassType0GetDeclaredConstructors1=b\n";
f+="ClassType0GetDeclaredFields0=a\n";
f+="ClassType0GetDeclaredStaticMethods0=a\n";
f+="ClassType0GetDeclaredStaticMethods1=b\n";
f+="ClassType0GetDeclaredStaticMethods2=c\n";
f+="ClassType0GetDeclaredStaticMethods3=d\n";
f+="ClassType0GetDeclaredMethods0=a\n";
f+="ClassType0GetDeclaredMethods1=b\n";
f+="ClassType0GetDeclaredMethods2=c\n";
f+="ClassType0GetDeclaredMethods3=d\n";
f+="ClassType0GetDeclaredExplicits0=a\n";
f+="ClassType0GetDeclaredImplicits0=a\n";
f+="ClassType0GetDeclaredBlocks0=a\n";
f+="ClassType0GetDeclaredBlocks1=b\n";
f+="ClassType0MakeGeneric0=a\n";
f+="ClassType0MakeWildCard0=a\n";
f+="ClassType0MakeRef0=a\n";
f+="ClassType0GetOperators0=a\n";
f+="ClassType0GetOperators1=b\n";
f+="ClassType0GetOperators2=c\n";
f+="ClassType0ArrayNewInstance0=a\n";
f+="ClassType0ArrayGetLength0=a\n";
f+="ClassType0ArrayGet0=a\n";
f+="ClassType0ArrayGet1=b\n";
f+="ClassType0ArraySet0=a\n";
f+="ClassType0ArraySet1=b\n";
f+="ClassType0ArraySet2=c\n";
f+="ClassType0TryWrap0=a\n";
f+="Constructor0NewInstance0=a\n";
f+="Field0GetField0=a\n";
f+="Field0SetField0=a\n";
f+="Field0SetField1=b\n";
f+="Method0Invoke0=a\n";
f+="Method0Invoke1=b\n";
f+="Method0InvokeDirect0=a\n";
f+="Method0InvokeDirect1=b\n";
f+="Method0GetDeclaredAnonymousLambdaLocalVarsNb0=a\n";
f+="Method0GetDeclaredAnonymousLambdaLocalVars0=a\n";
f+="Method0GetDeclaredAnonymousLambdaLocalVars1=b\n";
f+="Method0GetDeclaredAnonymousLambdaLocalVars2=c\n";
f+="Method1GetDeclaredAnonymousLambdaLocalVars0=a\n";
f+="Method1GetDeclaredAnonymousLambdaLocalVars1=b\n";
f+="Method2GetDeclaredAnonymousLambdaLocalVars0=a\n";
f+="Method2GetDeclaredAnonymousLambdaLocalVars1=b\n";
f+="Method3GetDeclaredAnonymousLambdaLocalVars0=a\n";
f+="Method0GetDeclaredAnonymousLambdaLoopVars0=a\n";
f+="Method0GetDeclaredAnonymousLambdaLoopVars1=b\n";
f+="Method0GetDeclaredAnonymousLambdaLoopVars2=c\n";
f+="Method1GetDeclaredAnonymousLambdaLoopVars0=a\n";
f+="Method1GetDeclaredAnonymousLambdaLoopVars1=b\n";
f+="Method2GetDeclaredAnonymousLambdaLoopVars0=a\n";
f+="Method2GetDeclaredAnonymousLambdaLoopVars1=b\n";
f+="Method3GetDeclaredAnonymousLambdaLoopVars0=a\n";
f+="AnnotationType0GetString0=a\n";
f+="Annotated0GetAnnotations0=a\n";
f+="Annotated0GetAnnotationsParameters0=a\n";
f+="Annotated0GetDeclaredAnonymousLambda0=a\n";
f+="Annotated0GetDeclaredAnonymousLambda1=b\n";
f+="Annotated0GetDeclaredAnonymousLambda2=c\n";
f+="Annotated0GetDeclaredAnonymousLambda3=d\n";
f+="Annotated0GetDeclaredSwitchMethods0=a\n";
f+="Annotated0GetDeclaredSwitchMethods1=b\n";
f+="Annotated0GetDeclaredSwitchMethods2=c\n";
f+="Annotated0GetDeclaredSwitchMethods3=d\n";
f+="Thread0SetPriority0=a\n";
f+="Thread0Sleep0=a\n";
f+="Thread0Print0=a\n";
f+="Thread1Print0=a\n";
f+="Thread2Print0=a\n";
f+="Thread2Print1=b\n";
f+="Thread0ThreadExitHook0=a\n";
f+="Thread0Thread0=a\n";
f+="Thread0ThreadEq0=a\n";
f+="Thread0ThreadEq1=b\n";
f+="ThreadSet0ThreadSetAdd0=a\n";
f+="ThreadSet0ThreadSetContains0=a\n";
f+="ThreadSet0ThreadSetRemove0=a\n";
f+="ThreadSet0ThreadSet0=a\n";
f+="ReentrantLock0ReentrantLock0=a\n";
f+="AtomicBoolean0SetAtomic0=a\n";
f+="AtomicBoolean0CompareAndSetAtomic0=a\n";
f+="AtomicBoolean0CompareAndSetAtomic1=b\n";
f+="AtomicBoolean0GetAndSetAtomic0=a\n";
f+="AtomicBoolean0LazySetAtomic0=a\n";
f+="AtomicBoolean0AtomicBoolean0=a\n";
f+="AtomicInteger0SetAtomic0=a\n";
f+="AtomicInteger0CompareAndSetAtomic0=a\n";
f+="AtomicInteger0CompareAndSetAtomic1=b\n";
f+="AtomicInteger0GetAndSetAtomic0=a\n";
f+="AtomicInteger0LazySetAtomic0=a\n";
f+="AtomicInteger0AddAndGetAtomic0=a\n";
f+="AtomicInteger0GetAndAddAtomic0=a\n";
f+="AtomicInteger0AtomicInteger0=a\n";
f+="AtomicLong0SetAtomic0=a\n";
f+="AtomicLong0CompareAndSetAtomic0=a\n";
f+="AtomicLong0CompareAndSetAtomic1=b\n";
f+="AtomicLong0GetAndSetAtomic0=a\n";
f+="AtomicLong0LazySetAtomic0=a\n";
f+="AtomicLong0AddAndGetAtomic0=a\n";
f+="AtomicLong0GetAndAddAtomic0=a\n";
f+="AtomicLong0AtomicLong0=a\n";
f+="TableStringObject0ConcKeys0=a\n";
f+="TableStringObject0ConcHasKey0=a\n";
f+="TableStringObject0ConcHasValue0=a\n";
f+="TableStringObject0Get0=a\n";
f+="TableStringObject0Remove0=a\n";
f+="TableStringObject0PutAll0=a\n";
f+="TableStringObject0Put0=a\n";
f+="TableStringObject0Put1=b\n";
f+="TableStringObject0PutAbs0=a\n";
f+="TableStringObject0PutAbs1=b\n";
f+="TableStringObject0Replace0=a\n";
f+="TableStringObject0Replace1=b\n";
f+="EntryStringObject0TableEntryValue0=a\n";
f+="EntryBinary0EntryBinary0=a\n";
f+="EntryBinary0EntryBinary1=b\n";
f+="EntryBinary0EntryTime0=a\n";
f+="EntryText0EntryText0=a\n";
f+="EntryText0EntryText1=b\n";
f+="EntryText0EntryTime0=a\n";
f+="File0Read0=a\n";
f+="File0Write0=a\n";
f+="File0Write1=b\n";
f+="File0FileReadBin0=a\n";
f+="File0FileWriteBin0=a\n";
f+="File0FileWriteBin1=b\n";
f+="File0ThreadSetRemove0=a\n";
f+="File0FileRename0=a\n";
f+="File0FileRename1=b\n";
f+="File0FileDir0=a\n";
f+="File0AppendToFile0=a\n";
f+="File0AppendToFile1=b\n";
f+="File0FileAbsolutePath0=a\n";
f+="File0FileGetName0=a\n";
f+="File0FileGetParentPath0=a\n";
f+="File0FileGetLength0=a\n";
f+="File0FileLastModif0=a\n";
f+="File0FileListDirectories0=a\n";
f+="File0FileListFiles0=a\n";
f+="File0FileIsDirectory0=a\n";
f+="File0FileIsFile0=a\n";
f+="File0FileIsAbsolute0=a\n";
f+="File0FileZipBin0=a\n";
f+="File0FileZipBin1=b\n";
f+="File0FileZipBinArray0=a\n";
f+="File0FileZipText0=a\n";
f+="File0FileZipText1=b\n";
f+="File0FileZippedBin0=a\n";
f+="File0FileZippedBinArray0=a\n";
f+="File0FileZippedText0=a\n";
f+="File0FileMakeDirs0=a\n";
f+="CustIterator0CustIterator0=a\n";
f+="List0AddLi0=a\n";
f+="List1AddLi0=a\n";
f+="List1AddLi1=b\n";
f+="List0This0=a\n";
f+="List1This0=a\n";
f+="List0RemoveLi0=a\n";
f+="List0List0=a\n";
f+="List1List0=a\n";
f+="CustPair0SetFirst0=a\n";
f+="CustPair0SetSecond0=a\n";
f+="CustPair0CustPair0=a\n";
f+="CustPair0CustPair1=b\n";
f+="CustIterTable0CustIterTable0=a\n";
f+="Table0AddLi0=a\n";
f+="Table0AddLi1=b\n";
f+="Table1AddLi0=a\n";
f+="Table0GetTa0=a\n";
f+="Table0GetFirstTa0=a\n";
f+="Table0GetSecondTa0=a\n";
f+="Table0SetFirst0=a\n";
f+="Table0SetFirst1=b\n";
f+="Table0SetSecond0=a\n";
f+="Table0SetSecond1=b\n";
f+="Table0RemoveLi0=a\n";
f+="Execute0ExecuteTests0=a\n";
f+="Execute0Run0=a\n";
f+="Execute0Run1=b\n";
f+="Execute0Run2=c\n";
f+="Execute0ExecuteConvert0=a\n";
f+="Execute0ExecuteSetupNoException0=a\n";
f+="Execute0ExecuteSetupNoException1=b\n";
f+="Execute0ExecuteSetupError0=a\n";
f+="Execute0ExecuteSetupError1=b\n";
f+="Execute0ExecuteSetupError2=c\n";
f+="Execute0ExecuteSetupError3=d\n";
f+="Execute1ExecuteSetupError0=a\n";
f+="Execute1ExecuteSetupError1=b\n";
f+="Execute1ExecuteSetupError2=c\n";
f+="Assert0AssertAssert0=a\n";
f+="Assert0AssertAssert1=b\n";
f+="Assert1AssertAssert0=a\n";
f+="Assert1AssertAssert1=b\n";
f+="Assert2AssertAssert0=a\n";
f+="Assert2AssertAssert1=b\n";
f+="Assert3AssertAssert0=a\n";
f+="Assert3AssertAssert1=b\n";
f+="Assert4AssertAssert0=a\n";
f+="Assert4AssertAssert1=b\n";
f+="Assert5AssertAssertDouble0=a\n";
f+="Assert5AssertAssertDouble1=b\n";
f+="Assert5AssertAssertDouble2=c\n";
f+="Assert0AssertAssertArr0=a\n";
f+="Assert0AssertAssertArr1=b\n";
f+="Assert1AssertAssertArr0=a\n";
f+="Assert1AssertAssertArr1=b\n";
f+="Assert2AssertAssertArr0=a\n";
f+="Assert2AssertAssertArr1=b\n";
f+="Assert3AssertAssertArr0=a\n";
f+="Assert3AssertAssertArr1=b\n";
f+="Assert4AssertAssertArr0=a\n";
f+="Assert4AssertAssertArr1=b\n";
f+="Assert5AssertAssertArrDouble0=a\n";
f+="Assert5AssertAssertArrDouble1=b\n";
f+="Assert5AssertAssertArrDouble2=c\n";
f+="Assert0AssertAssertNot0=a\n";
f+="Assert0AssertAssertNot1=b\n";
f+="Assert1AssertAssertNot0=a\n";
f+="Assert1AssertAssertNot1=b\n";
f+="Assert2AssertAssertNot0=a\n";
f+="Assert2AssertAssertNot1=b\n";
f+="Assert3AssertAssertNot0=a\n";
f+="Assert3AssertAssertNot1=b\n";
f+="Assert4AssertAssertNot0=a\n";
f+="Assert4AssertAssertNot1=b\n";
f+="Assert5AssertAssertNotDouble0=a\n";
f+="Assert5AssertAssertNotDouble1=b\n";
f+="Assert5AssertAssertNotDouble2=c\n";
f+="Assert0AssertAssertNotArr0=a\n";
f+="Assert0AssertAssertNotArr1=b\n";
f+="Assert1AssertAssertNotArr0=a\n";
f+="Assert1AssertAssertNotArr1=b\n";
f+="Assert2AssertAssertNotArr0=a\n";
f+="Assert2AssertAssertNotArr1=b\n";
f+="Assert3AssertAssertNotArr0=a\n";
f+="Assert3AssertAssertNotArr1=b\n";
f+="Assert4AssertAssertNotArr0=a\n";
f+="Assert4AssertAssertNotArr1=b\n";
f+="Assert5AssertAssertNotArrDouble0=a\n";
f+="Assert5AssertAssertNotArrDouble1=b\n";
f+="Assert5AssertAssertNotArrDouble2=c\n";
f+="Assert0AssertAssertTrue0=a\n";
f+="Assert0AssertAssertFalse0=a\n";
f+="Assert0AssertAssertNull0=a\n";
f+="Assert0AssertAssertNotNull0=a\n";
f+="Assert0AssertAssertSame0=a\n";
f+="Assert0AssertAssertSame1=b\n";
f+="Assert0AssertAssertNotSame0=a\n";
f+="Assert0AssertAssertNotSame1=b\n";
f+="Assert5AssertAssert0=a\n";
f+="Assert5AssertAssert1=b\n";
f+="Assert5AssertAssert2=c\n";
f+="Assert6AssertAssert0=a\n";
f+="Assert6AssertAssert1=b\n";
f+="Assert5AssertAssertArr0=a\n";
f+="Assert5AssertAssertArr1=b\n";
f+="Assert5AssertAssertArr2=c\n";
f+="Assert6AssertAssertArr0=a\n";
f+="Assert6AssertAssertArr1=b\n";
f+="Assert5AssertAssertNot0=a\n";
f+="Assert5AssertAssertNot1=b\n";
f+="Assert5AssertAssertNot2=c\n";
f+="Assert6AssertAssertNot0=a\n";
f+="Assert6AssertAssertNot1=b\n";
f+="Assert5AssertAssertNotArr0=a\n";
f+="Assert5AssertAssertNotArr1=b\n";
f+="Assert5AssertAssertNotArr2=c\n";
f+="Assert6AssertAssertNotArr0=a\n";
f+="Assert6AssertAssertNotArr1=b\n";
f+="FormatType0Print0=a\n";
f+="FormatType1Print0=a\n";
f+="FormatType1Print1=b\n";
f+="Math0Eval0=a\n";
f+="Math0Eval1=b\n";
return f;
}
static String resourcesLgAliasesFrKeywords(){
String f="Interface=interface\n";
f+="Continue=iterer\n";
f+="Abstract=abstrait\n";
f+="Instanceof=instancede\n";
f+="ToString=$chaine\n";
f+="Private=prive\n";
f+="Annotation=annotation\n";
f+="Public=public\n";
f+="Var=var\n";
f+="Break=sortir\n";
f+="True=vrai\n";
f+="Static=static\n";
f+="StaticCall=staticAppel\n";
f+="While=tantque\n";
f+="If=si\n";
f+="Return=retour\n";
f+="Null=nul\n";
f+="Elseif=sinonsi\n";
f+="False=faux\n";
f+="For=pour\n";
f+="Class=classe\n";
f+="Final=final\n";
f+="New=nouveau\n";
f+="Cast=$\n";
f+="Explicit=explicite\n";
f+="Throw=lancer\n";
f+="Else=sinon\n";
f+="Try=essai\n";
f+="This=ceci\n";
f+="Value=valeur\n";
f+="Iter=iter\n";
f+="Catch=capture\n";
f+="Switch=selon\n";
f+="Case=cas\n";
f+="Do=faire\n";
f+="Enum=enum\n";
f+="Normal=normal\n";
f+="Foreach=pourchaque\n";
f+="EscUnicode=u\n";
f+="EscFeed=r\n";
f+="Interfaces=interfaces\n";
f+="EscBound=b\n";
f+="Finally=finallement\n";
f+="Protected=protege\n";
f+="DefaultValue=valDefaut\n";
f+="Package=paquetage\n";
f+="Operator=operateur\n";
f+="EscForm=f\n";
f+="Default=autrement\n";
f+="Parent=$parent\n";
f+="EscLine=n\n";
f+="Super=super\n";
f+="EscSpace=s\n";
f+="EscTab=t\n";
f+="Intern=$interne\n";
f+="Bool=bool\n";
f+="Id=$id\n";
f+="That=cela\n";
f+="NbHex=x\n";
f+="NbHexEnd=x\n";
f+="NbBin=b\n";
f+="Values=$valeurs\n";
f+="Lambda=$lambda\n";
f+="Vararg=$vararg\n";
f+="Firstopt=$premieropt\n";
f+="NbExpBin=p\n";
f+="ValueOf=$valeurDe\n";
f+="Superaccess=superacces\n";
f+="NbExpDec=e\n";
f+="Thisaccess=cetacces\n";
f+="Classchoice=choixclasse\n";
f+="NbSufDoublePrim=d\n";
f+="NbSufDouble=D\n";
f+="NbSufFloatPrim=f\n";
f+="NbSufFloat=F\n";
f+="NbSufLongPrim=o8\n";
f+="NbSufLong=O8\n";
f+="NbSufIntegerPrim=o4\n";
f+="NbSufInteger=O4\n";
f+="NbSufCharacterPrim=c\n";
f+="NbSufCharacter=C\n";
f+="NbSufShortPrim=o2\n";
f+="NbSufShort=O2\n";
f+="NbSufBytePrim=o\n";
f+="NbSufByte=O\n";
return f;
}
static String resourcesLgAliasesFrMessages(){
String f="EmptyWord={0} a un mot cl&eacute; vide.\n";
f+="NotWordChar={0} contient un caract&egrave;re {1} qui n''est pas un caract&egrave;re de mot.\n";
f+="DigitFirst={0} commence par {1} qui est un chiffre.\n";
f+="EmptyString={0} a un mot cl&eacute; vide sp&eacute;cifique aux chaines.\n";
f+="EmptyNb={0} a un mot cl&eacute; vide sp&eacute;cifique aux nombres.\n";
f+="EmptyBinExp=exponentielle binaire vide\n";
f+="EmptyPreBin=pr&eacute;fixe binaire vide\n";
f+="EmptyPreHex=pr&eacute;fixe hexad&eacute;cimal vide\n";
f+="IllegalChar=le mot cl&eacute; num&eacute;rique {0} contient un caract&egrave;re {1} qui est ill&eacute;gal.\n";
f+="IllegalFirstChar=le mot cl&eacute; num&eacute;rique {0} commence par {1} qui est ill&eacute;gal en tant que premier caract&egrave;re\n";
f+="EmptyPrimitive={0} a une valeur de type primitive vide.\n";
f+="NotWordCharPrimitive={0} contient un caract&egrave;re {1} qui n''est pas un caract&egrave;re de mot.\n";
f+="PrimitiveKeyWord=la primitive {0}:{1} est une chaine doublon d''un mot cl&eacute;.\n";
f+="DigitFirstPrimitive={0} commence par {1} qui est un chiffre.\n";
f+="EmptyRefType={0} a une valeur de type r&eacute;f&eacute;rence vide.\n";
f+="EmptyRefTypeIn={0} a une valeur de type r&eacute;f&eacute;rence vide entre deux points {1}.\n";
f+="NotWordCharRefType={0} contient un caract&egrave;re {1} qui n''est pas un caract&egrave;re de mot.\n";
f+="RefTypeKeyWord=le type r&eacute;f&eacute;rence {0}:{1} contient une chaine doublon d''un mot cl&eacute;.\n";
f+="RefTypePrimitive=le type r&eacute;f&eacute;rence {0}:{1} contient une chaine doublon d''une primitive.\n";
f+="DigitFirstRefType={0} commence par {1} qui est un chiffre.\n";
f+="EmptyPkgRefType={0}:{1} n''appartient pas &agrave; un paquetage.\n";
f+="DefaultPkgRefType={0} correspond au paquetage par d&eacute;faut {1}.\n";
f+="DefaultPkgNoMatch=le paquetage par d&eacute;faut {0} n''a pas de type r&eacute;f&eacute;rence.\n";
f+="EmptyMethod=la m&eacute;thode cl&eacute; {0} dans le type r&eacute;f&eacute;rence {1} a un nom vide.\n";
f+="NotWordCharMethod=le nom de m&eacute;thode {0} dans le type r&eacute;f&eacute;rence {1} contient un caract&egrave;re {2} qui n''est pas un caract&egrave;re de mot.\n";
f+="MethodKeyWord=le nom de m&eacute;thode {0} dans le type r&eacute;f&eacute;rence {1}:{2} est une chaine doublon d''un mot cl&eacute;.\n";
f+="MethodPrimitive=le nom de m&eacute;thode {0} dans le type r&eacute;f&eacute;rence {1}:{2} est une chaine doublon d''une primitive.\n";
f+="DigitFirstMethod=le nom de m&eacute;thode {0} dans le type r&eacute;f&eacute;rence {1} commence par {2} qui est un chiffre.\n";
f+="EmptyField=le champ cl&eacute; {0} dans le type r&eacute;f&eacute;rence {1} a un nom vide.\n";
f+="NotWordCharField=le nom de champ {0} dans le type r&eacute;f&eacute;rence {1} contient a caract&egrave;re {2} qui n''est pas un caract&egrave;re de mot.\n";
f+="FieldKeyWord=le nom de champ {0} dans le type r&eacute;f&eacute;rence {1}:{2} est une chaine doublon d''un mot cl&eacute;.\n";
f+="FieldPrimitive=le nom de champ {0} dans le type r&eacute;f&eacute;rence {1}:{2} est une chaine doublon d''une primitive.\n";
f+="DigitFirstField=le nom de champ {0} dans le type r&eacute;f&eacute;rence {1} commence par {2} qui est un chiffre.\n";
f+="EmptyVarType=le type variable cl&eacute; {0} dans le type r&eacute;f&eacute;rence {1} a un nom vide.\n";
f+="NotWordCharVarType=le nom de type variable {0} dans le type r&eacute;f&eacute;rence {1} contient a caract&egrave;re {2} qui n''est pas un caract&egrave;re de mot.\n";
f+="VarTypeKeyWord=le nom de type variable {0} dans le type r&eacute;f&eacute;rence {1}:{2} est une chaine doublon d''un mot cl&eacute;.\n";
f+="VarTypePrimitive=le nom de type variable {0} dans le type r&eacute;f&eacute;rence {1}:{2} est une chaine doublon d''une primitive.\n";
f+="DigitFirstVarType=le nom de type variable {0} dans le type r&eacute;f&eacute;rence {1} commence par {2} qui est un chiffre.\n";
f+="DuplicateKeyWord={0} est dupliqu&eacute; en tant que mot cl&eacute;.\n";
f+="DuplicateStringWord={0} est dupliqu&eacute; en tant que &eacute;chappement dans une chaine.\n";
f+="DuplicateStarting=le mot d''&eacute;chappement {0} commence par le mot d''&eacute;chappement {1}.\n";
f+="DuplicateStartingUni=le mot d''&eacute;chappement {0} commence par le caract&egrave;re unicode d''&eacute;chappement {1}.\n";
f+="DuplicateNumberWord={0} est dupliqu&eacute; en tant que mot dans un nombre.\n";
f+="DuplicateStartingNb=le mot dans un nombre {0} commence par le mot dans un nombre {1}.\n";
f+="DuplicatePrimtive=la primitive {0} est dupliqu&eacute;.\n";
f+="DuplicateRefType=le type r&eacute;f&eacute;rence {0} est dupliqu&eacute;.\n";
f+="DuplicateMethod=le nom de m&eacute;thode {0} est dupliqu&eacute;.\n";
f+="DuplicateField=le nom de champ {0} est dupliqu&eacute;.\n";
f+="DuplicateVarType=le nom de type variable {0} est dupliqu&eacute;.\n";
f+="DuplicateMergedMethod=le nom de m&eacute;thode fusionn&eacute; {0}:{1} est dupliqu&eacute;.\n";
f+="AbstractMethodBody=La m&eacute;thode {1} dans le type {0} est abstraite et ne peut pas avoir de corps.\n";
f+="AbstractMethodConc=La m&eacute;thode {1} dans le type concret {0} ne doit pas &ecirc;tre abstraite.\n";
f+="AbstractMethodImpl=La m&eacute;thode {1} provenant du type {0} doit &ecirc;tre red&eacute;finie dans le type concret {2}.\n";
f+="AbstractMethodRef=La m&eacute;thode {1} provenant du type {0} ne doit pas &ecirc;tre appel&eacute;e directement &agrave; de son abstraction.\n";
f+="InaccessibleType=Le type {0} n''est pas accessible depuis le type {1}.\n";
f+="UnexpectedType=Le type {0} est inattendu.\n";
f+="UnexpectedRetType=Le type de retour {0} dans la fonction {1} est inattendu.\n";
f+="MethodsAccesses=La m&eacute;thode {1} provenant du type {0} est strictement plus accessible que la m&eacute;thode {3} provenant du type {2}.\n";
f+="EmptyPackage=Un type doit avoir un paquetage non vide.\n";
f+="EmptyPartClassName=La partie ne doit pas &ecirc;tre vide.\n";
f+="BadPartClassName=La partie {0} dans un type n''est pas valide. Elle doit &ecirc;tre un mot.\n";
f+="KeyWordPartClassName=La partie {0} dans un type n''est pas valide. Elle ne doit pas &ecirc;tre un mot cl&eacute;.\n";
f+="PrimPartClassName=La partie {0} dans un type n''est pas valide. Elle ne doit pas &ecirc;tre un type primitif.\n";
f+="DigitPartClassName=La partie {0} dans un type n''est pas valide. Elle ne doit pas commencer par un chiffre.\n";
f+="BadPartVarClassName=La partie {0} dans un type variable n''est pas valide. Elle doit &ecirc;tre un mot.\n";
f+="KeyWordPartVarClassName=La partie {0} dans un type variable n''est pas valide. Elle ne doit pas &ecirc;tre un mot cl&eacute;.\n";
f+="PrimPartVarClassName=La partie {0} dans un type variable n''est pas valide. Elle ne doit pas &ecirc;tre un type primitif.\n";
f+="DigitPartVarClassName=La partie {0} dans un type variable n''est pas valide. Elle ne doit pas commencer par un chiffre.\n";
f+="DuplicatedPartVarClassName=La partie {0} dans un type variable est dupliqu&eacute;e.\n";
f+="CallCtorEnd=L''appel d''un constructeur passant l''instance implicitement doit &ecirc;tre effectu&eacute; &agrave; la fin de l''instruction.\n";
f+="CallCtor=L''appel d''un constructeur passant l''instance implicitement doit &ecirc;tre effectu&eacute; dans un constructeur.\n";
f+="CallCtorBeforeBlock=L''appel d''un constructeur passant l''instance implicitement doit &ecirc;tre effectu&eacute; avant un bloc d''instructions.\n";
f+="CallCtorFirstLine=L''appel d''un constructeur du type ou de la super classe passant l''instance implicitement doit &ecirc;tre effectu&eacute; sur la premi&egrave;re ligne.\n";
f+="CallCtorIntFromSuperInt=L''appel d''un constructeur d''interface doit r&eacute;f&eacute;rencer une super interface du type appelant.\n";
f+="CallCtorIntNotFromInt=L''appel d''un constructeur d''interface ne doit pas &ecirc;tre fait dans un constructeur d''interface.\n";
f+="CallCtorIntAfterSuperThis=Un appel d''un constructeur d''interface ne peut &ecirc;tre effectu&eacute; qu''apr&egrave;s un appel de constructeur passant l''instance implicitement.\n";
f+="CallCtorIntInherits=L''appel du constructeur de l''interface {0} ne peut pas &ecirc;tre effectu&eacute; avant l''appel du constructeur de l''interface {1}.\n";
f+="CallCtorSuperClassEnumSingleton=Le super constructeur ne peut &ecirc;tre appel&eacute; que depuis une classe ou une enum&eacute;ration (singleton ou normale).\n";
f+="CallCtorNoSuperClassEnum=Il n''y a pas de type utilisateur &agrave; &ecirc;tre appel&eacute; depuis cette classe ou &eacute;num&eacute;ration (singleton or normale).\n";
f+="AnnotFieldNotUniq=Le champ de l''annotatation n''a pas &ecirc;tre trouv&eacute; de mani&egrave;re unique.\n";
f+="AnnotFieldMust=Le champ {0} de l''annotatation est obligatoire.\n";
f+="DupSuppliedAnnotField=Le champ {0} de l''annotatation est fourni en doublon.\n";
f+="BadExpression=Caract&egrave;re inattendu {0} &agrave; la position {1} dans l''expression {2}\n";
f+="BadFieldName=Le nom de champ {0} n''est pas valide. Il doit &ecirc;tre un mot.\n";
f+="KeyWordFieldName=Le nom de champ {0} n''est pas valide. Il ne doit pas &ecirc;tre un mot cl&eacute;.\n";
f+="PrimFieldName=Le nom de champ {0} n''est pas valide. Il ne doit pas &ecirc;tre un type primitif.\n";
f+="DigitFieldName=Le nom de champ {0} n''est pas valide. Il ne doit pas commencer par un chiffre.\n";
f+="NotRetrievedFields=Aucun champ n''a pas &ecirc;tre r&eacute;cup&eacute;r&eacute;.\n";
f+="BadNbFormat=Mauvais format de nombre {0}\n";
f+="BadCharFormat=Mauvais format de caract&egrave;re {0}\n";
f+="BadImplicitCast=Le type {0} ne peut pas &ecirc;tre implicitement converti en {1}\n";
f+="NotPrimitiveWrapper=Le type {0} n''est pas un type primitive ou un type enveloppeur.\n";
f+="VoidType=Le type ne peut pas &ecirc;tre le mot cl&eacute; {0}.\n";
f+="BadIndexInParser=Mauvais indice en parsant.\n";
f+="IllegalCharacter=Les caract&egrave;res ascii {0} sont ill&eacute;gaux.\n";
f+="CallIntInherits=Initialiser l''interface {0} ne peut pas &ecirc;tre effectu&eacute; avant d''initialiser l''interface {1}.\n";
f+="CallIntNoNeed=Initialiser un type depuis l''interface {0} n''est pas n&eacute;cessaire.\n";
f+="CallIntNoNeedType=Initialiser l''interface {0} depuis le type {1} n''est pas n&eacute;cessaire.\n";
f+="CallIntNeedType=Initialiser l''interface {0} depuis le type {1} est n&eacute;cessaire.\n";
f+="CallIntOnly=Le type {0} n''est pas une interface.\n";
f+="BadInheritsType=Le type {0} ne peut pas avoir le type {1} en tant que super type.\n";
f+="BadInheritsTypeInn=Le type {0} ne peut pas avoir le type {1} en tant que super type parce que {1} est un type d''instance.\n";
f+="BadInheritsTypeAsInn=Le type {0} ne peut pas avoir le type {1} en tant que super type parce que {1} est un type d''instance.\n";
f+="BadInheritsTypeInt=Le type {0} ne peut pas avoir le type {1} en tant que super type parce que {1} n''est pas une interface.\n";
f+="FinalType=Le type {0} ne peut pas avoir le type {1} en tant que super type parce que {1} est final.\n";
f+="DuplicateSuper=Le type {0} ne peut pas avoir le type {1} dupliqu&eacute; en tant que super type {2} fois.\n";
f+="ReservedType=Le type {0} ne peut pas avoir explicitement le the type {1} en tant que super type parce que {1} est r&eacute;serv&eacute;.\n";
f+="SuperClass=La classe {0} ne peut pas avoir plus d''une super classe ({1} fois).\n";
f+="UnknownSuperType=Les super types du type static {0} n''ont pas pu &ecirc;tre trouv&eacute;s.\n";
f+="CyclicInherits=Le type {0} appartient &agrave; un h&eacute;ritage cyclique.\n";
f+="AnnotationParam=L''annotation {0} ne peut pas &ecirc;tre param&eacute;tr&eacute;e.\n";
f+="CyclicMapping=Les types variables du type {0} ont un h&eacute;ritage cyclique.\n";
f+="AbsMapping=Il y a {0} types abstraits en tant que bornes sup&eacute;rieures.\n";
f+="FinalMapping=Il y a au moins un type final en tant que borne sup&eacute;rieure ({0} fois).\n";
f+="MustCallIntCtor=Le type {0} doit avoir un constructeur vu l''implementation d''interfaces avec des &eacute;l&eacute;ments d''instance.\n";
f+="MustNotCallIntCtorAfterThis=Il ne doit pas y avoir un appel de constructor apr&egrave;s un appel de constructor alternatif.\n";
f+="MustCallIntCtorNeed=Un constructor du type {0} doit &ecirc;tre appel&eacute; dans le constructeur.\n";
f+="MustCallIntCtorNotNeed=Un constructor du type {0} ne doit pas &ecirc;tre appel&eacute; dans le constructeur.\n";
f+="BadLabel=Un &eacute;tiquette doit &ecirc;tre un mot (pouvant inclure des caract&egrave;res dollars).\n";
f+="DuplicatedLabel=L''&eacute;tiquette est dupliqu&eacute;e.\n";
f+="BadMethodName=Le nom de m&eacute;thode {0} n''est pas valide. Il doit &ecirc;tre un mot.\n";
f+="KeyWordMethodName=Le nom de m&eacute;thode {0} n''est pas valide. Il ne doit pas &ecirc;tre un mot cl&eacute;.\n";
f+="PrimMethodName=Le nom de m&eacute;thode {0} n''est pas valide. Il ne doit pas &ecirc;tre un type primitif.\n";
f+="DigitMethodName=Le nom de m&eacute;thode {0} n''est pas valide. Il ne doit pas commencer par un chiffre.\n";
f+="BadOperatorName=Le symbole d''op&eacute;rateur {0} n''est pas valide.\n";
f+="BadAccess=La m&eacute;thode {0} doit &ecirc;tre publique.\n";
f+="BadReturnType=La m&eacute;thode {0} doit avoir {1} as return type.\n";
f+="BadParams=La m&eacute;thode {0} doit avoir un param&egrave;tre.\n";
f+="BadMethodModifier=La m&eacute;thode {0} doit &ecirc;tre statique.\n";
f+="BadMethodVararg=La m&eacute;thode {0} ne doit pas &ecirc;tre avec un nombre d''argument variable.\n";
f+="BadIndexerParams=L''indexeur {0} doit avoir au moins un param&egrave;tre.\n";
f+="BadIndexerModifier=L''indexeur {0} ne doit pas &ecirc;tre static.\n";
f+="BadIndexerModifiers=Les indexeurs {0} lecture et &eacute;criture doivent avoir le m&ecirc;me modificateur.\n";
f+="BadIndexerAccesses=Les indexeurs {0} lecture et &eacute;criture doivent avoir le m&ecirc;me acc&egrave;s.\n";
f+="BadIndexerPairGet=L''indexeur {0} lecture doit &ecirc;tre defini.\n";
f+="BadIndexerPairSet=L''indexeur {0} &eacute;criture doit &ecirc;tre defini.\n";
f+="DuplicateCustomMethod=La m&eacute;thode {0} est dupliqu&eacute;e.\n";
f+="ReservedCustomMethod=La m&eacute;thode {0} est r&eacute;serv&eacute;e.\n";
f+="DuplicateIndexer=L''indexeur {0} est dupliqu&eacute;.\n";
f+="DuplicateOperator=L''op&eacute;rateur {0} est dupliqu&eacute;.\n";
f+="FunctionalApplyNbDiff=Le nombre d''arguments obligatoires {0} est diff&eacute;rent du nombre d''arguments fournis {1} pour la m&eacute;thode du type elliptique {2}\n";
f+="FunctionalApplyOnly=Seule la m&eacute;thode {0} peut &ecirc;tre utilis&eacute;e pour le type elliptique {1}\n";
f+="OperatorNbDiff=Le nombre d''op&eacute;randes obligatoires {0} est diff&eacute;rent du nombre d''op&eacute;randes fournis {1} pour l''op&eacute;rateur {2}\n";
f+="SplitComa=Le nombre de parties obligatoires s&eacute;par&eacute;es par virgules {0} est sup&eacute;rieur au nombre de parties fournies s&eacute;par&eacute;es par virgules {1}.\n";
f+="SplitComaLow=Le nombre de parties obligatoires s&eacute;par&eacute;es par virgules {0} est inf&eacute;rieur au nombre de parties fournies s&eacute;par&eacute;es par virgules {1}.\n";
f+="SplitDiff=Le nombre d''op&eacute;randes obligatoires {0} est diff&eacute;rent du nombre d''op&eacute;randes fournis {1}.\n";
f+="BadDotted=La partie de code suivant l''op&eacute;rateur point ne peut pas &ecirc;tre utilis&eacute;e.\n";
f+="BadParamName=Le nom de param&egrave;tre m&eacute;thode {0} n''est pas valide. Il doit &ecirc;tre un mot.\n";
f+="KeyWordParamName=Le nom de param&egrave;tre m&eacute;thode {0} n''est pas valide. Il ne doit pas &ecirc;tre un mot cl&eacute;.\n";
f+="PrimParamName=Le nom de param&egrave;tre m&eacute;thode {0} n''est pas valide. Il ne doit pas &ecirc;tre un type primitif.\n";
f+="DigitParamName=Le nom de param&egrave;tre m&eacute;thode {0} n''est pas valide. Il ne doit pas commencer par un chiffre.\n";
f+="ReservedParamName=Le nom de param&egrave;tre m&eacute;thode {0} est r&eacute;serv&eacute; pour un indexeur &eacute;criture.\n";
f+="DuplicatedParamName=Le nom de param&egrave;tre fonction {0} est dupliqu&eacute;.\n";
f+="BadReturnTypeInherit=Le type de retour {0} de la m&eacute;thode {1} du type {2} n''est pas sous type du type de retour {3} de la m&eacute;thode {4} du type {5}\n";
f+="BadReturnTypeIndexer=Le type de retour {0} de l''indexer {1} du type {2} n''est pas le type de retour {3} de l''indexer {4} du type {5}\n";
f+="DuplicatedOverriding=Le type {0} h&eacute;rite une fonction {1} qui est dupliqu&eacute;e.\n";
f+="TwoFinal=Le type {0} h&eacute;rite deux fonctions finales de cl&eacute; {1}.\n";
f+="FinalNotSubReturnType=Le type de retour {0} de la m&eacute;thode finale {1} du type {2} n''est pas sous type du type de retour {3} de la m&eacute;thode {4} du type {5}\n";
f+="TwoReturnTypes=Les m&eacute;thodes fusionn&eacute;es avec pour cl&eacute; {0} des types {1} ont pour sous types {2} en tant que types de retour.\n";
f+="ReturnTypes=Les indexeurs avec pour cl&eacute; {0} des types {1} ont pour types {2} en tant que types de retour.\n";
f+="BadVariableName=Le nom de variable {0} n''est pas valide. Il doit &ecirc;tre un mot.\n";
f+="KeyWordVariableName=Le nom de variable {0} n''est pas valide. Il ne doit pas &ecirc;tre un mot cl&eacute;.\n";
f+="PrimVariableName=Le nom de variable {0} n''est pas valide. Il ne doit pas &ecirc;tre un type primitif.\n";
f+="DigitVariableName=Le nom de variable {0} n''est pas valide. Il ne doit pas commencer par un chiffre.\n";
f+="DuplicatedVariableName=Le nom de variable {0} n''est pas valide. Il ne doit pas &ecirc;tre le nom d''une autre variable du scope.\n";
f+="CyclicCtorCall=Les constructeurs {0} du type {1} appartiennent &agrave; des appels cycliques.\n";
f+="DeadCode=Le code est inatteignable dans la fonction {0}\n";
f+="DeadCodeTernary=Une partie du code est inatteignable dans cette op&eacute;ration ternaire.\n";
f+="UnusedParamStatic=Le param&egrave;tre {0} est inutilis&eacute;.\n";
f+="DuplicatedCtor=Le constructeur {0} est dupliqu&eacute;.\n";
f+="DuplicatedGenericSuperTypes=Les super types g&eacute;n&eacute;riques {0} sont dupliqu&eacute;s.\n";
f+="DuplicatedInnerType=Le simple nom du type interne {0} est dupliqu&eacute;.\n";
f+="DuplicatedType=Le nom du type {0} est dupliqu&eacute; avec un autre type client.\n";
f+="DuplicatedTypePrim=Le nom du type {0} est dupliqu&eacute; avec un type primitif.\n";
f+="DuplicatedTypeStd=Le nom du type {0} est dupliqu&eacute; avec un type standard.\n";
f+="DuplicatedTypePkg=Le nom du type {0} est masqu&eacute; par le paquetage {1}.\n";
f+="EmptyExpressionPart=La partie d''expression est vide.\n";
f+="DoWhileNotEmpty=Le bloc {0} associ&eacute; &agrave; un bloc {1} doit &ecirc;tre vide.\n";
f+="DuplicatedFinal=La fonction {0} du type {1} est finale. Donc la red&eacute;finir est interdit.\n";
f+="IllegalCtorEnum=Un constructeur d''une &eacute;num&eacute;ration ne peut pas &ecirc;tre appel&eacute;e explicitement.\n";
f+="IllegalGenericSuperTypeBound=L''argument {0} du super type g&eacute;n&eacute;rique {1} est une borne. Il ne peut pas &ecirc;tre utilis&eacute; dans un super type g&eacute;n&eacute;rique.\n";
f+="IllegalCtorAnnotation=Apr&egrave;s @ le type {0} n''est pas une annotation.\n";
f+="IllegalCtorAbstract=Le type {0} ne peut pas &ecirc;tre instanci&eacute; &eacute;tant donn&eacute; son abstraction.\n";
f+="IllegalCtorBound=L''argument {0} du type {1} est une borne. Il ne peut pas &ecirc;tre utilis&eacute; dans un appel de constructeur.\n";
f+="IllegalCtorArray=Le type {0} is an array type. Il ne peut pas &ecirc;tre utilis&eacute; en tant qu''argument pr&eacute;c&eacute;de d''un point pour instancier.\n";
f+="IllegalCtorUnknown=Le type {0} n''est pas r&eacute;solu pour instancier.\n";
f+="MissingAbrupt=Un bloc {0} ou un bloc {1} est manquant pour la m&eacute;thode {2}.\n";
f+="NotInitClass=Le type {0} n''est pas initialis&eacute;.\n";
f+="NullValue=La valeur ne doit pas &ecirc;tre nulle &agrave; de possibles {0}.\n";
f+="BadParameTypeForId=Le type de param&egrave;tre {0} n''est pas r&eacute;solu pour obtenir l''identit&eacute; d''une fonction.\n";
f+="NotResolvedOwner=Le possesseur pour le type {0} n''est pas r&eacute;solu pour instancier.\n";
f+="UndefinedAccessibleField=Il n''y pas de champ accessible nomm&eacute; {0} depuis le type {1} dans ce contexte.\n";
f+="StaticAccess=Le context est statique. Le mot cl&eacute; {0} ne peut pas &ecirc;tre utilis&eacute; dans ce contexte.\n";
f+="StaticAccessPrev=Un type doit &ecirc;tre utilis&eacute; pour acc&eacute;der au mot cl&eacute; {0}.\n";
f+="UnassignedFinalField=Le champ {0} du type {1} n''est pas assign&eacute; par une constante.\n";
f+="UnassignedInferingType=Le type d''inf&eacute;rence type {0} n''est pas d&eacute;fini pour les variables {1}.\n";
f+="UndefinedCtor=Le constructeur {0} est ind&eacute;fini.\n";
f+="UndefinedMethod=La m&eacute;thode {0} est ind&eacute;finie.\n";
f+="ArrayCloneOnly=Seule la m&eacute;thode {0} peut &ecirc;tre utilis&eacute;e pour le type tableau {1}\n";
f+="UndefinedSuperCtor=Aucun super constructeur &agrave appel implicite n''est defin&eacute; et accessible. Il doit y avoir au moins un constructeur pour le type {0}\n";
f+="UndefinedSuperCtorCall=Aucun super constructeur &agrave appel implicite n''est defin&eacute; et accessible. L''appel explicite d''un super constructeur est obligatoir pour le constructeur {0}.\n";
f+="UndefinedVariable=La variable {0} est ind&eacute;finie dans ce contexte.\n";
f+="UnexpectedAffect=L''op&eacute;rateur d''assignement {0} est inattendu.\n";
f+="FinalField=Le champ {0} est d&eacute;j&agrave; assign&eacute;.\n";
f+="BadOperatorRef=La chaine {0} n''est pas une r&eacute;f&eacute;rence d''op&eacute;rateur.\n";
f+="UnexpectedCatchElseFinally=Le bloc {0} doit &ecirc;tre pr&eacute;c&eacute;d&eacute; par un des blocs {1}.\n";
f+="UnexpectedAbrupt=Le bloc {0} doit &ecirc;tre interne aux blocs {1}.\n";
f+="UnexpectedAbruptLab=Le bloc {0} avec &eacute;tiquette {1} doit &ecirc;tre interne &agrave; un bloc &eacute;tiquet&eacute; avec {2}.\n";
f+="UnexpectedCaseDef=Le bloc {0} avec expression {1} doit &ecirc;tre un enfant d''un bloc {2}.\n";
f+="UnexpectedCaseVar=Le bloc {0} avec expression {1} n''est pas constant.\n";
f+="UnexpectedCaseValue=Le bloc {0} avec valeur {1} n''est pas un sous type de {2}.\n";
f+="UnexpectedCaseDup=Le bloc {0} avec valeur {1} est dupliqu&eacute; in the parent {2} block.\n";
f+="UnexpectedDefDup=Le bloc {0} est dupliqu&eacute; dans le bloc parent {1}.\n";
f+="UnexpectedDoTry=Le bloc {0} doit &ecirc;tre suivi d''un des blocs {1}.\n";
f+="UnexpectedSwitch=Le bloc {0} doit contenir seulement un des blocs {1}.\n";
f+="UnexpectedMemberInst=Le type d''instance {0} doit contenir seulement des types d''instance et des blocs initialisateurs d''instance.\n";
f+="UnexpectedBlockExp=Le bloc est inattendu.\n";
f+="UnexpectedOperandTypes=Les types {0} des op&eacute;randes pour l''op&eacute;rateur {1} sont inattendus.\n";
f+="UnknownType=Le type {0} est inconnu.\n";
f+="EmptyType=Il doit y avoir un type.\n";
f+="BadParamerizedType=Le type {0} n''est pas correctement param&eacute;tr&eacute;.\n";
f+="UnexpectedTypeBound=Le type {0} est inattendu pour une borne.\n";
f+="UnexpectedVararg=Les trois points sont inattendu ici.\n";
f+="UnexpectedLeaf=Le mot cl&eacute; {0} est inattendu ici.\n";
f+="EmptyPart=Il doit y avoir une expression.\n";
return f;
}
static String resourcesLgAliasesFrTypes(){
String f="MIN_VALUE=MIN_VALEUR\n";
f+="MAX_VALUE=MAX_VALEUR\n";
f+="PLUS_INFINITY=PLUS_INFINI\n";
f+="MINUS_INFINITY=MOINS_INFINI\n";
f+="NAN=PUN\n";
f+="CharSequence=$coeur.SequenceCaractere\n";
f+="BadEncode=$coeur.MauvaisEncodage\n";
f+="IllegalArg=$coeur.IllegalArgument\n";
f+="IteratorType=$coeur.Iterateur\n";
f+="EnumParam=$coeur.Enum\n";
f+="GetMessage=valMessage\n";
f+="DivisionZero=$coeur.DivisionZero\n";
f+="IteratorTableTypeVarFirst=T\n";
f+="IteratorTableTypeVarSecond=U\n";
f+="Byte=$coeur.Entier1\n";
f+="Digit=chiffre\n";
f+="ParseInt=parseEntier4\n";
f+="IntValue=valEntier4\n";
f+="IsDigit=estChiffre\n";
f+="Integer=$coeur.Entier4\n";
f+="Compare=compare\n";
f+="StringCompare=compare\n";
f+="IsLetter=estLettre\n";
f+="Long=$coeur.Entier8\n";
f+="PrimLong=entier8\n";
f+="Boolean=$coeur.Booleen\n";
f+="Short=$coeur.Entier2\n";
f+="PrimChar=caractere\n";
f+="Float=$coeur.Flottant\n";
f+="Double=$coeur.Double\n";
f+="Number=$coeur.Nombre\n";
f+="Equals=egal\n";
f+="CharSequenceEquals=egal\n";
f+="Iterator=iterateur\n";
f+="EnumType=$coeur.$en\n";
f+="Iterable=$coeur.Iterable\n";
f+="Enums=$coeur.Enums\n";
f+="Store=$coeur.MauvaisStockage\n";
f+="NullPe=$coeur.ObjetNul\n";
f+="NbFormat=$coeur.MauvaisFormat\n";
f+="BadSize=$coeur.TailleNegative\n";
f+="BadIndex=$coeur.MauvaisIndice\n";
f+="BadArgNumber=$coeur.MauvaisNombreArgs\n";
f+="AbstractTypeErr=$coeur.TypeAbstraitErreur\n";
f+="IllegalType=$coeur.TypeInattendu\n";
f+="NonInvokable=$coeur.NonInvoquable\n";
f+="CastType=$coeur.MauvaisTranstype\n";
f+="Error=$coeur.Erreur\n";
f+="Sof=$coeur.PileTropGrande\n";
f+="Void=vide\n";
f+="PrimByte=entier1\n";
f+="Math=$coeur.Math\n";
f+="GetCause=valCause\n";
f+="Object=$coeur.Objet\n";
f+="FloatValue=valFlottant\n";
f+="IsUpperCase=estMajuscule\n";
f+="ParseFloat=parseFlottant\n";
f+="CharValue=valCaractere\n";
f+="BooleanValue=booleenValue\n";
f+="IsLetterOrDigit=estLettreOuChiffre\n";
f+="ParseShortOrNull=parseEntier2OuNul\n";
f+="LongValue=valEntier8\n";
f+="IsLowerCase=estMinuscule\n";
f+="IsWhitespace=estEspaceBlanc\n";
f+="ParseDouble=parseDouble\n";
f+="DoubleValue=valDouble\n";
f+="IsWordChar=estCaractereMot\n";
f+="ParseLongOrNull=parseEntier8OuNul\n";
f+="IsInfinite=estInfini\n";
f+="ParseShort=parseEntier2\n";
f+="ShortValue=valEntier2\n";
f+="Character=$coeur.Caractere\n";
f+="ParseBoolean=parseBooleen\n";
f+="ParseLong=parseEntier8\n";
f+="MinValueField=MIN_VALEUR\n";
f+="ParseByte=parseEntier1\n";
f+="ParseFloatOrNull=parseFlottantOuNul\n";
f+="ParseIntOrNull=parseEntier4OuNul\n";
f+="ParseDoubleOrNull=parseDoubleOuNul\n";
f+="ByteValue=valEntier1\n";
f+="ParseByteOrNull=parseEntier1OuNul\n";
f+="ValueOfMethod=valeurDe\n";
f+="StringValueOf=valeurDe\n";
f+="StringUtilValueOf=valeurDe\n";
f+="PrimFloat=flottant\n";
f+="CompareTo=comparer\n";
f+="CharSequenceCompareTo=comparer\n";
f+="ToStringMethod=chaine\n";
f+="StackTraceElementToString=chaine\n";
f+="CharSequenceToString=chaine\n";
f+="ErrorToString=chaine\n";
f+="Signum=sgn\n";
f+="Bin=bin\n";
f+="Oct=oct\n";
f+="Hex=hex\n";
f+="PrimBoolean=booleen\n";
f+="PrimShort=entier2\n";
f+="PrimInteger=entier4\n";
f+="PrimDouble=double\n";
f+="Field=$coeur.Champ\n";
f+="HasNext=aSuivant\n";
f+="Next=suivant\n";
f+="Call=appeler\n";
f+="MetaInfo=metaInfo\n";
f+="Instance=instance\n";
f+="NextPair=suivantPair\n";
f+="Same=meme\n";
f+="GetFirst=valPremier\n";
f+="Delete=supprimer\n";
f+="Name=nom\n";
f+="Ordinal=ordinal\n";
f+="Abs=abs\n";
f+="Max=max\n";
f+="Min=min\n";
f+="Mod=mod\n";
f+="PairType=$coeur.Pair\n";
f+="Quot=quot\n";
f+="Clone=clone\n";
f+="Reverse=inverser\n";
f+="Insert=inserer\n";
f+="Clear=vider\n";
f+="Fct=$coeur.Fct\n";
f+="CharAt=car\n";
f+="Format=formatter\n";
f+="Append=ajouter\n";
f+="Capacity=capacite\n";
f+="Length=longueur\n";
f+="ArrayLength=longueur\n";
f+="IsSpace=estEspace\n";
f+="Replace=remplacer\n";
f+="ReplaceString=remplacer\n";
f+="Split=separer\n";
f+="Contains=contient\n";
f+="IsEmpty=estVide\n";
f+="GetType=valType\n";
f+="EndsWith=terminePar\n";
f+="GetBytes=valOctets\n";
f+="IsNan=estNbIndefini\n";
f+="String=$coeur.Chaine\n";
f+="Trim=trimmer\n";
f+="ForDigit=convertir\n";
f+="IndexOf=indiceDe\n";
f+="SubSequence=sousSequence\n";
f+="IterableTable=$coeur.IterableTable\n";
f+="ToLowerCase=versMinuscule\n";
f+="ToLowerCaseChar=versMinuscule\n";
f+="ReplaceMultiple=remplacerMultiple\n";
f+="GetDirectionality=valDirection\n";
f+="LastIndexOf=dernierIndiceDe\n";
f+="ToUpperCase=versMajuscule\n";
f+="ToUpperCaseChar=versMajuscule\n";
f+="GetCharType=valType\n";
f+="SplitStrings=separerChaines\n";
f+="DeleteCharAt=supprimerCaractere\n";
f+="SetCharAt=majCaractere\n";
f+="TrimToSize=trimmerTaille\n";
f+="RegionMatches=correspondRegions\n";
f+="EnsureCapacity=assurerCapacite\n";
f+="IteratorTable=iterateurTable\n";
f+="StartsWith=commencePar\n";
f+="CompareToIgnoreCase=compareIgnorantCasse\n";
f+="EqualsIgnoreCase=egalIgnorantCasse\n";
f+="SplitChars=separerCaracteres\n";
f+="StringBuilder=$coeur.ConstructeurChaine\n";
f+="IteratorTableType=$coeur.IterateurTable\n";
f+="ToCharArray=versTableauCaracter\n";
f+="Substring=sousChaine\n";
f+="SetLength=majLongueur\n";
f+="GetNewString=valChaineApres\n";
f+="ErrorInitClass=$coeur.ErrorDefClasse\n";
f+="GetSecond=valDeuxieme\n";
f+="HasNextPair=aSuivantPair\n";
f+="Replacement=$coeur.Remplacement\n";
f+="GetOldString=valChaineAvant\n";
f+="GetAnnotations=valAnnotations\n";
f+="GetDefaultValue=valDefValeur\n";
f+="GetAnnotationsParameters=valAnnotationsParametrees\n";
f+="Resources=$coeur.Ressources\n";
f+="IteratorTypeVar=T\n";
f+="ReadResources=lireContenu\n";
f+="ReadResourcesIndex=indice\n";
f+="InvokeTarget=$coeur.InvoqueCible\n";
f+="GetGenericVariableOwner=valGeneVariablePoss\n";
f+="ClassType=$coeur.Classe\n";
f+="EnumParamVar=T\n";
f+="GetVariableOwner=valVariablePoss\n";
f+="GetString=valChaine\n";
f+="GetDeclaredExplicits=valExplicitesDeclares\n";
f+="GetDeclaredImplicits=valImplicitesDeclares\n";
f+="GetDeclaredTrueOperators=valOperateursVraiDeclares\n";
f+="GetDeclaredFalseOperators=valOperateursFauxDeclares\n";
f+="GetDeclaredMethods=valMethodsDeclares\n";
f+="GetDeclaredStaticMethods=valMethodsStaticDeclares\n";
f+="IterableVar=T\n";
f+="ClassNotFoundError=$coeur.ClasseNonTrouve\n";
f+="IterableTableVarSecond=U\n";
f+="IterableTableVarFirst=T\n";
f+="PairTypeVarFirst=T\n";
f+="PairTypeVarSecond=U\n";
f+="EnumPredValueOf=valeurDe\n";
f+="EnumValues=valeurs\n";
f+="ReadResourcesNames=lireNoms\n";
f+="ReadResourcesNamesLength=nbNoms\n";
f+="AnnotationType=$coeur.Annotation\n";
f+="Annotated=$coeur.Annote\n";
f+="MakeGeneric=rendreGeneric\n";
f+="GetDeclaredFields=valChampsDeclares\n";
f+="GetDeclaredAnonymousTypes=valTypesAnonymesDeclares\n";
f+="GetDeclaredAnonymousLambda=valLambdaAnonymesDeclares\n";
f+="GetDeclaredAnonymousLambdaLocalVars=valLocalVarsLambdaAnonymesDeclares\n";
f+="GetDeclaredAnonymousLambdaLocalVarsNb=valEnvelVarsLambdaAnonymesDeclaresNb\n";
f+="GetDeclaredAnonymousLambdaLoopVars=valBoucleVarsLambdaAnonymesDeclares\n";
f+="GetDeclaredLocalTypes=valLocalTypesDeclares\n";
f+="GetDeclaredBlocks=valBlocsDeclares\n";
f+="GetDeclaredSwitchMethods=valMethodesSelon\n";
f+="GetOperators=valOperateurs\n";
f+="GetDeclaredConstructors=valConstructeursDeclares\n";
f+="Constructor=$coeur.Constructeur\n";
f+="GetAllClasses=valClasses\n";
f+="SameRef=eq\n";
f+="GetClass=valClasse\n";
f+="ArrayGet=obtenir\n";
f+="GetField=obtenir\n";
f+="IsFinal=estFinal\n";
f+="IsStatic=estStatic\n";
f+="IsStaticCall=estStaticAppel\n";
f+="IsInstanceMethod=estMethInstance\n";
f+="IsClass=estClasse\n";
f+="IsSpeClass=estClasseSpe\n";
f+="IsSpeMuClass=estClasseSpeMu\n";
f+="ArraySet=maj\n";
f+="IsNormal=estNormal\n";
f+="Invoke=invoque\n";
f+="IsPublic=estPublic\n";
f+="GetName=valNom\n";
f+="Init=init\n";
f+="TryWrap=essaiEnvel\n";
f+="ForName=parNom\n";
f+="Method=$coeur.Methode\n";
f+="SetField=maj\n";
f+="IsEnum=estEnum\n";
f+="IsArray=estTableau\n";
f+="Neg=neg\n";
f+="Lt=pq\n";
f+="NegBin=negBin\n";
f+="EnumName=nom\n";
f+="Minus=moins\n";
f+="Gt=gq\n";
f+="Le=pqe\n";
f+="And=et\n";
f+="Ge=gqe\n";
f+="BinQuot=binQuot\n";
f+="Xor=ouExc\n";
f+="Random=alea\n";
f+="NativeRandom=natAlea\n";
f+="SeedGenerator=$coeur.Generateur\n";
f+="SeedDoubleGenerator=$coeur.GenerateurDec\n";
f+="SeedGet=val\n";
f+="Seed=graine\n";
f+="SeedSpecGenerator=graineGenerateur\n";
f+="SeedSpecDoubleGenerator=graineGenerateurDec\n";
f+="Plus=plus\n";
f+="BinMod=binMod\n";
f+="Mult=mult\n";
f+="Or=ou\n";
f+="GetParent=valParent\n";
f+="GetFct=valFct\n";
f+="IsAbstract=estAbstrait\n";
f+="GetGenericSuperClass=valGeneSuperClasse\n";
f+="InvokeDirect=invoqueDirect\n";
f+="MakeArray=rendreTableau\n";
f+="GetParameterTypes=valTypesDeParametres\n";
f+="SetParent=majParent\n";
f+="GetTypeParameters=valTypesParametres\n";
f+="GetParameterNames=valGeneTypesParametres\n";
f+="GetReturnType=valTypeRetour\n";
f+="NewInstance=nouvelleInstance\n";
f+="GetFileName=valNomFichier\n";
f+="GetUpperBounds=valSuperTypesContraintes\n";
f+="GetEnclosingType=valTypeContenant\n";
f+="GetDeclaredClasses=valClassesDeclarees\n";
f+="GetSuperClass=valSuperClasse\n";
f+="GetLowerBounds=valSousTypesContraintes\n";
f+="GetPrettyName=valJoliNom\n";
f+="GetPrettySingleName=valJoliSimpleNom\n";
f+="GetComponentType=valTypeComposent\n";
f+="Range=$coeur.Rang\n";
f+="RangeLower=inf\n";
f+="RangeUpper=sup\n";
f+="RangeUnlimited=illimite\n";
f+="RangeUnlimitedStep=illimitePas\n";
f+="ObjectsUtil=$coeur.ObjetsUtil\n";
f+="GetGenericReturnType=valGeneTypeRetour\n";
f+="GetInterfaces=valInterfaces\n";
f+="GetGenericInterfaces=valGeneInterfaces\n";
f+="StringUtil=$coeur.ChaineUtil\n";
f+="IsTypeVariable=estTypeVariable\n";
f+="IsVarargs=estVarargs\n";
f+="IsPrivate=estPrive\n";
f+="IsAnnotation=estAnnotation\n";
f+="EnumValueOf=enumValeurDe\n";
f+="IsPrimitive=estPrimitif\n";
f+="GetBounds=valContraintes\n";
f+="GetDeclaringClass=valClasseDeclarante\n";
f+="GetActualTypeArguments=valCourantArgTypes\n";
f+="ShiftLeft=glisserGauche\n";
f+="ArrayGetLength=valLongeur\n";
f+="GetGenericType=valGeneType\n";
f+="IsPackage=estPaquetage\n";
f+="IsProtected=estProtege\n";
f+="MakeWildCard=rendreSynthetique\n";
f+="MakeRefType=rendreTypeRef\n";
f+="IsVariable=estVariable\n";
f+="IsInstance=estInstance\n";
f+="GetEnumConstants=valEnumConst\n";
f+="IsAssignableFrom=estAssignableDe\n";
f+="ArrayNewInstance=nouvelleInstanceTableau\n";
f+="IsWildCard=estSynthetique\n";
f+="IsRefType=estTypeRef\n";
f+="IsInterface=estInterface\n";
f+="GetGenericBounds=valGeneContraintes\n";
f+="DefaultInstance=instanceParDefaut\n";
f+="CurrentFullStack=couranteComplete\n";
f+="ShiftRight=glisserDroite\n";
f+="EnumOrdinal=ordinal\n";
f+="BitShiftLeft=binGlisserGauche\n";
f+="BitShiftRight=binGlisserDroite\n";
f+="CurrentStack=courante\n";
f+="ErrorCurrentStack=courante\n";
f+="RotateRight=rotDroite\n";
f+="StackTraceElement=$coeur.Pile\n";
f+="RotateLeft=rotGauche\n";
f+="IllegalThreadStateException=$coeur.IllegalEtatTache\n";
f+="InfoTestCount=nb\n";
f+="AssertAssertTrue=assertVrai\n";
f+="AssertAssertFalse=assertFaux\n";
f+="InfoTestCurrentMethod=methodCourante\n";
f+="DifferenceFoundNull=trouveNull\n";
f+="ConcurrentError=$coeur.ErreurConcurrentielle\n";
f+="ExecuteSetupNoException=majSansException\n";
f+="AssertAssert=assert\n";
f+="AssertAssertNull=assertNul\n";
f+="InfoTestCurrentClass=classeCourante\n";
f+="InfoTestCurrentParams=paramsCourants\n";
f+="ExecuteConvert=convertier\n";
f+="DifferenceExpected=attendu\n";
f+="AssertAssertNotNull=assertNonNul\n";
f+="DifferenceFoundNotTrue=trouvePasVrai\n";
f+="InfoTestDone=fait\n";
f+="ExecuteSetupError=majErreur\n";
f+="AssertAssertSame=assertMeme\n";
f+="DifferenceFound=trouve\n";
f+="DifferenceStackDiff=pileDiff\n";
f+="IsHeldByCurrentThread=estActiveeParTacheCourante\n";
f+="FileGetName=nom\n";
f+="FileAbsolutePath=absolu\n";
f+="SetPriority=majPriorite\n";
f+="AtomicInteger=$coeur.AtomicEntier4\n";
f+="AppendToFile=ajouterFinFichier\n";
f+="FileGetLength=lg\n";
f+="ThreadExitHook=sortieIntercept\n";
f+="AtomicBoolean=$coeur.AtomicBooleen\n";
f+="AtomicLong=$coeur.AtomicEntier8\n";
f+="ReentrantLock=$coeur.Verrou\n";
f+="FormatType=$coeur.Formattage\n";
f+="GetAtomic=valeur\n";
f+="CurrentThread=tacheCourante\n";
f+="ThreadCurrentTime=instant\n";
f+="ThreadCurrentNanoTime=instantNanos\n";
f+="FileIsDirectory=estDossier\n";
f+="FileIsFile=estFichier\n";
f+="FileRoots=racines\n";
f+="FileGetParentPath=chParent\n";
f+="JoinOthers=attendreAutres\n";
f+="SetAtomic=majValeur\n";
f+="CompareAndSetAtomic=compareEtMaj\n";
f+="LazySetAtomic=tardMaj\n";
f+="AddAndGetAtomic=ajEtObt\n";
f+="GetAndAddAtomic=obtEtAj\n";
f+="IncrementAndGetAtomic=incrEtObt\n";
f+="GetAndIncrementAtomic=obtEtIncr\n";
f+="DecrementAndGetAtomic=decrEtObt\n";
f+="GetAndDecrementAtomic=obtEtDecr\n";
f+="GetAndSetAtomic=obtEtMaj\n";
f+="GetPriority=valPriorite\n";
f+="FileListFiles=fichiers\n";
f+="CustIterator=$coeur.CustIterateur\n";
f+="GetFirstTa=valPremier\n";
f+="Parameters=$coeur.Parametres\n";
f+="TableVarFirst=T\n";
f+="ListClear=toutSuppr\n";
f+="IndexItrTa=indice\n";
f+="IterTaVarFirst=T\n";
f+="TestException=exception\n";
f+="TestNullException=nulleException\n";
f+="ExecutedTestAnnotations=annotations\n";
f+="FileMakeDirs=acheminerDossiers\n";
f+="ExecutedTest=$coeur.TestExecute\n";
f+="LengthItrTa=longueur\n";
f+="Difference=$coeur.Difference\n";
f+="EltDifference=$coeur.EltDifference\n";
f+="Index=indice\n";
f+="AssertNot=assertNon\n";
f+="AssertNotSame=assertNonMeme\n";
f+="ExecutedTestTest=test\n";
f+="TableVarSecond=U\n";
f+="ExecutedTestBefore=avant\n";
f+="IndexItrLi=indice\n";
f+="GetSecondTa=valDeuxieme\n";
f+="SetFirstTa=majPremier\n";
f+="FileListDirectories=dossiers\n";
f+="SetSecond=majDeuxieme\n";
f+="CustIterTable=$coeur.CustIterateurTable\n";
f+="LengthItrLi=longueur\n";
f+="SetSecondTa=majDeuxieme\n";
f+="PairVarFirst=T\n";
f+="FileLastModif=derModification\n";
f+="PairVarSecond=U\n";
f+="ListIterTable=liste\n";
f+="IterTaVarSecond=U\n";
f+="CustIteratorVar=T\n";
f+="ExecutedTestAfter=apres\n";
f+="ExecuteExecute=executer\n";
f+="ExecutedTestMethod=methode\n";
f+="ParametersMethod=methode\n";
f+="ResultTime=duree\n";
f+="ResultSuccess=succes\n";
f+="ResultParams=params\n";
f+="ParametersLocation=location\n";
f+="ExecuteTests=tests\n";
f+="ResultFailMessage=messageErreur\n";
f+="Runnable=$coeur.Executable\n";
f+="ThreadEq=tEq\n";
f+="Start=demarrer\n";
f+="Thread=$coeur.Tache\n";
f+="ThreadSet=$coeur.EnsTache\n";
f+="ThreadSetAll=tous\n";
f+="ThreadSetAdd=ajout\n";
f+="ThreadSetContains=contient\n";
f+="ThreadSetRemove=suppr\n";
f+="ThreadSetSnapshot=tab\n";
f+="Run=executer\n";
f+="Yield=declencher\n";
f+="Lock=verrouiller\n";
f+="SetFirst=majPremier\n";
f+="Unlock=deverrouiller\n";
f+="ListItr=liste\n";
f+="Write=ecrire\n";
f+="File=$coeur.Fichier\n";
f+="RemoveLi=supprimer\n";
f+="Print=afficher\n";
f+="List=$coeur.Liste\n";
f+="CustPair=$coeur.PaireImpl\n";
f+="Second=deuxieme\n";
f+="ArrayLi=tableau\n";
f+="IsAlive=estActif\n";
f+="IsEnded=estFini\n";
f+="End=finir\n";
f+="ListVar=T\n";
f+="Sleep=dormir\n";
f+="Join=attendre\n";
f+="First=premier\n";
f+="SizeLi=taille\n";
f+="Table=$coeur.Table\n";
f+="AddLi=ajouter\n";
f+="LengthLi=longueur\n";
f+="Read=lire\n";
f+="GetId=valId\n";
f+="Test=$coeur.Test\n";
f+="InfoTest=$coeur.InfoTest\n";
f+="Before=$coeur.Avant\n";
f+="AddTa=ajouter\n";
f+="After=$coeur.Apres\n";
f+="Assert=$coeur.Assertion\n";
f+="Result=$coeur.Resultat\n";
f+="ListTa=liste\n";
f+="RemoveTa=supprimer\n";
f+="SizeTa=taille\n";
f+="Execute=$coeur.Executer\n";
f+="GetTa=val\n";
f+="FileZippedBin=archiveBin\n";
f+="FileZippedBinArray=archiveBinTab\n";
f+="FileZippedText=archiveTexte\n";
f+="FileZipBin=archBin\n";
f+="FileZipBinArray=archBinTab\n";
f+="FileZipText=archTexte\n";
f+="TableStringObject=$coeur.TableChaineObjet\n";
f+="TableConcEmpty=vi\n";
f+="TableConcSize=taille\n";
f+="TableConcKeys=cles\n";
f+="TableConcValues=valeurs\n";
f+="TableConcHasKey=aCle\n";
f+="TableConcHasValue=aValeur\n";
f+="TableConcPairs=paires\n";
f+="TableConcPut=mettre\n";
f+="TableConcPutAbs=mettreAbs\n";
f+="TableConcGet=val\n";
f+="TableConcRemove=suppr\n";
f+="TableConcReplace=remplacer\n";
f+="TableConcClear=vider\n";
f+="TableConcPutAll=mettreTout\n";
f+="EntryStringObject=$coeur.EltChaineObjet\n";
f+="TableEntryKey=cle\n";
f+="TableEntryValue=valeur\n";
f+="TableEntryOwner=poss\n";
f+="EntryBinary=$coeur.EltArchBinaire\n";
f+="EntryText=$coeur.EltArchTexte\n";
f+="EntryName=nom\n";
f+="EntryValue=valeur\n";
f+="EntryTime=temps\n";
f+="FileIsAbsolute=estAbsolu\n";
f+="FileReadBin=lireBin\n";
f+="FileWriteBin=ecrireBin\n";
f+="FileDelete=suppr\n";
f+="FileRename=renommer\n";
f+="FileDir=dos\n";
f+="Eval=eval\n";
f+="DefaultPkg=$coeur\n";
f+="FalseString=faux\n";
f+="TrueString=vrai\n";
f+="Infinity=Infini\n";
f+="Nan=Pun\n";
f+="Exponent=E\n";
f+="NullString=\n";
f+="NullCoverString=nul\n";
f+="NotNullCoverString=non nul\n";
f+="StaticString=static\n";
f+="StaticCallString=staticAppel\n";
f+="SeedGenerator0Get0=a\n";
f+="CharSequence0SubSequence0=a\n";
f+="CharSequence0SubSequence1=b\n";
f+="CharSequence0CharAt0=a\n";
f+="CharSequence0Substring0=a\n";
f+="CharSequence0Substring1=b\n";
f+="CharSequence1Substring0=a\n";
f+="CharSequence0CompareTo0=a\n";
f+="CharSequence0Contains0=a\n";
f+="CharSequence0StartsWith0=a\n";
f+="CharSequence1StartsWith0=a\n";
f+="CharSequence1StartsWith1=b\n";
f+="CharSequence0EndsWith0=a\n";
f+="CharSequence0IndexOf0=a\n";
f+="CharSequence1IndexOf0=a\n";
f+="CharSequence1IndexOf1=b\n";
f+="CharSequence2IndexOf0=a\n";
f+="CharSequence3IndexOf0=a\n";
f+="CharSequence3IndexOf1=b\n";
f+="CharSequence0LastIndexOf0=a\n";
f+="CharSequence1LastIndexOf0=a\n";
f+="CharSequence1LastIndexOf1=b\n";
f+="CharSequence2LastIndexOf0=a\n";
f+="CharSequence3LastIndexOf0=a\n";
f+="CharSequence3LastIndexOf1=b\n";
f+="CharSequence0Format0=a\n";
f+="CharSequence0Split0=a\n";
f+="CharSequence1Split0=a\n";
f+="CharSequence1Split1=b\n";
f+="CharSequence2Split0=a\n";
f+="CharSequence3Split0=a\n";
f+="CharSequence3Split1=b\n";
f+="CharSequence0SplitStrings0=a\n";
f+="CharSequence1SplitStrings0=a\n";
f+="CharSequence1SplitStrings1=b\n";
f+="CharSequence0SplitChars0=a\n";
f+="CharSequence0RegionMatches0=a\n";
f+="CharSequence0RegionMatches1=b\n";
f+="CharSequence0RegionMatches2=c\n";
f+="CharSequence0RegionMatches3=d\n";
f+="CharSequence0Equals0=a\n";
f+="CharSequence0Equals1=b\n";
f+="String0EqualsIgnoreCase0=a\n";
f+="String0Compare0=a\n";
f+="String0Compare1=b\n";
f+="String0CompareToIgnoreCase0=a\n";
f+="String0ReplaceString0=a\n";
f+="String0ReplaceString1=b\n";
f+="String1ReplaceString0=a\n";
f+="String1ReplaceString1=b\n";
f+="String0ReplaceMultiple0=a\n";
f+="String0RegionMatches0=a\n";
f+="String0RegionMatches1=b\n";
f+="String0RegionMatches2=c\n";
f+="String0RegionMatches3=d\n";
f+="String0RegionMatches4=e\n";
f+="String0ValueOfMethod0=a\n";
f+="String1ValueOfMethod0=a\n";
f+="String2ValueOfMethod0=a\n";
f+="String3ValueOfMethod0=a\n";
f+="String4ValueOfMethod0=a\n";
f+="String5ValueOfMethod0=a\n";
f+="String6ValueOfMethod0=a\n";
f+="String7ValueOfMethod0=a\n";
f+="String8ValueOfMethod0=a\n";
f+="String9ValueOfMethod0=a\n";
f+="String9ValueOfMethod1=b\n";
f+="String9ValueOfMethod2=c\n";
f+="String0String0=a\n";
f+="String1String0=a\n";
f+="String1String1=b\n";
f+="String1String2=c\n";
f+="String2String0=a\n";
f+="String3String0=a\n";
f+="String3String1=b\n";
f+="String3String2=c\n";
f+="String4String0=a\n";
f+="StringBuilder0Append0=a\n";
f+="StringBuilder1Append0=a\n";
f+="StringBuilder2Append0=a\n";
f+="StringBuilder3Append0=a\n";
f+="StringBuilder4Append0=a\n";
f+="StringBuilder5Append0=a\n";
f+="StringBuilder6Append0=a\n";
f+="StringBuilder7Append0=a\n";
f+="StringBuilder8Append0=a\n";
f+="StringBuilder9Append0=a\n";
f+="StringBuilder9Append1=b\n";
f+="StringBuilder9Append2=c\n";
f+="StringBuilder10Append0=a\n";
f+="StringBuilder11Append0=a\n";
f+="StringBuilder11Append1=b\n";
f+="StringBuilder11Append2=c\n";
f+="StringBuilder12Append0=a\n";
f+="StringBuilder13Append0=a\n";
f+="StringBuilder13Append1=b\n";
f+="StringBuilder13Append2=c\n";
f+="StringBuilder0Delete0=a\n";
f+="StringBuilder0Delete1=b\n";
f+="StringBuilder0DeleteCharAt0=a\n";
f+="StringBuilder0Insert0=a\n";
f+="StringBuilder0Insert1=b\n";
f+="StringBuilder1Insert0=a\n";
f+="StringBuilder1Insert1=b\n";
f+="StringBuilder2Insert0=a\n";
f+="StringBuilder2Insert1=b\n";
f+="StringBuilder3Insert0=a\n";
f+="StringBuilder3Insert1=b\n";
f+="StringBuilder4Insert0=a\n";
f+="StringBuilder4Insert1=b\n";
f+="StringBuilder5Insert0=a\n";
f+="StringBuilder5Insert1=b\n";
f+="StringBuilder6Insert0=a\n";
f+="StringBuilder6Insert1=b\n";
f+="StringBuilder7Insert0=a\n";
f+="StringBuilder7Insert1=b\n";
f+="StringBuilder8Insert0=a\n";
f+="StringBuilder8Insert1=b\n";
f+="StringBuilder9Insert0=a\n";
f+="StringBuilder9Insert1=b\n";
f+="StringBuilder9Insert2=c\n";
f+="StringBuilder9Insert3=d\n";
f+="StringBuilder10Insert0=a\n";
f+="StringBuilder10Insert1=b\n";
f+="StringBuilder11Insert0=a\n";
f+="StringBuilder11Insert1=b\n";
f+="StringBuilder11Insert2=c\n";
f+="StringBuilder11Insert3=d\n";
f+="StringBuilder12Insert0=a\n";
f+="StringBuilder12Insert1=b\n";
f+="StringBuilder13Insert0=a\n";
f+="StringBuilder13Insert1=b\n";
f+="StringBuilder13Insert2=c\n";
f+="StringBuilder13Insert3=d\n";
f+="StringBuilder0Replace0=a\n";
f+="StringBuilder0Replace1=b\n";
f+="StringBuilder0Replace2=c\n";
f+="StringBuilder0SetCharAt0=a\n";
f+="StringBuilder0SetCharAt1=b\n";
f+="StringBuilder0SetLength0=a\n";
f+="StringBuilder0EnsureCapacity0=a\n";
f+="StringBuilder0Same0=a\n";
f+="StringBuilder0Same1=b\n";
f+="StringBuilder0StringBuilder0=a\n";
f+="StringBuilder1StringBuilder0=a\n";
f+="StringBuilder2StringBuilder0=a\n";
f+="Replacement0Replacement0=a\n";
f+="Replacement0Replacement1=b\n";
f+="Error0CurrentStack0=a\n";
f+="Error0ToStringMethod0=a\n";
f+="Enums0Name0=a\n";
f+="Enums0Ordinal0=a\n";
f+="Range0Range0=a\n";
f+="Range0Range1=b\n";
f+="Range0UnlimitedStep0=a\n";
f+="Range0UnlimitedStep1=b\n";
f+="Range1Range0=a\n";
f+="Range2Range0=a\n";
f+="Range2Range1=b\n";
f+="Range2Range2=c\n";
f+="ObjectsUtil0SameRef0=a\n";
f+="ObjectsUtil0SameRef1=b\n";
f+="ObjectsUtil0GetParent0=a\n";
f+="ObjectsUtil0SetParent0=a\n";
f+="ObjectsUtil0SetParent1=b\n";
f+="ObjectsUtil0GetFct0=a\n";
f+="StringUtil0ValueOfMethod0=a\n";
f+="Resources0ReadResources0=a\n";
f+="Resources0ReadResourcesIndex0=a\n";
f+="Math0Abs0=a\n";
f+="Math1Abs0=a\n";
f+="Math2Abs0=a\n";
f+="Math3Abs0=a\n";
f+="Math0Max0=a\n";
f+="Math0Max1=b\n";
f+="Math1Max0=a\n";
f+="Math1Max1=b\n";
f+="Math0Min0=a\n";
f+="Math0Min1=b\n";
f+="Math1Min0=a\n";
f+="Math1Min1=b\n";
f+="Math2Max0=a\n";
f+="Math2Max1=b\n";
f+="Math3Max0=a\n";
f+="Math3Max1=b\n";
f+="Math2Min0=a\n";
f+="Math2Min1=b\n";
f+="Math3Min0=a\n";
f+="Math3Min1=b\n";
f+="Math0Quot0=a\n";
f+="Math0Quot1=b\n";
f+="Math1Quot0=a\n";
f+="Math1Quot1=b\n";
f+="Math0Mod0=a\n";
f+="Math0Mod1=b\n";
f+="Math1Mod0=a\n";
f+="Math1Mod1=b\n";
f+="Math0Plus0=a\n";
f+="Math1Plus0=a\n";
f+="Math2Plus0=a\n";
f+="Math3Plus0=a\n";
f+="Math0Minus0=a\n";
f+="Math1Minus0=a\n";
f+="Math2Minus0=a\n";
f+="Math3Minus0=a\n";
f+="Math0Neg0=a\n";
f+="Math0NegBin0=a\n";
f+="Math1NegBin0=a\n";
f+="Math4Plus0=a\n";
f+="Math4Plus1=b\n";
f+="Math5Plus0=a\n";
f+="Math5Plus1=b\n";
f+="Math6Plus0=a\n";
f+="Math6Plus1=b\n";
f+="Math7Plus0=a\n";
f+="Math7Plus1=b\n";
f+="Math4Minus0=a\n";
f+="Math4Minus1=b\n";
f+="Math5Minus0=a\n";
f+="Math5Minus1=b\n";
f+="Math6Minus0=a\n";
f+="Math6Minus1=b\n";
f+="Math7Minus0=a\n";
f+="Math7Minus1=b\n";
f+="Math0Mult0=a\n";
f+="Math0Mult1=b\n";
f+="Math1Mult0=a\n";
f+="Math1Mult1=b\n";
f+="Math2Mult0=a\n";
f+="Math2Mult1=b\n";
f+="Math3Mult0=a\n";
f+="Math3Mult1=b\n";
f+="Math0BinQuot0=a\n";
f+="Math0BinQuot1=b\n";
f+="Math1BinQuot0=a\n";
f+="Math1BinQuot1=b\n";
f+="Math2BinQuot0=a\n";
f+="Math2BinQuot1=b\n";
f+="Math3BinQuot0=a\n";
f+="Math3BinQuot1=b\n";
f+="Math0BinMod0=a\n";
f+="Math0BinMod1=b\n";
f+="Math1BinMod0=a\n";
f+="Math1BinMod1=b\n";
f+="Math2BinMod0=a\n";
f+="Math2BinMod1=b\n";
f+="Math3BinMod0=a\n";
f+="Math3BinMod1=b\n";
f+="Math0And0=a\n";
f+="Math0And1=b\n";
f+="Math1And0=a\n";
f+="Math1And1=b\n";
f+="Math2And0=a\n";
f+="Math2And1=b\n";
f+="Math0Or0=a\n";
f+="Math0Or1=b\n";
f+="Math1Or0=a\n";
f+="Math1Or1=b\n";
f+="Math2Or0=a\n";
f+="Math2Or1=b\n";
f+="Math0Xor0=a\n";
f+="Math0Xor1=b\n";
f+="Math1Xor0=a\n";
f+="Math1Xor1=b\n";
f+="Math2Xor0=a\n";
f+="Math2Xor1=b\n";
f+="Math0ShiftLeft0=a\n";
f+="Math0ShiftLeft1=b\n";
f+="Math1ShiftLeft0=a\n";
f+="Math1ShiftLeft1=b\n";
f+="Math0ShiftRight0=a\n";
f+="Math0ShiftRight1=b\n";
f+="Math1ShiftRight0=a\n";
f+="Math1ShiftRight1=b\n";
f+="Math0BitShiftLeft0=a\n";
f+="Math0BitShiftLeft1=b\n";
f+="Math1BitShiftLeft0=a\n";
f+="Math1BitShiftLeft1=b\n";
f+="Math0BitShiftRight0=a\n";
f+="Math0BitShiftRight1=b\n";
f+="Math1BitShiftRight0=a\n";
f+="Math1BitShiftRight1=b\n";
f+="Math0RotateLeft0=a\n";
f+="Math0RotateLeft1=b\n";
f+="Math1RotateLeft0=a\n";
f+="Math1RotateLeft1=b\n";
f+="Math0RotateRight0=a\n";
f+="Math0RotateRight1=b\n";
f+="Math1RotateRight0=a\n";
f+="Math1RotateRight1=b\n";
f+="Math0Le0=a\n";
f+="Math0Le1=b\n";
f+="Math0Ge0=a\n";
f+="Math0Ge1=b\n";
f+="Math0Lt0=a\n";
f+="Math0Lt1=b\n";
f+="Math0Gt0=a\n";
f+="Math0Gt1=b\n";
f+="Math1Le0=a\n";
f+="Math1Le1=b\n";
f+="Math1Ge0=a\n";
f+="Math1Ge1=b\n";
f+="Math1Lt0=a\n";
f+="Math1Lt1=b\n";
f+="Math1Gt0=a\n";
f+="Math1Gt1=b\n";
f+="Math0Random0=a\n";
f+="Math0NativeRandom0=a\n";
f+="Math0Seed0=a\n";
f+="Math0SeedSpecGenerator0=a\n";
f+="Math0SeedSpecDoubleGenerator0=a\n";
f+="Byte0ToBinString0=a\n";
f+="Byte0ToOctString0=a\n";
f+="Byte0ToHexString0=a\n";
f+="Short0ToBinString0=a\n";
f+="Short0ToOctString0=a\n";
f+="Short0ToHexString0=a\n";
f+="Integer0ToBinString0=a\n";
f+="Integer0ToOctString0=a\n";
f+="Integer0ToHexString0=a\n";
f+="Long0ToBinString0=a\n";
f+="Long0ToOctString0=a\n";
f+="Long0ToHexString0=a\n";
f+="Boolean0Compare0=a\n";
f+="Boolean0Compare1=b\n";
f+="Boolean0CompareTo0=a\n";
f+="Boolean0Equals0=a\n";
f+="Boolean0ParseBoolean0=a\n";
f+="Boolean0ToStringMethod0=a\n";
f+="Boolean0ValueOfMethod0=a\n";
f+="Boolean1ValueOfMethod0=a\n";
f+="Boolean0Boolean0=a\n";
f+="Boolean1Boolean0=a\n";
f+="Byte0ToStringMethod0=a\n";
f+="Byte0ParseByte0=a\n";
f+="Byte1ParseByte0=a\n";
f+="Byte1ParseByte1=b\n";
f+="Byte0CompareTo0=a\n";
f+="Byte0Compare0=a\n";
f+="Byte0Compare1=b\n";
f+="Byte0ParseByteOrNull0=a\n";
f+="Byte1ParseByteOrNull0=a\n";
f+="Byte1ParseByteOrNull1=b\n";
f+="Byte0Byte0=a\n";
f+="Byte1Byte0=a\n";
f+="Short0ToStringMethod0=a\n";
f+="Short0ParseShort0=a\n";
f+="Short1ParseShort0=a\n";
f+="Short1ParseShort1=b\n";
f+="Short0CompareTo0=a\n";
f+="Short0Compare0=a\n";
f+="Short0Compare1=b\n";
f+="Short0ParseShortOrNull0=a\n";
f+="Short1ParseShortOrNull0=a\n";
f+="Short1ParseShortOrNull1=b\n";
f+="Short0Short0=a\n";
f+="Short1Short0=a\n";
f+="Integer0ToStringMethod0=a\n";
f+="Integer0ParseInt0=a\n";
f+="Integer1ParseInt0=a\n";
f+="Integer1ParseInt1=b\n";
f+="Integer0CompareTo0=a\n";
f+="Integer0Compare0=a\n";
f+="Integer0Compare1=b\n";
f+="Integer0ParseIntOrNull0=a\n";
f+="Integer1ParseIntOrNull0=a\n";
f+="Integer1ParseIntOrNull1=b\n";
f+="Integer0Integer0=a\n";
f+="Integer1Integer0=a\n";
f+="Long0ToStringMethod0=a\n";
f+="Long1ToStringMethod0=a\n";
f+="Long1ToStringMethod1=b\n";
f+="Long0Signum0=a\n";
f+="Long0ParseLong0=a\n";
f+="Long1ParseLong0=a\n";
f+="Long1ParseLong1=b\n";
f+="Long0CompareTo0=a\n";
f+="Long0Compare0=a\n";
f+="Long0Compare1=b\n";
f+="Long0ParseLongOrNull0=a\n";
f+="Long1ParseLongOrNull0=a\n";
f+="Long1ParseLongOrNull1=b\n";
f+="Long0Long0=a\n";
f+="Long1Long0=a\n";
f+="Float0ToStringMethod0=a\n";
f+="Float0ParseFloat0=a\n";
f+="Float0CompareTo0=a\n";
f+="Float0Compare0=a\n";
f+="Float0Compare1=b\n";
f+="Float0ParseFloatOrNull0=a\n";
f+="Float0IsInfinite0=a\n";
f+="Float0IsNan0=a\n";
f+="Float0Float0=a\n";
f+="Float1Float0=a\n";
f+="Double0ToStringMethod0=a\n";
f+="Double0ParseDouble0=a\n";
f+="Double0CompareTo0=a\n";
f+="Double0Compare0=a\n";
f+="Double0Compare1=b\n";
f+="Double0ParseDoubleOrNull0=a\n";
f+="Double0IsInfinite0=a\n";
f+="Double0IsNan0=a\n";
f+="Double0Double0=a\n";
f+="Double1Double0=a\n";
f+="Number0ToStringMethod0=a\n";
f+="Number0Equals0=a\n";
f+="Number1Equals0=a\n";
f+="Number1Equals1=b\n";
f+="Number0CompareTo0=a\n";
f+="Number0Compare0=a\n";
f+="Number0Compare1=b\n";
f+="Character0CompareTo0=a\n";
f+="Character0Compare0=a\n";
f+="Character0Compare1=b\n";
f+="Character0Digit0=a\n";
f+="Character0Digit1=b\n";
f+="Character0ForDigit0=a\n";
f+="Character0ForDigit1=b\n";
f+="Character0GetDirectionality0=a\n";
f+="Character0GetType0=a\n";
f+="Character0IsDigit0=a\n";
f+="Character0IsLetter0=a\n";
f+="Character0IsLetterOrDigit0=a\n";
f+="Character0IsWordChar0=a\n";
f+="Character0IsWhitespace0=a\n";
f+="Character0IsLowerCase0=a\n";
f+="Character0IsUpperCase0=a\n";
f+="Character0IsSpace0=a\n";
f+="Character0ToLowerCaseChar0=a\n";
f+="Character0ToUpperCaseChar0=a\n";
f+="Character0ToStringMethod0=a\n";
f+="Character0Character0=a\n";
f+="Fct0Call0=a\n";
f+="ClassType0GetClass0=a\n";
f+="ClassType0ForName0=a\n";
f+="ClassType0ForName1=b\n";
f+="ClassType1ForName0=a\n";
f+="ClassType0IsInstance0=a\n";
f+="ClassType0IsAssignableFrom0=a\n";
f+="ClassType0DefaultInstance0=a\n";
f+="ClassType0EnumValueOf0=a\n";
f+="ClassType0GetDeclaredConstructors0=a\n";
f+="ClassType0GetDeclaredConstructors1=b\n";
f+="ClassType0GetDeclaredFields0=a\n";
f+="ClassType0GetDeclaredStaticMethods0=a\n";
f+="ClassType0GetDeclaredStaticMethods1=b\n";
f+="ClassType0GetDeclaredStaticMethods2=c\n";
f+="ClassType0GetDeclaredStaticMethods3=d\n";
f+="ClassType0GetDeclaredMethods0=a\n";
f+="ClassType0GetDeclaredMethods1=b\n";
f+="ClassType0GetDeclaredMethods2=c\n";
f+="ClassType0GetDeclaredMethods3=d\n";
f+="ClassType0GetDeclaredExplicits0=a\n";
f+="ClassType0GetDeclaredImplicits0=a\n";
f+="ClassType0GetDeclaredBlocks0=a\n";
f+="ClassType0GetDeclaredBlocks1=b\n";
f+="ClassType0MakeGeneric0=a\n";
f+="ClassType0MakeWildCard0=a\n";
f+="ClassType0MakeRef0=a\n";
f+="ClassType0GetOperators0=a\n";
f+="ClassType0GetOperators1=b\n";
f+="ClassType0GetOperators2=c\n";
f+="ClassType0ArrayNewInstance0=a\n";
f+="ClassType0ArrayGetLength0=a\n";
f+="ClassType0ArrayGet0=a\n";
f+="ClassType0ArrayGet1=b\n";
f+="ClassType0ArraySet0=a\n";
f+="ClassType0ArraySet1=b\n";
f+="ClassType0ArraySet2=c\n";
f+="ClassType0TryWrap0=a\n";
f+="Constructor0NewInstance0=a\n";
f+="Field0GetField0=a\n";
f+="Field0SetField0=a\n";
f+="Field0SetField1=b\n";
f+="Method0Invoke0=a\n";
f+="Method0Invoke1=b\n";
f+="Method0InvokeDirect0=a\n";
f+="Method0InvokeDirect1=b\n";
f+="Method0GetDeclaredAnonymousLambdaLocalVarsNb0=a\n";
f+="Method0GetDeclaredAnonymousLambdaLocalVars0=a\n";
f+="Method0GetDeclaredAnonymousLambdaLocalVars1=b\n";
f+="Method0GetDeclaredAnonymousLambdaLocalVars2=c\n";
f+="Method1GetDeclaredAnonymousLambdaLocalVars0=a\n";
f+="Method1GetDeclaredAnonymousLambdaLocalVars1=b\n";
f+="Method2GetDeclaredAnonymousLambdaLocalVars0=a\n";
f+="Method2GetDeclaredAnonymousLambdaLocalVars1=b\n";
f+="Method3GetDeclaredAnonymousLambdaLocalVars0=a\n";
f+="Method0GetDeclaredAnonymousLambdaLoopVars0=a\n";
f+="Method0GetDeclaredAnonymousLambdaLoopVars1=b\n";
f+="Method0GetDeclaredAnonymousLambdaLoopVars2=c\n";
f+="Method1GetDeclaredAnonymousLambdaLoopVars0=a\n";
f+="Method1GetDeclaredAnonymousLambdaLoopVars1=b\n";
f+="Method2GetDeclaredAnonymousLambdaLoopVars0=a\n";
f+="Method2GetDeclaredAnonymousLambdaLoopVars1=b\n";
f+="Method3GetDeclaredAnonymousLambdaLoopVars0=a\n";
f+="AnnotationType0GetString0=a\n";
f+="Annotated0GetAnnotations0=a\n";
f+="Annotated0GetAnnotationsParameters0=a\n";
f+="Annotated0GetDeclaredAnonymousLambda0=a\n";
f+="Annotated0GetDeclaredAnonymousLambda1=b\n";
f+="Annotated0GetDeclaredAnonymousLambda2=c\n";
f+="Annotated0GetDeclaredAnonymousLambda3=d\n";
f+="Annotated0GetDeclaredSwitchMethods0=a\n";
f+="Annotated0GetDeclaredSwitchMethods1=b\n";
f+="Annotated0GetDeclaredSwitchMethods2=c\n";
f+="Annotated0GetDeclaredSwitchMethods3=d\n";
f+="Thread0SetPriority0=a\n";
f+="Thread0Sleep0=a\n";
f+="Thread0Print0=a\n";
f+="Thread1Print0=a\n";
f+="Thread2Print0=a\n";
f+="Thread2Print1=b\n";
f+="Thread0ThreadExitHook0=a\n";
f+="Thread0Thread0=a\n";
f+="Thread0ThreadEq0=a\n";
f+="Thread0ThreadEq1=b\n";
f+="ThreadSet0ThreadSetAdd0=a\n";
f+="ThreadSet0ThreadSetContains0=a\n";
f+="ThreadSet0ThreadSetRemove0=a\n";
f+="ThreadSet0ThreadSet0=a\n";
f+="ReentrantLock0ReentrantLock0=a\n";
f+="AtomicBoolean0SetAtomic0=a\n";
f+="AtomicBoolean0CompareAndSetAtomic0=a\n";
f+="AtomicBoolean0CompareAndSetAtomic1=b\n";
f+="AtomicBoolean0GetAndSetAtomic0=a\n";
f+="AtomicBoolean0LazySetAtomic0=a\n";
f+="AtomicBoolean0AtomicBoolean0=a\n";
f+="AtomicInteger0SetAtomic0=a\n";
f+="AtomicInteger0CompareAndSetAtomic0=a\n";
f+="AtomicInteger0CompareAndSetAtomic1=b\n";
f+="AtomicInteger0GetAndSetAtomic0=a\n";
f+="AtomicInteger0LazySetAtomic0=a\n";
f+="AtomicInteger0AddAndGetAtomic0=a\n";
f+="AtomicInteger0GetAndAddAtomic0=a\n";
f+="AtomicInteger0AtomicInteger0=a\n";
f+="AtomicLong0SetAtomic0=a\n";
f+="AtomicLong0CompareAndSetAtomic0=a\n";
f+="AtomicLong0CompareAndSetAtomic1=b\n";
f+="AtomicLong0GetAndSetAtomic0=a\n";
f+="AtomicLong0LazySetAtomic0=a\n";
f+="AtomicLong0AddAndGetAtomic0=a\n";
f+="AtomicLong0GetAndAddAtomic0=a\n";
f+="AtomicLong0AtomicLong0=a\n";
f+="TableStringObject0ConcKeys0=a\n";
f+="TableStringObject0ConcHasKey0=a\n";
f+="TableStringObject0ConcHasValue0=a\n";
f+="TableStringObject0Get0=a\n";
f+="TableStringObject0Remove0=a\n";
f+="TableStringObject0PutAll0=a\n";
f+="TableStringObject0Put0=a\n";
f+="TableStringObject0Put1=b\n";
f+="TableStringObject0PutAbs0=a\n";
f+="TableStringObject0PutAbs1=b\n";
f+="TableStringObject0Replace0=a\n";
f+="TableStringObject0Replace1=b\n";
f+="EntryStringObject0TableEntryValue0=a\n";
f+="EntryBinary0EntryBinary0=a\n";
f+="EntryBinary0EntryBinary1=b\n";
f+="EntryBinary0EntryTime0=a\n";
f+="EntryText0EntryText0=a\n";
f+="EntryText0EntryText1=b\n";
f+="EntryText0EntryTime0=a\n";
f+="File0Read0=a\n";
f+="File0Write0=a\n";
f+="File0Write1=b\n";
f+="File0FileReadBin0=a\n";
f+="File0FileWriteBin0=a\n";
f+="File0FileWriteBin1=b\n";
f+="File0ThreadSetRemove0=a\n";
f+="File0FileRename0=a\n";
f+="File0FileRename1=b\n";
f+="File0FileDir0=a\n";
f+="File0AppendToFile0=a\n";
f+="File0AppendToFile1=b\n";
f+="File0FileAbsolutePath0=a\n";
f+="File0FileGetName0=a\n";
f+="File0FileGetParentPath0=a\n";
f+="File0FileGetLength0=a\n";
f+="File0FileLastModif0=a\n";
f+="File0FileListDirectories0=a\n";
f+="File0FileListFiles0=a\n";
f+="File0FileIsDirectory0=a\n";
f+="File0FileIsFile0=a\n";
f+="File0FileIsAbsolute0=a\n";
f+="File0FileZipBin0=a\n";
f+="File0FileZipBin1=b\n";
f+="File0FileZipBinArray0=a\n";
f+="File0FileZipText0=a\n";
f+="File0FileZipText1=b\n";
f+="File0FileZippedBin0=a\n";
f+="File0FileZippedBinArray0=a\n";
f+="File0FileZippedText0=a\n";
f+="File0FileMakeDirs0=a\n";
f+="CustIterator0CustIterator0=a\n";
f+="List0AddLi0=a\n";
f+="List1AddLi0=a\n";
f+="List1AddLi1=b\n";
f+="List0This0=a\n";
f+="List1This0=a\n";
f+="List0RemoveLi0=a\n";
f+="List0List0=a\n";
f+="List1List0=a\n";
f+="CustPair0SetFirst0=a\n";
f+="CustPair0SetSecond0=a\n";
f+="CustPair0CustPair0=a\n";
f+="CustPair0CustPair1=b\n";
f+="CustIterTable0CustIterTable0=a\n";
f+="Table0AddLi0=a\n";
f+="Table0AddLi1=b\n";
f+="Table1AddLi0=a\n";
f+="Table0GetTa0=a\n";
f+="Table0GetFirstTa0=a\n";
f+="Table0GetSecondTa0=a\n";
f+="Table0SetFirst0=a\n";
f+="Table0SetFirst1=b\n";
f+="Table0SetSecond0=a\n";
f+="Table0SetSecond1=b\n";
f+="Table0RemoveLi0=a\n";
f+="Execute0ExecuteTests0=a\n";
f+="Execute0Run0=a\n";
f+="Execute0Run1=b\n";
f+="Execute0Run2=c\n";
f+="Execute0ExecuteConvert0=a\n";
f+="Execute0ExecuteSetupNoException0=a\n";
f+="Execute0ExecuteSetupNoException1=b\n";
f+="Execute0ExecuteSetupError0=a\n";
f+="Execute0ExecuteSetupError1=b\n";
f+="Execute0ExecuteSetupError2=c\n";
f+="Execute0ExecuteSetupError3=d\n";
f+="Execute1ExecuteSetupError0=a\n";
f+="Execute1ExecuteSetupError1=b\n";
f+="Execute1ExecuteSetupError2=c\n";
f+="Assert0AssertAssert0=a\n";
f+="Assert0AssertAssert1=b\n";
f+="Assert1AssertAssert0=a\n";
f+="Assert1AssertAssert1=b\n";
f+="Assert2AssertAssert0=a\n";
f+="Assert2AssertAssert1=b\n";
f+="Assert3AssertAssert0=a\n";
f+="Assert3AssertAssert1=b\n";
f+="Assert4AssertAssert0=a\n";
f+="Assert4AssertAssert1=b\n";
f+="Assert5AssertAssertDouble0=a\n";
f+="Assert5AssertAssertDouble1=b\n";
f+="Assert5AssertAssertDouble2=c\n";
f+="Assert0AssertAssertArr0=a\n";
f+="Assert0AssertAssertArr1=b\n";
f+="Assert1AssertAssertArr0=a\n";
f+="Assert1AssertAssertArr1=b\n";
f+="Assert2AssertAssertArr0=a\n";
f+="Assert2AssertAssertArr1=b\n";
f+="Assert3AssertAssertArr0=a\n";
f+="Assert3AssertAssertArr1=b\n";
f+="Assert4AssertAssertArr0=a\n";
f+="Assert4AssertAssertArr1=b\n";
f+="Assert5AssertAssertArrDouble0=a\n";
f+="Assert5AssertAssertArrDouble1=b\n";
f+="Assert5AssertAssertArrDouble2=c\n";
f+="Assert0AssertAssertNot0=a\n";
f+="Assert0AssertAssertNot1=b\n";
f+="Assert1AssertAssertNot0=a\n";
f+="Assert1AssertAssertNot1=b\n";
f+="Assert2AssertAssertNot0=a\n";
f+="Assert2AssertAssertNot1=b\n";
f+="Assert3AssertAssertNot0=a\n";
f+="Assert3AssertAssertNot1=b\n";
f+="Assert4AssertAssertNot0=a\n";
f+="Assert4AssertAssertNot1=b\n";
f+="Assert5AssertAssertNotDouble0=a\n";
f+="Assert5AssertAssertNotDouble1=b\n";
f+="Assert5AssertAssertNotDouble2=c\n";
f+="Assert0AssertAssertNotArr0=a\n";
f+="Assert0AssertAssertNotArr1=b\n";
f+="Assert1AssertAssertNotArr0=a\n";
f+="Assert1AssertAssertNotArr1=b\n";
f+="Assert2AssertAssertNotArr0=a\n";
f+="Assert2AssertAssertNotArr1=b\n";
f+="Assert3AssertAssertNotArr0=a\n";
f+="Assert3AssertAssertNotArr1=b\n";
f+="Assert4AssertAssertNotArr0=a\n";
f+="Assert4AssertAssertNotArr1=b\n";
f+="Assert5AssertAssertNotArrDouble0=a\n";
f+="Assert5AssertAssertNotArrDouble1=b\n";
f+="Assert5AssertAssertNotArrDouble2=c\n";
f+="Assert0AssertAssertTrue0=a\n";
f+="Assert0AssertAssertFalse0=a\n";
f+="Assert0AssertAssertNull0=a\n";
f+="Assert0AssertAssertNotNull0=a\n";
f+="Assert0AssertAssertSame0=a\n";
f+="Assert0AssertAssertSame1=b\n";
f+="Assert0AssertAssertNotSame0=a\n";
f+="Assert0AssertAssertNotSame1=b\n";
f+="Assert5AssertAssert0=a\n";
f+="Assert5AssertAssert1=b\n";
f+="Assert5AssertAssert2=c\n";
f+="Assert6AssertAssert0=a\n";
f+="Assert6AssertAssert1=b\n";
f+="Assert5AssertAssertArr0=a\n";
f+="Assert5AssertAssertArr1=b\n";
f+="Assert5AssertAssertArr2=c\n";
f+="Assert6AssertAssertArr0=a\n";
f+="Assert6AssertAssertArr1=b\n";
f+="Assert5AssertAssertNot0=a\n";
f+="Assert5AssertAssertNot1=b\n";
f+="Assert5AssertAssertNot2=c\n";
f+="Assert6AssertAssertNot0=a\n";
f+="Assert6AssertAssertNot1=b\n";
f+="Assert5AssertAssertNotArr0=a\n";
f+="Assert5AssertAssertNotArr1=b\n";
f+="Assert5AssertAssertNotArr2=c\n";
f+="Assert6AssertAssertNotArr0=a\n";
f+="Assert6AssertAssertNotArr1=b\n";
f+="FormatType0Print0=a\n";
f+="FormatType1Print0=a\n";
f+="FormatType1Print1=b\n";
f+="Math0Eval0=a\n";
f+="Math0Eval1=b\n";
return f;
}
static String resourcesLgCollectionsList(){
String f="{public} {class} {Iter}<{T}> :{iteratorType}<{T}>'{'\n";
f+=" {private} {List}<{T}> {listItr};\n";
f+=" {private} {int} {lengthItrLi};\n";
f+=" {private} {int} {indexItrLi};\n";
f+=" {public} ({List}<{T}> {itCtr})'{'\n";
f+="  {this}.{listItr}={itCtr};\n";
f+="  {this}.{lengthItrLi}={this}.{listItr}.{sizeLi}();\n";
f+=" '}'\n";
f+=" {public} {T} {next}()'{'\n";
f+="  {T} {out}={this}.{listItr}[{indexItrLi}];\n";
f+="  {this}.{indexItrLi}++;\n";
f+="  {return} {out};\n";
f+=" '}'\n";
f+=" {public} {boolean} {hasNext}()'{'\n";
f+="  {return} {indexItrLi}<{lengthItrLi};\n";
f+=" '}'\n";
f+="'}'\n";
f+="{public} {class} {List}<{E}> :{iterable}<{E}>'{'\n";
f+=" {private} {E}[] {array};\n";
f+=" {private} {int} {lengthLi};\n";
f+=" {public} ()'{'\n";
f+="  {array}={new} {E}[0];\n";
f+=" '}'\n";
f+=" {public} ({List}<{E}> {liCtr1})'{'\n";
f+="  {this}.{array}=({liCtr1}).{array}.{clone}();\n";
f+="  {this}.{lengthLi}={this}.{array}.{length};\n";
f+=" '}'\n";
f+=" {public} ({E}... {liCtr2})'{'\n";
f+="  {this}.{array}=({liCtr2}).{clone}();\n";
f+="  {this}.{lengthLi}={this}.{array}.{length};\n";
f+=" '}'\n";
f+=" {public} {void} {add}({E} {liAdd1})'{'\n";
f+="  {add}({this}.{lengthLi},{liAdd1});\n";
f+=" '}'\n";
f+=" {public} {void} {add}({int} {liAdd21},{E} {liAdd22})'{'\n";
f+="  {E}[] {out}={new} {E}[{this}.{lengthLi}+1];\n";
f+="  {iter}({int} {i}=0;{liAdd21};1)'{'\n";
f+="   {out}[{i}]={this}.{array}[{i}];\n";
f+="  '}'\n";
f+="  {out}[{liAdd21}]={liAdd22};\n";
f+="  {iter}({int} {i}={liAdd21}+1;{lengthLi}+1;1)'{'\n";
f+="   {out}[{i}]={this}.{array}[{i}-1];\n";
f+="  '}'\n";
f+="  {this}.{lengthLi}++;\n";
f+="  {this}.{array}={out};\n";
f+=" '}'\n";
f+=" {public} {int} {sizeLi}()'{'\n";
f+="  {return} {this}.{lengthLi};\n";
f+=" '}'\n";
f+=" {public} {E} {this}({int} {liInd1})'{'\n";
f+="  {return} {this}.{array}[{liInd1}];\n";
f+=" '}'\n";
f+=" {public} {void} {this}({int} {liInd2})'{'\n";
f+="  {this}.{array}[{liInd2}]={value};\n";
f+=" '}'\n";
f+=" {public} {void} {remove}({int} {liRem})'{'\n";
f+="  {E}[] {out}={new} {E}[{this}.{lengthLi}-1];\n";
f+="  {iter}({int} {i}=0;{liRem};1)'{'\n";
f+="   {out}[{i}]={this}.{array}[{i}];\n";
f+="  '}'\n";
f+="  {iter}({int} {i}={liRem}+1;{this}.{lengthLi};1)'{'\n";
f+="   {out}[{i}-1]={this}.{array}[{i}];\n";
f+="  '}'\n";
f+="  {this}.{array} = {out};\n";
f+="  {lengthLi}--;\n";
f+=" '}'\n";
f+=" {public} {void} {clear}()'{'\n";
f+="  {lengthLi}=0;\n";
f+="  {this}.{array}={new} {E}[0];\n";
f+=" '}'\n";
f+=" {public} {iteratorType}<{E}> {iterator}()'{'\n";
f+="  {return} {new} {Iter}<{E}>({this});\n";
f+=" '}'\n";
f+="'}'\n";
return f;
}
static String resourcesLgCollectionsTable(){
String f="{public} {class} {CustPair}<{U},{V}> :{Pair}<{U},{V}>'{'\n";
f+=" {private} {U} {first};\n";
f+=" {private} {V} {second};\n";
f+=" {public} ()'{'\n";
f+=" '}'\n";
f+=" {public} ({U} {p1},{V} {p2})'{'\n";
f+="  {this}.{first} = {p1};\n";
f+="  {this}.{second} = {p2};\n";
f+=" '}'\n";
f+=" {public} {U} {getFirst}()'{'\n";
f+="  {return} {first};\n";
f+=" '}'\n";
f+=" {public} {V} {getSecond}()'{'\n";
f+="  {return} {second};\n";
f+=" '}'\n";
f+=" {public} {void} {setFirst}({U} {p3})'{'\n";
f+="  {this}.{first} = {p3};\n";
f+=" '}'\n";
f+=" {public} {void} {setSecond}({V} {p4})'{'\n";
f+="  {this}.{second} = {p4};\n";
f+=" '}'\n";
f+="'}'\n";
f+="{public} {class} {CustIterTable}<{A},{B}> :{IterTypeTable}<{A},{B}>'{'\n";
f+=" {private} {Table}<{A},{B}> {listItrTa};\n";
f+=" {private} {int} {lengthItrTa};\n";
f+=" {private} {int} {indexItrTa};\n";
f+=" {public} ({Table}<{A},{B}> {ti})'{'\n";
f+="  {this}.{listItrTa}={ti};\n";
f+="  {this}.{lengthItrTa}={this}.{listItrTa}.{sizeTa}();\n";
f+=" '}'\n";
f+=" {public} {CustPair}<{A},{B}> {nextPair}()'{'\n";
f+="  {CustPair}<{A},{B}> {out}={this}.{listItrTa}.{getTa}({this}.{indexItrTa});\n";
f+="  {this}.{indexItrTa}++;\n";
f+="  {return} {out};\n";
f+=" '}'\n";
f+=" {public} {boolean} {hasNextPair}()'{'\n";
f+="  {return} {indexItrTa}<{lengthItrTa};\n";
f+=" '}'\n";
f+="'}'\n";
f+="{public} {class} {Table}<{E},{F}> :{iterableTable}<{E},{F}>'{'\n";
f+=" {private} {List}<{CustPair}<{E},{F}>> {listTa};\n";
f+=" {public} ()'{'\n";
f+="  {listTa}={new} {List}<{CustPair}<{E},{F}>>();\n";
f+=" '}'\n";
f+=" {public} {void} {addTa}({E} {p5},{F} {p6})'{'\n";
f+="  {this}.{listTa}.{add}({new} {CustPair}<{E},{F}>({p5},{p6}));\n";
f+=" '}'\n";
f+=" {public} {void} {addTa}({CustPair}<{E},{F}> {p7})'{'\n";
f+="  {this}.{listTa}.{add}({p7});\n";
f+=" '}'\n";
f+=" {public} {int} {sizeTa}()'{'\n";
f+="  {return} {listTa}.{sizeLi}();\n";
f+=" '}'\n";
f+=" {public} {CustPair}<{E},{F}> {getTa}({int} {p8})'{'\n";
f+="  {return} {this}.{listTa}[{p8}];\n";
f+=" '}'\n";
f+=" {public} {E} {getFirstTa}({int} {p9})'{'\n";
f+="  {return} {this}.{listTa}[{p9}].{getFirst}();\n";
f+=" '}'\n";
f+=" {public} {F} {getSecondTa}({int} {p10})'{'\n";
f+="  {return} {this}.{listTa}[{p10}].{getSecond}();\n";
f+=" '}'\n";
f+=" {public} {void} {setFirstTa}({int} {p11}, {E} {p12})'{'\n";
f+="  {this}.{listTa}[{p11}].{setFirst}({p12});\n";
f+=" '}'\n";
f+=" {public} {void} {setSecondTa}({int} {p13}, {F} {p14})'{'\n";
f+="  {this}.{listTa}[{p13}].{setSecond}({p14});\n";
f+=" '}'\n";
f+=" {public} {void} {removeTa}({int} {p15})'{'\n";
f+="  {this}.{listTa}.{remove}({p15});\n";
f+=" '}'\n";
f+=" {public} {IterTypeTable}<{E},{F}> {iteratorTable}()'{'\n";
f+="  {return} {new} {CustIterTable}<{E},{F}>({this});\n";
f+=" '}'\n";
f+="'}'\n";
return f;
}
static String resourcesLgTestsRun(){
String f="\n";
f+="{public} {abstract} {final} {class} {Execute}'{'\n";
f+="    {public} {static} {Table}<{Method},{Result}> {tests}({InfoTest} {info})'{'\n";
f+="        {Table}<{Class},{List}<{ExecutedTest}>> {out} = {new} {Table}<>();\n";
f+="        {var} {t} = {cast}({long})0;\n";
f+="        {for} ({var} {c}: {static}({Class}).{getAllClasses}())'{'\n";
f+="            {List}<{Method}> {bs} = {new} {List}<>();\n";
f+="            {List}<{Method}> {as} = {new} {List}<>();\n";
f+="            {List}<{ExecutedTest}> {tts} = {new} {List}<>();\n";
f+="            {for} ({var} {m}: ({c}).{getDeclaredMethods}())'{'\n";
f+="                {var} {e} = {new} {ExecutedTest}();\n";
f+="                {var} {a} = ({m}).{getAnnotations}({class}({Test}));\n";
f+="                {if} ({static}({ObjectsUtil}).{eq}(({a}).{length}, 1) && (({cast}({Test}){a}[0]).{exception}() == {cast}({Object}) {null} || !{class}({Difference}).{isAssignableFrom}(({cast}({Test}){a}[0]).{exception}())))'{'\n";
f+="                    ({e}).{test} = {m};\n";
f+="                    ({e}).{annotations} = {a};\n";
f+="                    ({e}).{before} = {bs};\n";
f+="                    ({e}).{after} = {as};\n";
f+="                    {var} {aParam} = ({m}).{getAnnotations}({class}({Parameters}));\n";
f+="                    {if} ({static}({ObjectsUtil}).{eq}(({aParam}).{length}, 1))'{'\n";
f+="                        {var} {paramAnn} = {cast}({Parameters}){aParam}[0];\n";
f+="                        {var} {loc} = ({paramAnn}).{methodParam}();\n";
f+="                        {var} {locType} = ({paramAnn}).{location}();\n";
f+="                        {if} ({static}({ObjectsUtil}).{eq}({locType},{null}))'{'\n";
f+="                            {locType} = {c};\n";
f+="                        '}'\n";
f+="                        {for} ({var} {p}: ({locType}).{getDeclaredMethods}())'{'\n";
f+="                            {if} (!{static}({ObjectsUtil}).{eq}(({p}).{getMethodName}(), {loc}))'{'\n";
f+="                                {continue};\n";
f+="                            '}'\n";
f+="                            {if} (!({p}).{isStatic}())'{'\n";
f+="                                {continue};\n";
f+="                            '}'\n";
f+="                            {if} (!{static}({ObjectsUtil}).{eq}(({p}).{getParameterTypes}().{length},0))'{'\n";
f+="                                {continue};\n";
f+="                            '}'\n";
f+="                            ({e}).{method} = {p};\n";
f+="                            {break};\n";
f+="                        '}'\n";
f+="                    '}'\n";
f+="                    {t} = {static}({Math}).{plus}({t},1);\n";
f+="                    ({tts}).{add}({e});\n";
f+="                '}'\n";
f+="                {if} ({static}({Math}).{gt}(({m}).{getAnnotations}({class}({Before})).{length},0))'{'\n";
f+="                    ({bs}).{add}({m});\n";
f+="                '}'\n";
f+="                {if} ({static}({Math}).{gt}(({m}).{getAnnotations}({class}({After})).{length},0))'{'\n";
f+="                    ({as}).{add}({m});\n";
f+="                '}'\n";
f+="            '}'\n";
f+="            {if} ({static}({Math}).{gt}(({tts}).{sizeLi}(),0))'{'\n";
f+="                ({out}).{addTa}({c},{tts});\n";
f+="            '}'\n";
f+="        '}'\n";
f+="        ({info}).{count} = {t};\n";
f+="        {Table}<{Method},{Result}> {results} = {new} {Table}<>();\n";
f+="        {for} ({var} {c}, {var} {l}: {out})'{'\n";
f+="            {for} ({var} {e}: {l})'{'\n";
f+="                {var} {tt} = ({e}).{test};\n";
f+="                ({info}).{currentMethod} = {tt};\n";
f+="                {if} (!{static}({ObjectsUtil}).{eq}(({e}).{method},{null}))'{'\n";
f+="                    {Object} {arr} = {null};\n";
f+="                    {Object} {exc} = {null};\n";
f+="                    {try} '{'\n";
f+="                        {arr} = ({e}).{method}.{invoke}({null});\n";
f+="                    '}' {catch} ({InvokeTarget} {o})'{'\n";
f+="                        {exc} = ({o}).{getCause}();\n";
f+="                    '}'\n";
f+="                    {if} ({arr} {instanceof} {Object}[][])'{'\n";
f+="                        {for} ({var} {p}: {cast}({Object}[][]){arr})'{'\n";
f+="                            {var} {params} = {new} {StringBuilder}();\n";
f+="                            {var} {nbParams} = ({p}).{length};\n";
f+="                            {for} ({var} {i} = 0; {static}({Math}).{lt}({i}, {static}({Math}).{minus}({nbParams},1)); {i}={static}({Math}).{plus}({i},1))'{'\n";
f+="                                ({params}).{append}({convert}({p}[{i}])).{append}(\",\");\n";
f+="                            '}'\n";
f+="                            {if} ({static}({Math}).{gt}({nbParams},0))'{'\n";
f+="                                ({params}).{append}({convert}({p}[{static}({Math}).{minus}({nbParams},1)]));\n";
f+="                            '}'\n";
f+="                            ({info}).{currentParams} = ({params}).{toString}();\n";
f+="                            {var} {res} = {execute}({e},{c},{p});\n";
f+="                            ({res}).{pf} = ({params}).{toString}();\n";
f+="                            ({results}).{addTa}({tt},{res});\n";
f+="                        '}'\n";
f+="                    '}' {else} '{'\n";
f+="                        ({results}).{addTa}({tt},{setupError}({e},{exc},-1));\n";
f+="                    '}'\n";
f+="                '}' {else} '{'\n";
f+="                    ({results}).{addTa}({tt},{execute}({e},{c},{new} {Object}[]'{''}'));\n";
f+="                '}'\n";
f+="                ({info}).{done} = {static}({Math}).{plus}(({info}).{done},1);\n";
f+="            '}'\n";
f+="        '}'\n";
f+="        {static}({Thread}).{joinOthers}();\n";
f+="        {return} {results};\n";
f+="    '}'\n";
f+="    {private} {static} {Result} {execute}({ExecutedTest} {r1},{Class} {r2},{Object}[] {r3})'{'\n";
f+="        {var} {processEx} = {false};\n";
f+="        {var} {stTime} = {static}({Thread}).{instant}();\n";
f+="        {long} {diff} = -1;\n";
f+="        {try} '{'\n";
f+="            {var} {ctor} = ({r2}).{getDeclaredConstructors}({false})[0];\n";
f+="            {processEx} = {true};\n";
f+="            {var} {classTest} = ({ctor}).{newInstance}();\n";
f+="            {for} ({var} {b}: ({r1}).{before})'{'\n";
f+="                ({b}).{invoke}({classTest});\n";
f+="            '}'\n";
f+="            {stTime} = {static}({Thread}).{instant}();\n";
f+="            ({r1}).{test}.{invoke}({classTest}, {r3});\n";
f+="            {diff} = {static}({Thread}).{instant}()-{stTime};\n";
f+="            {for} ({var} {b}: ({r1}).{after})'{'\n";
f+="                ({b}).{invoke}({classTest});\n";
f+="            '}'\n";
f+="            {return} {setupNoException}({r1},{diff});\n";
f+="        '}' {catch} ({InvokeTarget} {o})'{'\n";
f+="            {diff} = {diff} == -1 ? {static}({Thread}).{instant}()-{stTime} : {diff};\n";
f+="            {return} {setupError}({r1},{o},{processEx},{diff});\n";
f+="        '}' {catch} ({Object} {o})'{'\n";
f+="            {diff} = {diff} == -1 ? {static}({Thread}).{instant}()-{stTime} : {diff};\n";
f+="            {return} {setupError}({r1},{o},{diff});\n";
f+="        '}' {catch} '{'\n";
f+="            {diff} = {diff} == -1 ? {static}({Thread}).{instant}()-{stTime} : {diff};\n";
f+="            {return} {setupError}({r1},{null},{diff});\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {private} {static} {String} {convert}({Object} {co})'{'\n";
f+="        {try} '{'\n";
f+="            {return} {static}({StringUtil}).{valueOf}({co});\n";
f+="        '}' {catch} ({Object} {e})'{'\n";
f+="            {return} {static}({Class}).{getClass}({co}).{getClassName}();\n";
f+="        '}' {catch} '{'\n";
f+="            {return} {static}({Class}).{getClass}({co}).{getClassName}();\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {private} {static} {Result} {setupNoException}({ExecutedTest} {et1},{long} {tps1})'{'\n";
f+="        {var} {res} = {new} {Result}();\n";
f+="        {res}.{time} = {tps1}/1000000;\n";
f+="        {var} {tt} = {cast}({Test})({et1}).{annotations}[0];\n";
f+="        {if} (({tt}).{nullException}())'{'\n";
f+="            ({res}).{success} = {false};\n";
f+="            ({res}).{failMessage} = {new} {StringBuilder}(\"!=\").{append}({static}({StringUtil}).{valueOf}({null})).{toString}();\n";
f+="        '}' {else} {if} (!{static}({ObjectsUtil}).{eq}(({tt}).{exception}(),{null}))'{'\n";
f+="            ({res}).{success} = {false};\n";
f+="            ({res}).{failMessage} = {new} {StringBuilder}(\"!=\").{append}(({tt}).{exception}().{getClassName}()).{toString}();\n";
f+="        '}'\n";
f+="        {return} {res};\n";
f+="    '}'\n";
f+="    {private} {static} {Result} {setupError}({ExecutedTest} {et2}, {InvokeTarget} {et3}, {boolean} {et4}, {long} {tps2})'{'\n";
f+="        {var} {res} = {new} {Result}();\n";
f+="        {res}.{time} = {tps2}/1000000;\n";
f+="        {var} {ex} = ({et3}).{getCause}();\n";
f+="        {if} ({et4}) '{'\n";
f+="            {var} {tt} = {cast}({Test})({et2}).{annotations}[0];\n";
f+="            {if} (({tt}).{nullException}())'{'\n";
f+="                {if} (!{static}({ObjectsUtil}).{eq}({ex},{null}))'{'\n";
f+="                    ({res}).{success} = {false};\n";
f+="                    ({res}).{failMessage} = {static}({StringUtil}).{valueOf}({ex});\n";
f+="                '}'\n";
f+="            '}' {else} {if} (!{static}({ObjectsUtil}).{eq}(({tt}).{exception}(),{null})) '{'\n";
f+="                {if} (!({tt}).{exception}().{isAssignableFrom}({static}({Class}).{getClass}({ex})))'{'\n";
f+="                    ({res}).{success} = {false};\n";
f+="                    ({res}).{failMessage} = {static}({StringUtil}).{valueOf}({ex});\n";
f+="                '}'\n";
f+="            '}' {else} '{'\n";
f+="                ({res}).{success} = {false};\n";
f+="                ({res}).{failMessage} = {static}({StringUtil}).{valueOf}({ex});\n";
f+="            '}'\n";
f+="        '}' {else} '{'\n";
f+="            ({res}).{success} = {false};\n";
f+="            ({res}).{failMessage} = {static}({StringUtil}).{valueOf}({ex});\n";
f+="        '}'\n";
f+="        {return} {res};\n";
f+="    '}'\n";
f+="    {private} {static} {Result} {setupError}({ExecutedTest} {et}, {Object} {er}, {long} {tps3})'{'\n";
f+="        {var} {res} = {new} {Result}();\n";
f+="        {res}.{time} = {tps3}/1000000;\n";
f+="        ({res}).{success} = {false};\n";
f+="        ({res}).{failMessage} = {static}({StringUtil}).{valueOf}({er});\n";
f+="        {return} {res};\n";
f+="    '}'\n";
f+="'}'\n";
f+="{public} {class} {InfoTest}'{'\n";
f+="    {public} {long} {count};\n";
f+="    {public} {long} {done};\n";
f+="    {public} {Method} {currentMethod};\n";
f+="    {public} {String} {currentParams};\n";
f+="'}'\n";
f+="{public} {class} {Result}'{'\n";
f+="    {public} {long} {time} = -1;\n";
f+="    {public} {boolean} {success} = {true};\n";
f+="    {public} {String} {pf} = \"\";\n";
f+="    {public} {String} {failMessage} = \"\";\n";
f+="'}'\n";
f+="{public} {class} {ExecutedTest}'{'\n";
f+="    {public} {List}<{Method}> {before};\n";
f+="    {public} {Method} {test};\n";
f+="    {public} {Annotation}[] {annotations};\n";
f+="    {public} {List}<{Method}> {after};\n";
f+="    {public} {Method} {method};\n";
f+="'}'\n";
f+="{public} {annotation} {Before}'{''}'\n";
f+="{public} {annotation} {After}'{''}'\n";
f+="{public} {annotation} {Parameters}'{'\n";
f+="    {String} {methodParam}();\n";
f+="    {Class} {location}(){null};\n";
f+="'}'\n";
f+="{public} {annotation} {Test}'{'\n";
f+="    {Class} {exception}(){null};\n";
f+="    {boolean} {nullException}(){false};\n";
f+="'}'\n";
f+="{public} {abstract} {final} {class} {Assert}'{'\n";
f+="    {public} {static} {void} {assert}({long}[] {at11}, {long}[] {at12})'{'\n";
f+="        {assert}({at11}.{length},{at12}.{length});\n";
f+="        {var} {la} = {at11}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} (!{static}({ObjectsUtil}).{eq}({at11}[{ea}], {at12}[{ea}]))'{'\n";
f+="                {var} {d} = {new} {EltDifference}();\n";
f+="                ({d}).{index}={ea};\n";
f+="                ({d}).{expected}={at11}[{ea}];\n";
f+="                ({d}).{found}={at12}[{ea}];\n";
f+="                ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="                {throw} {d};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({double}[] {at21}, {double}[] {at22})'{'\n";
f+="        {assert}({at21}.{length},{at22}.{length});\n";
f+="        {var} {la} = {at21}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} (!{static}({ObjectsUtil}).{eq}({at21}[{ea}], {at22}[{ea}]))'{'\n";
f+="                {var} {d} = {new} {EltDifference}();\n";
f+="                ({d}).{index}={ea};\n";
f+="                ({d}).{expected}={at21}[{ea}];\n";
f+="                ({d}).{found}={at22}[{ea}];\n";
f+="                ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="                {throw} {d};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({double}[] {at211}, {double}[] {at212}, {double} {at213})'{'\n";
f+="        {assert}({at211}.{length},{at212}.{length});\n";
f+="        {var} {la} = {at211}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} ({static}({Double}).{compare}({at211}[{ea}], {at212}[{ea}]) != 0 && !({static}({Math}).{abs}({at211}[{ea}]- {at212}[{ea}])<={at213}))'{'\n";
f+="                {var} {d} = {new} {EltDifference}();\n";
f+="                ({d}).{index}={ea};\n";
f+="                ({d}).{expected}={at211}[{ea}];\n";
f+="                ({d}).{found}={at212}[{ea}];\n";
f+="                ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="                {throw} {d};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({String}[] {at31}, {String}[] {at32})'{'\n";
f+="        {assert}({at31}.{length},{at32}.{length});\n";
f+="        {var} {la} = {at31}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} (!{static}({ObjectsUtil}).{eq}({at31}[{ea}], {at32}[{ea}]))'{'\n";
f+="                {var} {d} = {new} {EltDifference}();\n";
f+="                ({d}).{index}={ea};\n";
f+="                ({d}).{expected}={at31}[{ea}];\n";
f+="                ({d}).{found}={at32}[{ea}];\n";
f+="                ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="                {throw} {d};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({StringBuilder}[] {at41}, {StringBuilder}[] {at42})'{'\n";
f+="        {assert}({at41}.{length},{at42}.{length});\n";
f+="        {var} {la} = {at41}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} (!{static}({ObjectsUtil}).{eq}({at41}[{ea}], {at42}[{ea}]))'{'\n";
f+="                {var} {d} = {new} {EltDifference}();\n";
f+="                ({d}).{index}={ea};\n";
f+="                ({d}).{expected}={at41}[{ea}];\n";
f+="                ({d}).{found}={at42}[{ea}];\n";
f+="                ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="                {throw} {d};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({boolean}[] {at51}, {boolean}[] {at52})'{'\n";
f+="        {assert}({at51}.{length},{at52}.{length});\n";
f+="        {var} {la} = {at51}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} (!{static}({ObjectsUtil}).{eq}({at51}[{ea}], {at52}[{ea}]))'{'\n";
f+="                {var} {d} = {new} {EltDifference}();\n";
f+="                ({d}).{index}={ea};\n";
f+="                ({d}).{expected}={at51}[{ea}];\n";
f+="                ({d}).{found}={at52}[{ea}];\n";
f+="                ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="                {throw} {d};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({long} {a11}, {long} {a12})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({a11}, {a12}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={a11};\n";
f+="            ({d}).{found}={a12};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({double} {a21}, {double} {a22})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({a21}, {a22}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={a21};\n";
f+="            ({d}).{found}={a22};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({double} {a211}, {double} {a212}, {double} {a213})'{'\n";
f+="        {if} ({static}({Double}).{compare}({a211}, {a212}) != 0 && !({static}({Math}).{abs}({a211}- {a212})<={a213}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={a211};\n";
f+="            ({d}).{found}={a212};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({String} {a31}, {String} {a32})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({a31}, {a32}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={a31};\n";
f+="            ({d}).{found}={a32};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({StringBuilder} {a41}, {StringBuilder} {a42})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({a41}, {a42}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={a41};\n";
f+="            ({d}).{found}={a42};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({boolean} {a51}, {boolean} {a52})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({a51}, {a52}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={a51};\n";
f+="            ({d}).{found}={a52};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({long}[] {ant11}, {long}[] {ant12})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({ant11}.{length},{ant12}.{length}))'{'\n";
f+="            {return};\n";
f+="        '}'\n";
f+="        {assert}({ant11}.{length},{ant12}.{length});\n";
f+="        {var} {la} = {ant11}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} (!{static}({ObjectsUtil}).{eq}({ant11}[{ea}], {ant12}[{ea}]))'{'\n";
f+="                {return};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="        {var} {d} = {new} {Difference}();\n";
f+="        ({d}).{expected}={ant11};\n";
f+="        ({d}).{found}={ant12};\n";
f+="        ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="        {throw} {d};\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({double}[] {ant21}, {double}[] {ant22})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({ant21}.{length},{ant22}.{length}))'{'\n";
f+="            {return};\n";
f+="        '}'\n";
f+="        {var} {la} = {ant21}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} (!{static}({ObjectsUtil}).{eq}({ant21}[{ea}], {ant22}[{ea}]))'{'\n";
f+="                {return};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="        {var} {d} = {new} {Difference}();\n";
f+="        ({d}).{expected}={ant21};\n";
f+="        ({d}).{found}={ant22};\n";
f+="        ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="        {throw} {d};\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({double}[] {ant211}, {double}[] {ant212}, {double} {ant213})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({ant211}.{length},{ant212}.{length}))'{'\n";
f+="            {return};\n";
f+="        '}'\n";
f+="        {var} {la} = {ant211}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} ({static}({Double}).{compare}({ant211}[{ea}], {ant212}[{ea}]) != 0 && !({static}({Math}).{abs}({ant211}[{ea}]- {ant212}[{ea}])<={ant213}))'{'\n";
f+="                {return};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="        {var} {d} = {new} {Difference}();\n";
f+="        ({d}).{expected}={ant211};\n";
f+="        ({d}).{found}={ant212};\n";
f+="        ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="        {throw} {d};\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({String}[] {ant31}, {String}[] {ant32})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({ant31}.{length},{ant32}.{length}))'{'\n";
f+="            {return};\n";
f+="        '}'\n";
f+="        {var} {la} = {ant31}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} (!{static}({ObjectsUtil}).{eq}({ant31}[{ea}], {ant32}[{ea}]))'{'\n";
f+="                {return};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="        {var} {d} = {new} {Difference}();\n";
f+="        ({d}).{expected}={ant31};\n";
f+="        ({d}).{found}={ant32};\n";
f+="        ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="        {throw} {d};\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({StringBuilder}[] {ant41}, {StringBuilder}[] {ant42})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({ant41}.{length},{ant42}.{length}))'{'\n";
f+="            {return};\n";
f+="        '}'\n";
f+="        {var} {la} = {ant41}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} (!{static}({ObjectsUtil}).{eq}({ant41}[{ea}], {ant42}[{ea}]))'{'\n";
f+="                {return};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="        {var} {d} = {new} {Difference}();\n";
f+="        ({d}).{expected}={ant41};\n";
f+="        ({d}).{found}={ant42};\n";
f+="        ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="        {throw} {d};\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({boolean}[] {ant51}, {boolean}[] {ant52})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({ant51}.{length},{ant52}.{length}))'{'\n";
f+="            {return};\n";
f+="        '}'\n";
f+="        {var} {la} = {ant51}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} (!{static}({ObjectsUtil}).{eq}({ant51}[{ea}], {ant52}[{ea}]))'{'\n";
f+="                {return};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="        {var} {d} = {new} {Difference}();\n";
f+="        ({d}).{expected}={ant51};\n";
f+="        ({d}).{found}={ant52};\n";
f+="        ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="        {throw} {d};\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({long} {an11}, {long} {an12})'{'\n";
f+="        {if} ({static}({ObjectsUtil}).{eq}({an11}, {an12}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={an11};\n";
f+="            ({d}).{found}={an12};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({double} {an21}, {double} {an22})'{'\n";
f+="        {if} ({static}({ObjectsUtil}).{eq}({an21}, {an22}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={an21};\n";
f+="            ({d}).{found}={an22};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({double} {an211}, {double} {an212}, {double} {an213})'{'\n";
f+="        {if} ({static}({Double}).{compare}({an211}, {an212}) == 0 || {static}({Math}).{abs}({an211}- {an212})<={an213})'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={a211};\n";
f+="            ({d}).{found}={a212};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({String} {an31}, {String} {an32})'{'\n";
f+="        {if} ({static}({ObjectsUtil}).{eq}({an31}, {an32}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={an31};\n";
f+="            ({d}).{found}={an32};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({StringBuilder} {an41}, {StringBuilder} {an42})'{'\n";
f+="        {if} ({static}({ObjectsUtil}).{eq}({an41}, {an42}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={an41};\n";
f+="            ({d}).{found}={an42};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({boolean} {an51}, {boolean} {an52})'{'\n";
f+="        {if} ({static}({ObjectsUtil}).{eq}({an51}, {an52}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={an51};\n";
f+="            ({d}).{found}={an52};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertTrue}({boolean} {a6})'{'\n";
f+="        {if} (!{a6})'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={true};\n";
f+="            ({d}).{found}={false};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertFalse}({boolean} {a61})'{'\n";
f+="        {if} ({a61})'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={false};\n";
f+="            ({d}).{found}={true};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNull}({Object} {a7})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({a7}, {null}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={null};\n";
f+="            ({d}).{found}={a7};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNotNull}({Object} {a8})'{'\n";
f+="        {if} ({static}({ObjectsUtil}).{eq}({a8}, {null}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{foundNull}={true};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertSame}({Object} {a91}, {Object} {a92})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({a91}, {a92}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={a91};\n";
f+="            ({d}).{found}={a92};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNotSame}({Object} {an91}, {Object} {an92})'{'\n";
f+="        {if} ({static}({ObjectsUtil}).{eq}({an91}, {an92}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={an91};\n";
f+="            ({d}).{found}={an92};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({Object}[] {at101}, {Object}[] {at102}, {Fct}<?,?,{boolean}> {at103})'{'\n";
f+="        {assert}({at101}.{length},{at102}.{length});\n";
f+="        {var} {la} = {at101}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} (!({at103}).{call}({at101}[{ea}], {at102}[{ea}]))'{'\n";
f+="                {var} {d} = {new} {EltDifference}();\n";
f+="                ({d}).{index}={ea};\n";
f+="                ({d}).{expected}={at101}[{ea}];\n";
f+="                ({d}).{found}={at102}[{ea}];\n";
f+="                ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="                {throw} {d};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({Object}[] {at111}, {Fct}<?,{boolean}> {at112})'{'\n";
f+="        {for}({var} {ea}:{at111})'{'\n";
f+="            {if} (!({at112}).{call}({ea}))'{'\n";
f+="                {var} {d} = {new} {EltDifference}();\n";
f+="                ({d}).{index}=([{ea}]);\n";
f+="                ({d}).{found}={ea};\n";
f+="                ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="                {throw} {d};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({Object} {a101}, {Object} {a102}, {Fct}<?,?,{boolean}> {a103})'{'\n";
f+="        {if} (!({a103}).{call}({a101}, {a102}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={a101};\n";
f+="            ({d}).{found}={a102};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assert}({Object} {a111}, {Fct}<?,{boolean}> {a112})'{'\n";
f+="        {if} (!({a112}).{call}({a111}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{foundNotTrue}={true};\n";
f+="            ({d}).{found}={a111};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({Object}[] {ant101}, {Object}[] {ant102}, {Fct}<?,?,{boolean}> {ant103})'{'\n";
f+="        {if} (!{static}({ObjectsUtil}).{eq}({ant101}.{length},{ant102}.{length}))'{'\n";
f+="            {return};\n";
f+="        '}'\n";
f+="        {var} {la} = {ant101}.{length};\n";
f+="        {iter}({int} {ea}=0;{la};1)'{'\n";
f+="            {if} (!({ant103}).{call}({ant101}[{ea}], {ant102}[{ea}]))'{'\n";
f+="                {return};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="        {var} {d} = {new} {Difference}();\n";
f+="        ({d}).{found}={ant111};\n";
f+="        ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="        {throw} {d};\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({Object}[] {ant111}, {Fct}<?,{boolean}> {ant112})'{'\n";
f+="        {for}({var} {ea}:{ant111})'{'\n";
f+="            {if} (!({ant112}).{call}({ea}))'{'\n";
f+="                {return};\n";
f+="            '}'\n";
f+="        '}'\n";
f+="        {var} {d} = {new} {Difference}();\n";
f+="        ({d}).{found}={ant111};\n";
f+="        ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="        {throw} {d};\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({Object} {an101}, {Object} {an102}, {Fct}<?,?,{boolean}> {an103})'{'\n";
f+="        {if} (({an103}).{call}({an101}, {an102}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{expected}={an101};\n";
f+="            ({d}).{found}={an102};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="    {public} {static} {void} {assertNot}({Object} {an111}, {Fct}<?,{boolean}> {an112})'{'\n";
f+="        {if} (({an112}).{call}({an111}))'{'\n";
f+="            {var} {d} = {new} {Difference}();\n";
f+="            ({d}).{foundNotTrue}={true};\n";
f+="            ({d}).{found}={an111};\n";
f+="            ({d}).{stackDiff} = {static}({Stack}).{current}();\n";
f+="            {throw} {d};\n";
f+="        '}'\n";
f+="    '}'\n";
f+="'}'\n";
f+="{public} {class} {Difference}'{'\n";
f+="    {public} {Object} {expected};\n";
f+="    {public} {Object} {found};\n";
f+="    {public} {boolean} {foundNull};\n";
f+="    {public} {boolean} {foundNotTrue};\n";
f+="    {public} {Stack}[] {stackDiff};\n";
f+="    {public} {String} {toSpecString}()'{'\n";
f+="        {var} {out} = {new} {StringBuilder}();\n";
f+="        {for} ({var} {s}: {this}.{stackDiff})'{'\n";
f+="            ({out}).{append}({static}({StringUtil}).{valueOf}({s}));\n";
f+="        '}'\n";
f+="        {if} ({this}.{foundNotTrue})'{'\n";
f+="            ({out}).{insert}(0,\"\\n\");\n";
f+="            ({out}).{insert}(0,{static}({StringUtil}).{valueOf}({this}.{found}));\n";
f+="            {return} ({out}).{toString}();\n";
f+="        '}'\n";
f+="        {if} ({this}.{foundNull})'{'\n";
f+="            ({out}).{insert}(0,\"\\n\");\n";
f+="            ({out}).{insert}(0,{static}({StringUtil}).{valueOf}({null}));\n";
f+="            {return} ({out}).{toString}();\n";
f+="        '}'\n";
f+="        ({out}).{insert}(0,\"\\n\");\n";
f+="        ({out}).{insert}(0,{static}({StringUtil}).{valueOf}({this}.{found}));\n";
f+="        ({out}).{insert}(0,\"!=\");\n";
f+="        ({out}).{insert}(0,{static}({StringUtil}).{valueOf}({this}.{expected}));\n";
f+="        {return} ({out}).{toString}();\n";
f+="    '}'\n";
f+="'}'\n";
f+="{public} {class} {EltDifference}:{Difference}'{'\n";
f+="    {public} {int} {index};\n";
f+="    {public} {String} {toSpecString}()'{'\n";
f+="        {var} {out} = {new} {StringBuilder}();\n";
f+="        ({out}).{append}({index});\n";
f+="        ({out}).{append}(\":\");\n";
f+="        ({out}).{append}({super}.{toSpecString}());\n";
f+="        {return} ({out}).{toString}();\n";
f+="    '}'\n";
f+="'}'\n";
return f;
}
static String resourcesLgThreadsFormatting(){
String f="{public} {abstract} {final} {class} {Format} '{'\n";
f+="    {public} {static} {void} {print}({Object} {fo1})'{'\n";
f+="        {static}({Thread}).{print}({static}({StringUtil}).{valueOf}({fo1}));\n";
f+="    '}'\n";
f+="    {public} {static} {void} {print}({String} {fo2},{Object}... {fo3})'{'\n";
f+="        {String}[] {as} = {new} {String}[({fo3}).{length}];\n";
f+="        {for}({var} {e}:{fo3})'{'\n";
f+="            {as}[([{e}])] = {static}({StringUtil}).{valueOf}({e});\n";
f+="        '}'\n";
f+="        {static}({Thread}).{print}(({fo2}).{format}({as}));\n";
f+="    '}'\n";
f+="'}'\n";
return f;
}
static String resourcesLgThreadsRunnable(){
String f="\n";
f+="{public} {interface} {Runnable} '{'\n";
f+="    {public} {abstract} {void} {run}();\n";
f+="'}'\n";
return f;
}
}
