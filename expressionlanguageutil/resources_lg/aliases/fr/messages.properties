EmptyWord={0} a un mot cl&eacute; vide.
NotWordChar={0} contient un caract&egrave;re {1} qui n''est pas un caract&egrave;re de mot.
DigitFirst={0} commence par {1} qui est un chiffre.
EmptyString={0} a un mot cl&eacute; vide sp&eacute;cifique aux chaines.
EmptyNb={0} a un mot cl&eacute; vide sp&eacute;cifique aux nombres.
EmptyBinExp=exponentielle binaire vide
EmptyPreBin=pr&eacute;fixe binaire vide
EmptyPreHex=pr&eacute;fixe hexad&eacute;cimal vide
IllegalChar=le mot cl&eacute; num&eacute;rique {0} contient un caract&egrave;re {1} qui est ill&eacute;gal.
IllegalFirstChar=le mot cl&eacute; num&eacute;rique {0} commence par {1} qui est ill&eacute;gal en tant que premier caract&egrave;re
EmptyPrimitive={0} a une valeur de type primitive vide.
NotWordCharPrimitive={0} contient un caract&egrave;re {1} qui n''est pas un caract&egrave;re de mot.
PrimitiveKeyWord=la primitive {0}:{1} est une chaine doublon d''un mot cl&eacute;.
DigitFirstPrimitive={0} commence par {1} qui est un chiffre.
EmptyRefType={0} a une valeur de type r&eacute;f&eacute;rence vide.
EmptyRefTypeIn={0} a une valeur de type r&eacute;f&eacute;rence vide entre deux points {1}.
NotWordCharRefType={0} contient un caract&egrave;re {1} qui n''est pas un caract&egrave;re de mot.
RefTypeKeyWord=le type r&eacute;f&eacute;rence {0}:{1} contient une chaine doublon d''un mot cl&eacute;.
RefTypePrimitive=le type r&eacute;f&eacute;rence {0}:{1} contient une chaine doublon d''une primitive.
DigitFirstRefType={0} commence par {1} qui est un chiffre.
EmptyPkgRefType={0}:{1} n''appartient pas &agrave; un paquetage.
DefaultPkgRefType={0} correspond au paquetage par d&eacute;faut {1}.
DefaultPkgNoMatch=le paquetage par d&eacute;faut {0} n''a pas de type r&eacute;f&eacute;rence.
EmptyMethod=la m&eacute;thode cl&eacute; {0} dans le type r&eacute;f&eacute;rence {1} a un nom vide.
NotWordCharMethod=le nom de m&eacute;thode {0} dans le type r&eacute;f&eacute;rence {1} contient un caract&egrave;re {2} qui n''est pas un caract&egrave;re de mot.
MethodKeyWord=le nom de m&eacute;thode {0} dans le type r&eacute;f&eacute;rence {1}:{2} est une chaine doublon d''un mot cl&eacute;.
MethodPrimitive=le nom de m&eacute;thode {0} dans le type r&eacute;f&eacute;rence {1}:{2} est une chaine doublon d''une primitive.
DigitFirstMethod=le nom de m&eacute;thode {0} dans le type r&eacute;f&eacute;rence {1} commence par {2} qui est un chiffre.
EmptyField=le champ cl&eacute; {0} dans le type r&eacute;f&eacute;rence {1} a un nom vide.
NotWordCharField=le nom de champ {0} dans le type r&eacute;f&eacute;rence {1} contient a caract&egrave;re {2} qui n''est pas un caract&egrave;re de mot.
FieldKeyWord=le nom de champ {0} dans le type r&eacute;f&eacute;rence {1}:{2} est une chaine doublon d''un mot cl&eacute;.
FieldPrimitive=le nom de champ {0} dans le type r&eacute;f&eacute;rence {1}:{2} est une chaine doublon d''une primitive.
DigitFirstField=le nom de champ {0} dans le type r&eacute;f&eacute;rence {1} commence par {2} qui est un chiffre.
EmptyVarType=le type variable cl&eacute; {0} dans le type r&eacute;f&eacute;rence {1} a un nom vide.
NotWordCharVarType=le nom de type variable {0} dans le type r&eacute;f&eacute;rence {1} contient a caract&egrave;re {2} qui n''est pas un caract&egrave;re de mot.
VarTypeKeyWord=le nom de type variable {0} dans le type r&eacute;f&eacute;rence {1}:{2} est une chaine doublon d''un mot cl&eacute;.
VarTypePrimitive=le nom de type variable {0} dans le type r&eacute;f&eacute;rence {1}:{2} est une chaine doublon d''une primitive.
DigitFirstVarType=le nom de type variable {0} dans le type r&eacute;f&eacute;rence {1} commence par {2} qui est un chiffre.
DuplicateKeyWord={0} est dupliqu&eacute; en tant que mot cl&eacute;.
DuplicateStringWord={0} est dupliqu&eacute; en tant que &eacute;chappement dans une chaine.
DuplicateStarting=le mot d''&eacute;chappement {0} commence par le mot d''&eacute;chappement {1}.
DuplicateStartingUni=le mot d''&eacute;chappement {0} commence par le caract&egrave;re unicode d''&eacute;chappement {1}.
DuplicateNumberWord={0} est dupliqu&eacute; en tant que mot dans un nombre.
DuplicateStartingNb=le mot dans un nombre {0} commence par le mot dans un nombre {1}.
DuplicatePrimtive=la primitive {0} est dupliqu&eacute;.
DuplicateRefType=le type r&eacute;f&eacute;rence {0} est dupliqu&eacute;.
DuplicateMethod=le nom de m&eacute;thode {0} est dupliqu&eacute;.
DuplicateField=le nom de champ {0} est dupliqu&eacute;.
DuplicateVarType=le nom de type variable {0} est dupliqu&eacute;.
DuplicateMergedMethod=le nom de m&eacute;thode fusionn&eacute; {0}:{1} est dupliqu&eacute;.
AbstractMethodBody=La m&eacute;thode {1} dans le type {0} est abstraite et ne peut pas avoir de corps.
AbstractMethodConc=La m&eacute;thode {1} dans le type concret {0} ne doit pas &ecirc;tre abstraite.
AbstractMethodImpl=La m&eacute;thode {1} provenant du type {0} doit &ecirc;tre red&eacute;finie dans le type concret {2}.
AbstractMethodRef=La m&eacute;thode {1} provenant du type {0} ne doit pas &ecirc;tre appel&eacute;e directement &agrave; de son abstraction.
InaccessibleType=Le type {0} n''est pas accessible depuis le type {1}.
UnexpectedType=Le type {0} est inattendu.
MethodsAccesses=La m&eacute;thode {1} provenant du type {0} est strictement plus accessible que la m&eacute;thode {3} provenant du type {2}.
EmptyPackage=Un type doit avoir un paquetage non vide.
EmptyPartClassName=La partie ne doit pas &ecirc;tre vide.
BadPartClassName=La partie {0} dans un type n''est pas valide. Elle doit &ecirc;tre un mot qui n''est pas un mot cl&eacute;, ni un type primitif. De plus, elle ne doit pas commencer par un chiffre.
BadPartVarClassName=La partie {0} dans un type variable n''est pas valide. Elle doit &ecirc;tre un mot qui n''est pas un mot cl&eacute;, ni un type primitif. De plus, elle ne doit pas commencer par un chiffre.
CallCtorEnd=L''appel d''un constructeur passant l''instance implicitement doit &ecirc;tre effectu&eacute; &agrave; la fin de l''instruction.
CallCtor=L''appel d''un constructeur passant l''instance implicitement doit &ecirc;tre effectu&eacute; dans un constructeur.
CallCtorBeforeBlock=L''appel d''un constructeur passant l''instance implicitement doit &ecirc;tre effectu&eacute; avant un bloc d''instructions.
CallCtorFirstLine=L''appel d''un constructeur du type ou de la super classe passant l''instance implicitement doit &ecirc;tre effectu&eacute; sur la premi&egrave;re ligne.
CallCtorIntFromSuperInt=L''appel d''un constructeur d''interface doit r&eacute;f&eacute;rencer une super interface du type appelant.
CallCtorIntNotFromInt=L''appel d''un constructeur d''interface ne doit pas &ecirc;tre fait dans un constructeur d''interface.
CallCtorIntAfterSuperThis=Un appel d''un constructeur d''interface ne peut &ecirc;tre effectu&eacute; qu''apr&egrave;s un appel de constructeur passant l''instance implicitement.
CallCtorIntInherits=L''appel du constructeur de l''interface {0} ne peut pas &ecirc;tre effectu&eacute; avant l''appel du constructeur de l''interface {1}.
CallCtorSuperClassEnumSingleton=Le super constructeur ne peut &ecirc;tre appel&eacute; que depuis une classe ou une enum&eacute;ration (singleton ou normale).
AnnotFieldNotUniq=Le champ de l''annotatation n''a pas &ecirc;tre trouv&eacute; de mani&egrave;re unique.
AnnotFieldMust=Le champ {0} de l''annotatation est obligatoire.
DupSuppliedAnnotField=Le champ {0} de l''annotatation est fourni en doublon.
BadExpression=Caract&egrave;re inattendu {0} &agrave; la position {1} dans l''expression {2}
BadFieldName=Le nom de champ {0} n''est pas valide. Il doit &ecirc;tre un mot qui n''est pas un mot cl&eacute;, ni un type primitif. De plus, il ne doit pas commencer par un chiffre.
NotRetrievedFields=Aucun champ n''a pas &ecirc;tre r&eacute;cup&eacute;r&eacute;.
BadNbFormat=Mauvais format de nombre {0}
BadCharFormat=Mauvais format de caract&egrave;re {0}
BadImplicitCast=Le type {0} ne peut pas &ecirc;tre implicitement converti en {1}
NotPrimitiveWrapper=Le type {0} n''est pas un type primitive ou un type enveloppeur.
VoidType=Le type ne peut pas &ecirc;tre le mot cl&eacute; {0}.
BadIndexInParser=Mauvais indice en parsant.
IllegalCharacter=Les caract&egrave;res ascii {0} sont ill&eacute;gaux.
CallIntInherits=Initialiser l''interface {0} ne peut pas &ecirc;tre effectu&eacute; avant d''initialiser l''interface {1}.
CallIntNoNeed=Initialiser un type depuis l''interface {0} n''est pas n&eacute;cessaire.
CallIntNoNeedType=Initialiser l''interface {0} depuis le type {1} n''est pas n&eacute;cessaire.
CallIntNeedType=Initialiser l''interface {0} depuis le type {1} est n&eacute;cessaire.
CallIntOnly=Le type {0} n''est pas une interface.
BadInheritsType=Le type {0} ne peut pas avoir le type {1} en tant que super type.
BadInheritsTypeInn=Le type {0} ne peut pas avoir le type {1} en tant que super type parce que {1} est un type d''instance.
BadInheritsTypeAsInn=Le type {0} ne peut pas avoir le type {1} en tant que super type parce que {1} est un type d''instance.
BadInheritsTypeInt=Le type {0} ne peut pas avoir le type {1} en tant que super type parce que {1} n''est pas une interface.
FinalType=Le type {0} ne peut pas avoir le type {1} en tant que super type parce que {1} est final.
DuplicateSuper=Le type {0} ne peut pas avoir le type {1} duplicated en tant que super type {2} fois.
ReservedType=Le type {0} ne peut pas avoir explicitement le the type {1} en tant que super type parce que {1} est r&eacute;serv&eacute;.
SuperClass=La classe {0} ne peut pas avoir plus d''une super classe ({1} fois).
UnknownSuperType=Les super types du type static {0} n''ont pas pu &ecirc;tre trouv&eacute;s.
CyclicInherits=Le type {0} appartient &agrave; un h&eacute;ritage cyclique.
AnnotationParam=L''annotation {0} ne peut pas &ecirc;tre param&eacute;tr&eacute;e.
CyclicMapping=Les types variables du type {0} ont un h&eacute;ritage cyclique.
AbsMapping=Il y a {0} types abstraits en tant que bornes sup&eacute;rieures.
FinalMapping=Il y a au moins un type final en tant que borne sup&eacute;rieure ({0} fois).
MustCallIntCtor=Le type {0} doit avoir un constructeur vu l''implementation d''interfaces avec des &eacute;l&eacute;ments d''instance.
MustNotCallIntCtorAfterThis=Il ne doit pas y avoir un appel de constructor apr&egrave;s un appel de constructor alternatif.
MustCallIntCtorNeed=Un constructor du type {0} doit &ecirc;tre appel&eacute; dans le constructeur.
MustCallIntCtorNotNeed=Un constructor du type {0} ne doit pas &ecirc;tre appel&eacute; dans le constructeur.
BadLabel=Un &eacute;tiquette doit &ecirc;tre un mot (pouvant inclure des caract&egrave;res dollars).
DuplicatedLabel=L''&eacute;tiquette est dupliqu&eacute;e.
BadMethodName=Le nom de m&eacute;thode {0} n''est pas valide. Il doit &ecirc;tre un mot qui n''est pas un mot cl&eacute;, ni un type primitif. De plus, il ne doit pas commencer par un chiffre.
BadOperatorName=Le symbole d''op&eacute;rateur {0} n''est pas valide.
BadAccess=La m&eacute;thode {0} doit &ecirc;tre publique.
BadReturnType=La m&eacute;thode {0} doit avoir {1} as return type.
BadParams=La m&eacute;thode {0} doit avoir un param&egrave;tre.
BadMethodModifier=La m&eacute;thode {0} doit &ecirc;tre statique.
BadMethodVararg=La m&eacute;thode {0} ne doit pas &ecirc;tre avec un nombre d''argument variable.
BadIndexerParams=L''indexeur {0} doit avoir au moins un param&egrave;tre.
BadIndexerModifier=L''indexeur {0} ne doit pas &ecirc;tre static.
BadIndexerModifiers=Les indexeurs {0} lecture et &eacute;criture doivent avoir le m&ecirc;me modificateur.
BadIndexerAccesses=Les indexeurs {0} lecture et &eacute;criture doivent avoir le m&ecirc;me acc&egrave;s.
BadIndexerPairGet=L''indexeur {0} lecture doit &ecirc;tre defini.
BadIndexerPairSet=L''indexeur {0} &eacute;criture doit &ecirc;tre defini.
DuplicateCustomMethod=La m&eacute;thode {0} est dupliqu&eacute;e.
ReservedCustomMethod=La m&eacute;thode {0} est r&eacute;serv&eacute;e.
DuplicateIndexer=L''indexeur {0} est dupliqu&eacute;.
DuplicateOperator=L''op&eacute;rateur {0} est dupliqu&eacute;.
FunctionalApplyNbDiff=Le nombre d''arguments obligatoires {0} est diff&eacute;rent du nombre d''arguments fournis {1} pour la m&eacute;thode du type elliptique {2}
FunctionalApplyOnly=Seule la m&eacute;thode {0} peut &ecirc;tre utilis&eacute;e pour le type elliptique {1}
OperatorNbDiff=Le nombre d''op&eacute;randes obligatoires {0} est diff&eacute;rent du nombre d''op&eacute;randes fournis {1} pour l''op&eacute;rateur {2}
SplitComa=Le nombre de parties obligatoires s&eacute;par&eacute;es par virgules {0} est sup&eacute;rieur au nombre de parties fournies s&eacute;par&eacute;es par virgules {1}.
SplitComaLow=Le nombre de parties obligatoires s&eacute;par&eacute;es par virgules {0} est inf&eacute;rieur au nombre de parties fournies s&eacute;par&eacute;es par virgules {1}.
SplitDiff=Le nombre d''op&eacute;randes obligatoires {0} est diff&eacute;rent du nombre d''op&eacute;randes fournis {1}.
BadDotted=La partie de code suivant l''op&eacute;rateur point ne peut pas &ecirc;tre utilis&eacute;e.
BadParamName=Le nom de param&egrave;tre m&eacute;thode {0} n''est pas valide. Il doit &ecirc;tre un mot qui n''est pas un mot cl&eacute;, ni un type primitif. De plus, il ne doit pas commencer par un chiffre.
ReservedParamName=Le nom de param&egrave;tre m&eacute;thode {0} est r&eacute;serv&eacute; pour un indexeur &eacute;criture.
DuplicatedParamName=Le nom de param&egrave;tre fonction {0} est dupliqu&eacute;.
BadReturnTypeInherit=Le type de retour {0} de la m&eacute;thode {1} du type {2} n''est pas sous type du type de retour {3} de la m&eacute;thode {4} du type {5}
BadReturnTypeIndexer=Le type de retour {0} de l''indexer {1} du type {2} n''est pas le type de retour {3} de l''indexer {4} du type {5}
DuplicatedOverriding=Le type {0} h&eacute;rite une fonction {1} qui est dupliqu&eacute;e.
TwoFinal=Le type {0} h&eacute;rite deux fonctions finales de cl&eacute; {1}.
FinalNotSubReturnType=Le type de retour {0} de la m&eacute;thode finale {1} du type {2} n''est pas sous type du type de retour {3} de la m&eacute;thode {4} du type {5}
TwoReturnTypes=Les m&eacute;thodes fusionn&eacute;es avec pour cl&eacute; {0} des types {1} ont pour sous types {2} en tant que types de retour.
ReturnTypes=Les indexeurs avec pour cl&eacute; {0} des types {1} ont pour types {2} en tant que types de retour.
BadVariableName=Le nom de variable {0} n''est pas valide. Il doit &ecirc;tre un mot qui n''est pas un mot cl&eacute;, ni un type primitif. De plus, il ne doit pas commencer par un chiffre. Il ne doit pas &ecirc;tre le nom d''une autre variable du scope.
CyclicCtorCall=Les constructeurs {0} du type {1} appartiennent &agrave; des appels cycliques.
DeadCode=Le code est inatteignable dans la fonction {0}
DuplicatedCtor=Le constructeur {0} est dupliqu&eacute;.
DuplicatedGenericSuperTypes=Les super types g&eacute;n&eacute;riques {0} sont dupliqu&eacute;s.
DuplicatedInnerType=Le simple nom du type interne {0} est dupliqu&eacute;.
DuplicatedType=Le nom du type {0} est dupliqu&eacute; avec un autre type client.
DuplicatedTypePrim=Le nom du type {0} est dupliqu&eacute; avec un type primitif.
DuplicatedTypeStd=Le nom du type {0} est dupliqu&eacute; avec un type standard.
DuplicatedTypePkg=Le nom du type {0} est masqu&eacute; par le paquetage {1}.
EmptyExpressionPart=La partie d''expression est vide.
DoWhileNotEmpty=Le bloc {0} associ&eacute; &agrave; un bloc {1} doit &ecirc;tre vide.
DuplicatedFinal=La fonction {0} du type {1} est finale. Donc la red&eacute;finir est interdit.
IllegalCtorEnum=Un constructeur d''une &eacute;num&eacute;ration ne peut pas &ecirc;tre appel&eacute;e explicitement.
IllegalGenericSuperTypeBound=L''argument {0} du super type g&eacute;n&eacute;rique {1} est une borne. Il ne peut pas &ecirc;tre utilis&eacute; dans un super type g&eacute;n&eacute;rique.
IllegalCtorAnnotation=Apr&egrave;s @ le type {0} n''est pas une annotation.
IllegalCtorAbstract=Le type {0} cannot be instantiated because of abstract.
IllegalCtorBound=L''argument {0} du type {1} est une borne. Il ne peut pas &ecirc;tre utilis&eacute; dans un appel de constructeur.
IllegalCtorArray=Le type {0} is an array type. Il ne peut pas &ecirc;tre utilis&eacute; en tant qu''argument pr&eacute;c&eacute;de d''un point pour instancier.
IllegalCtorUnknown=Le type {0} n''est pas r&eacute;solu pour instancier.
MissingAbrupt=Un bloc {0} ou un bloc {1} est manquant pour la m&eacute;thode {2}.
NotInitClass=Le type {0} n''est pas initialis&eacute;.
NullValue=La valeur ne doit pas &ecirc;tre nulle &agrave; de possibles {0}.
BadParameTypeForId=Le type de param&egrave;tre {0} n''est pas r&eacute;solu pour obtenir l''identit&eacute; d''une fonction.
NotResolvedOwner=Le possesseur pour le type {0} n''est pas r&eacute;solu pour instancier.
UndefinedAccessibleField=Il n''y pas de champ accessible nomm&eacute; {0} depuis le type {1} dans ce contexte.
StaticAccess=Le context est statique. Le mot cl&eacute; {0} ne peut pas &ecirc;tre utilis&eacute; dans ce contexte.
StaticAccessPrev=Un type doit &ecirc;tre utilis&eacute; pour acc&eacute;der au mot cl&eacute; {0}.
UnassignedFinalField=Le champ {0} du type {1} n''est pas assign&eacute; par une constante.
UnassignedInferingType=Le type d''inf&eacute;rence type {0} n''est pas d&eacute;fini pour les variables {1}.
UndefinedCtor=Le constructeur {0} est ind&eacute;fini.
UndefinedMethod=La m&eacute;thode {0} est ind&eacute;finie.
ArrayCloneOnly=Seule la m&eacute;thode {0} peut &ecirc;tre utilis&eacute;e pour le type tableau {1}
UndefinedSuperCtor=Aucun super constructeur &agrave appel implicite n''est defin&eacute; et accessible. Il doit y avoir au moins un constructeur pour le type {0}
UndefinedSuperCtorCall=Aucun super constructeur &agrave appel implicite n''est defin&eacute; et accessible. L''appel explicite d''un super constructeur est obligatoir pour le constructeur {0}.
UndefinedVariable=La variable {0} est ind&eacute;finie dans ce contexte.
UnexpectedAffect=L''op&eacute;rateur d''assignement {0} est inattendu.
FinalField=Le champ {0} est d&eacute;j&agrave; assign&eacute;.
BadOperatorRef=La chaine {0} n''est pas une r&eacute;f&eacute;rence d''op&eacute;rateur.
UnexpectedCatchElseFinally=Le bloc {0} doit &ecirc;tre pr&eacute;c&eacute;d&eacute; par un des blocs {1}.
UnexpectedAbrupt=Le bloc {0} doit &ecirc;tre interne aux blocs {1}.
UnexpectedAbruptLab=Le bloc {0} avec &eacute;tiquette {1} doit &ecirc;tre interne &agrave; un bloc &eacute;tiquet&eacute; avec {1}.
UnexpectedCaseDef=Le bloc {0} avec expression {1} doit &ecirc;tre un enfant d''un bloc {2}.
UnexpectedCaseVar=Le bloc {0} avec expression {1} n''est pas constant.
UnexpectedCaseValue=Le bloc {0} avec valeur {1} n''est pas un sous type de {2}.
UnexpectedCaseDup=Le bloc {0} avec valeur {1} est dupliqu&eacute; in the parent {2} block.
UnexpectedDefDup=Le bloc {0} est dupliqu&eacute; dans le bloc parent {1}.
UnexpectedDoTry=Le bloc {0} doit &ecirc;tre suivi d''un des blocs {1}.
UnexpectedSwitch=Le bloc {0} doit contenir seulement un des blocs {1}.
UnexpectedMemberInst=Le type d''instance {0} doit contenir seulement des types d''instance et des blocs initialisateurs d''instance.
UnexpectedBlockExp=Le bloc est inattendu.
UnexpectedOperandTypes=Les types {0} des op&eacute;randes pour l''op&eacute;rateur {1} sont inattendus.
UnknownType=Le type {0} est inconnu.
BadParamerizedType=Le type {1} n''est pas correctement param&eacute;tr&eacute;.
UnexpectedTypeBound=Le type {0} est inattendu pour une borne.
UnexpectedVararg=Les trois points sont inattendu ici.
UnexpectedLeaf=Le mot cl&eacute; {0} est inattendu ici.