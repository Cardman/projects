		/*for (Coords k: dataMap_.getAccessibility().keySet()) {
			if (!k.isInside()) {
				System.out.println("assertEquals("+dataMap_.getAccessibility().getVal(k).size()+", dataMap_.getAccessibility().getVal(coords("+k.getNumberPlace()+", "+k.getLevel().getLevelIndex()+", "+k.getLevel().getPoint().getx()+", "+k.getLevel().getPoint().gety()+")).size());");
				for (Coords c: dataMap_.getAccessibility().getVal(k)) {
					if (!c.isInside()) {
						System.out.println("assertTrue(dataMap_.getAccessibility().getVal(coords("+k.getNumberPlace()+", "+k.getLevel().getLevelIndex()+", "+k.getLevel().getPoint().getx()+", "+k.getLevel().getPoint().gety()+")).containsObj(coords("+c.getNumberPlace()+", "+c.getLevel().getLevelIndex()+", "+c.getLevel().getPoint().getx()+", "+c.getLevel().getPoint().gety()+")));");
					} else {
						System.out.println("assertTrue(dataMap_.getAccessibility().getVal(coords("+k.getNumberPlace()+", "+k.getLevel().getLevelIndex()+", "+k.getLevel().getPoint().getx()+", "+k.getLevel().getPoint().gety()+")).containsObj(coords("+c.getNumberPlace()+", "+c.getInsideBuilding().getx()+", "+c.getInsideBuilding().gety()+", "+c.getLevel().getPoint().getx()+", "+c.getLevel().getPoint().gety()+")));");
					}
				}
			} else {
				System.out.println("assertEquals("+dataMap_.getAccessibility().getVal(k).size()+", dataMap_.getAccessibility().getVal(coords("+k.getNumberPlace()+", "+k.getInsideBuilding().getx()+", "+k.getInsideBuilding().gety()+", "+k.getLevel().getPoint().getx()+", "+k.getLevel().getPoint().gety()+")).size());");
				for (Coords c: dataMap_.getAccessibility().getVal(k)) {
					if (!c.isInside()) {
						System.out.println("assertTrue(dataMap_.getAccessibility().getVal(coords("+k.getNumberPlace()+", "+k.getInsideBuilding().getx()+", "+k.getInsideBuilding().gety()+", "+k.getLevel().getPoint().getx()+", "+k.getLevel().getPoint().gety()+")).containsObj(coords("+c.getNumberPlace()+", "+c.getLevel().getLevelIndex()+", "+c.getLevel().getPoint().getx()+", "+c.getLevel().getPoint().gety()+")));");
					} else {
						System.out.println("assertTrue(dataMap_.getAccessibility().getVal(coords("+k.getNumberPlace()+", "+k.getInsideBuilding().getx()+", "+k.getInsideBuilding().gety()+", "+k.getLevel().getPoint().getx()+", "+k.getLevel().getPoint().gety()+")).containsObj(coords("+c.getNumberPlace()+", "+c.getInsideBuilding().getx()+", "+c.getInsideBuilding().gety()+", "+c.getLevel().getPoint().getx()+", "+c.getLevel().getPoint().gety()+")));");
					}
				}
			}
		}*/

//		for (Coords c: dataMap_.getAccessibility().keySet()) {
//			Condition c_ = dataMap_.getAccessibility().getVal(c);
//			String coords_ = c.getNumberPlace()+", "+c.getLevel().getLevelIndex()+", ";
//			coords_ += c.getLevel().getPoint().getx()+", ";
//			coords_ += c.getLevel().getPoint().gety();
////			if (c_.size() == 1) {
////				System.out.println(c+" "+c_);
////			}
//			System.out.println("\t\tassertEquals("+c_.size()+", dataMap_.getAccessibility().getVal(coords("+coords_+")).size());");
//			for (Coords a: c_) {
//				String coords2_ = a.getNumberPlace()+", "+a.getInsideBuilding().getx()+", "+a.getInsideBuilding().gety()+", ";
//				coords2_ += a.getLevel().getPoint().getx()+", ";
//				coords2_ += a.getLevel().getPoint().gety();
//				System.out.println("\t\tassertTrue(dataMap_.getAccessibility().getVal(coords("+coords_+")).containsObj(coords("+coords2_+")));");
//			}
//		}



	//TODO List instead of array
	List<Object> getVars(String _token, String _language) {
		Map<String,String> litt_ = litterals.getVal(_language);
		String tok_ = _token.substring(VAR_PREFIX.length());
		StringList elts_ = new StringList(tok_.split(SEP_BETWEEN_KEYS));
		String line_ = litt_.getVal(elts_.first());
		StringList infos_ = new StringList(line_.split(TAB));
		String type_ = infos_.get(0);
		StringList types_ = new StringList(type_.split(NumericString.SEPARATOR_SET));
		//Object[] obj_ = elts_.toArray();
		List<Object> objDisplay_ = new List<>();
//		int len_ = obj_.length;
		int len_ = elts_.size();
		for (int j = List.SECOND_INDEX; j < len_; j++) {
			if (types_.get(j - 1).equals(MOVE_FORMULA)) {
				objDisplay_.add(translatedMoves.getVal(_language).getVal(elts_.get(j).toString()));
			}
			if (types_.get(j - 1).equals(CAT_FORMULA)) {
				objDisplay_.add(translatedCategories.getVal(_language).getVal(elts_.get(j).toString()));
			}
			if (types_.get(j - 1).equals(STATIS_FORMULA)) {
				objDisplay_.add(translatedStatistics.getVal(_language).getVal(Statistic.valueOf(elts_.get(j).toString())));
			}
			if (types_.get(j - 1).equals(STATUS_FORMULA)) {
				objDisplay_.add(translatedStatus.getVal(_language).getVal(elts_.get(j).toString()));
			}
			if (types_.get(j - 1).equals(TYPE_FORMULA)) {
				objDisplay_.add(translatedTypes.getVal(_language).getVal(elts_.get(j).toString()));
			}
		}
//		for (int j = List.SECOND_INDEX; j < len_; j++) {
//			if (types_.get(j - 1).equals(MOVE_FORMULA)) {
//				objDisplay_[j - 1] = translatedMoves.getVal(_language).getVal(obj_[j].toString());
//			}
//			if (types_.get(j - 1).equals(CAT_FORMULA)) {
//				objDisplay_[j - 1] = translatedCategories.getVal(_language).getVal(obj_[j].toString());
//			}
//			if (types_.get(j - 1).equals(STATIS_FORMULA)) {
//				objDisplay_[j - 1] = translatedStatistics.getVal(_language).getVal(Statistic.valueOf(obj_[j].toString()));
//			}
//			if (types_.get(j - 1).equals(STATUS_FORMULA)) {
//				objDisplay_[j - 1] = translatedStatus.getVal(_language).getVal(obj_[j].toString());
//			}
//			if (types_.get(j - 1).equals(TYPE_FORMULA)) {
//				objDisplay_[j - 1] = translatedTypes.getVal(_language).getVal(obj_[j].toString());
//			}
//		}
		return objDisplay_;
	}


formathtml 
		//TODO disabled attribute for input and select (==> not available) DONE
//ConverterBufferedImage TODO switch names with Stream...Image (move some methods)
//TODO check html with escaped attribute and properties with & character, attributes with &
//TODO see _event.getInputEvent();


________________________________________________________

//TODO coverage belote annonce points
				@Test
				public void compare_GameStrengthLowHandBelote2Test() {
				Map<Suit,HandBelote> hand_;
				hand_ = new Map<>();
				HandBelote suit_ = new HandBelote();
				suit_.ajouter(CardBelote.DIAMOND_1);
				suit_.ajouter(CardBelote.DIAMOND_10);
				hand_.put(Suit.DIAMOND, suit_);
				suit_ = new HandBelote();
				suit_.ajouter(CardBelote.HEART_JACK);
				suit_.ajouter(CardBelote.HEART_9);
				hand_.put(Suit.HEART, suit_);
				suit_ = new HandBelote();
				hand_.put(Suit.SPADE, suit_);
				hand_.put(Suit.CLUB, suit_);
				BidBeloteSuit bid_ = new BidBeloteSuit();
				bid_.setCouleur(Suit.HEART);
				bid_.setEnchere(BidBelote.SUIT);
				List<Suit> suits_ = Suit.couleursOrdinaires();
				suits_.sort(new GameStrengthLowHandBeloteComparator(hand_, bid_));
				assertEquals(4, suits_.size());
				assertEquals(Suit.SPADE, suits_.get(0));
				assertEquals(Suit.CLUB, suits_.get(1));
				assertEquals(Suit.HEART, suits_.get(2));
				assertEquals(Suit.DIAMOND, suits_.get(3));
				}

		//TODO dynamic translation menus cards
//TODO gear setResizable(false); main window

//TODO avoid Small as first played card in a trick.

//TODO 9 d'atout seul game belote called player
//TODO hypotheses

//TODO confidence called played (some calls) tarot hypothesesRepartitionsJoueurs
//TODO tarot master at trump suit
//TODO Defender, taker tarot cartes appelees de la couleur c toutes jouees

//TODO ajouter le code manquant "s'il existe une couleur avec carte rel maitre sur l'appele" excuse begin trick
//TODO tester code et attention a carteAppeleeJouee excuse begin trick x 2

		GameState Contrat,/*Fin_Contrat,*/Appel,Avant_Ecart,Ecart,Chien_Vu,Avant_Jeu,Avant_Jeu2,Jeu
//TODO plusieurs appels possibles test tarot
//TODO attention chelem tarot

//TODO search why pack infinite loop

//TODO c1_vs_2(3,5,new int[]{3,3},new int[]{3})
//TODO c1_vs_1(2,8,new int[]{3,3,2},new int[]{4})

//TODO exit game multi cards


____________________________________________________________________________

Test all cases while skip evolutions.

	//TODO mini map and other city linked accessible to the cave after the league; initialize in other method
	//TODO nickname fields
	//TODO check validity flee rate pokemon
	//TODO forms with free teams
//TODO title game
//TODO validate each element ref remove ref with comment: //validate
	//TODO assertion nextFight FightSimulation
	//TODO errors messages loading file + successful load rom
	//TODO keypad,
//TODO filter by nickname, display nickname box,						 html fighter and pokemon player
//TODO area walk some issue pokemon
//TODO animation and menus

			//game.getInterfaceType() == InterfaceType.PERSONNAGE && gym
			//TODO message for beat all trainers in a gym
			//TODO test nextFight FightSimulation
//TODO use the method for simulating laws for a move used by a pokemon against an other pokemon (damage)
//TODO change getStatus().put(...,(short)1) ==> affecterStatut(...)
			//TODO message for ally chooseBackFighterAddon
//TODO if wild fight nbActions_ is not checked playable before round
//TODO messages

static void effectStatus(Fight _fight,TeamPosition _lanceur,TeamPosition _cible,EffectStatus _effet,Difficulty _diff,DataBase _import){
if(_effet.getStatusFromUser()){
for(String e:statutsTranferes_){
creatureCible_.affecterStatut(e);
//TODO _fight.setAnimationStatus(e);
static void synchronizeStatus(Fight _fight,TeamPosition _lanceur,TeamPosition _cible,Map<String,String> _echecStatuts,Map<String,String> _echecStatutsAb,DataBase _import){
for(String e:_fight.getSufferingTargetStatus()){
if(effet_.getWeddingAlly()){
//TODO _fight.setAnimationStatus(e);

//TODO affectStatusToThrower _fight.setAnimationStatus(_status);

//TODO enable/disable pad after pack window pokemon
//TODO disable all inputs while a round (before facade) (, re enable after a round opt because of refresh) 
//TODO errors if out index fighterPanel.getSelectedIndex() evolutions
//TODO ball animation
//TODO animation switch places (switch between front pk)
//TODO delete koFighter at begin front battle

DataBase: validate
if (move_.getNbPrepaRound() > 0 && !move_.getDisappearBeforeUse()) {
continue;//TODO create moves and remove
}
//			if (move_.getNbPrepaRound() > 0) {
//				continue;
//			}

//TODO FightFacadeTest add firstPositPlayerFighters firstPositFoeFighters
//TODO currentUser validation fight test
//TODO possibility to catch a wild pk while the fight is not ended.
//TODO impossible target team valid tests
//	@Test
//	@Parameters(method="sex")
//	public void isValid47Test(Sex _sex) {
//		Game game_ = newGameInFightTrainer(_sex);
//		Team team_ = game_.getFight().getUserTeam();
//		Map<Byte,Anticipation> map_;
//		map_ = new Map<Byte,Anticipation>();
//		map_.put((byte) 0, new Anticipation());
//		map_.getVal((byte) 0).setTargetPosition(POKEMON_FOE_TARGET_TWO);
//		team_.getMovesAnticipation().put("PRESCIENCE", map_);
//		assertTrue(!team_.isValid(data, Fight.PLAYER, game_.getFight()));
//	}
//
//	@Test
//	@Parameters(method="sex")
//	public void isValid48Test(Sex _sex) {
//		Game game_ = newGameInFightTrainer(_sex);
//		Team team_ = game_.getFight().getFoeTeam();
//		Map<Byte,Anticipation> map_;
//		map_ = new Map<Byte,Anticipation>();
//		map_.put((byte) 0, new Anticipation());
//		map_.getVal((byte) 0).setTargetPosition(POKEMON_FOE_TARGET_TWO);
//		team_.getMovesAnticipation().put("PRESCIENCE", map_);
//		assertTrue(!team_.isValid(data, Fight.FOE, game_.getFight()));
//	}

//	@Test
//	@Parameters(method="sex")
//	public void isValid49Test(Sex _sex) {
//		Game game_ = newGameInFightTrainer(_sex);
//		Team team_ = game_.getFight().getUserTeam();
//		Map<Byte,Anticipation> map_;
//		map_ = new Map<Byte,Anticipation>();
//		map_.put((byte) 0, new Anticipation());
//		map_.getVal((byte) 0).setTargetPosition(POKEMON_PLAYER_TARGET_ZERO);
//		team_.getMovesAnticipation().put("PRESCIENCE", map_);
//		assertTrue(!team_.isValid(data, Fight.PLAYER, game_.getFight()));
//	}
//
//	@Test
//	@Parameters(method="sex")
//	public void isValid50Test(Sex _sex) {
//		Game game_ = newGameInFightTrainer(_sex);
//		Team team_ = game_.getFight().getFoeTeam();
//		Map<Byte,Anticipation> map_;
//		map_ = new Map<Byte,Anticipation>();
//		map_.put((byte) 0, new Anticipation());
//		map_.getVal((byte) 0).setTargetPosition(POKEMON_FOE_TARGET_ZERO);
//		team_.getMovesAnticipation().put("PRESCIENCE", map_);
//		assertTrue(!team_.isValid(data, Fight.FOE, game_.getFight()));
//	}


________________________________________________________________________
technical
//TODO search workdir-win32:1.5.1 house pc

