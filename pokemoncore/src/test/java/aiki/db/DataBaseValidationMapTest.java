package aiki.db;

import aiki.instances.Instances;
import aiki.map.DataMap;
import aiki.map.buildings.Gym;
import aiki.map.buildings.PokemonCenter;
import aiki.map.characters.*;
import aiki.map.characters.enums.SellType;
import aiki.map.enums.Direction;
import aiki.map.levels.*;
import aiki.map.levels.enums.EnvironmentType;
import aiki.map.places.*;
import aiki.map.pokemon.PkTrainer;
import aiki.map.pokemon.PokemonTeam;
import aiki.map.pokemon.WildPk;
import aiki.map.util.MiniMapCoords;
import aiki.map.util.PlaceInterConnect;
import aiki.map.util.TileMiniMap;
import aiki.util.Coords;
import aiki.util.LevelPoint;
import aiki.util.Point;
import code.util.EqList;
import code.util.ObjectMap;
import code.util.ShortMap;
import code.util.StringList;
import org.junit.Test;

import static aiki.db.EquallablePkUtil.assertEq;
import static org.junit.Assert.assertTrue;

public final class DataBaseValidationMapTest extends DataBaseValidationCommon {

    @Test
    public void link1Test() {
        Link l_ = new Link("l'UP'5;10_8,4");
        assertEq("l'UP'5;10_8,4",l_.display());
    }

    @Test
    public void link2Test() {
        Link l_ = new Link("l'U'5;10_8,4");
        assertEq("l'UP'5;10_8,4",l_.display());
    }

    @Test
    public void link3Test() {
        Link l_ = new Link("l'5;10_8,4");
        assertEq("l'5;10_8,4",l_.display());
    }
    @Test
    public void fail1Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        map_.getPlaces().addEntry((short)0,Instances.newRoad());
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) -1);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail2Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        map_.getPlaces().addEntry((short)0,Instances.newRoad());
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail3Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Road r_ = Instances.newRoad();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 1);
        block_.setIndexApparition((short)10);
        AreaApparition area_ = Instances.newAreaApparition();
        area_.getWildPokemonFishing().add(Instances.newWildPk());
        area_.setMultFight((byte)5);
        r_.getLevelRoad().getWildPokemonAreas().add(area_);
        area_ = Instances.newAreaApparition();
        area_.setMultFight((byte)-1);
        r_.getLevelRoad().getWildPokemonAreas().add(area_);
        r_.getLevelRoad().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        TrainerMultiFights tr_ = Instances.newTrainerMultiFights();
        tr_.setMultiplicityFight((byte) 5);
        PokemonTeam team_ = Instances.newPokemonTeam();
        PkTrainer pkTr_ = Instances.newPkTrainer();
        team_.getTeam().add(pkTr_);
        pkTr_ = Instances.newPkTrainer();
        pkTr_.getMoves().add(ELECTRICK);
        pkTr_.getMoves().add(CHARGE);
        pkTr_.getMoves().add(CHARGE2);
        pkTr_.getMoves().add(CHARGE3);
        pkTr_.getMoves().add(CHARGE4);
        pkTr_.getMoves().add(TREMPETTE);
        pkTr_.getMoves().add(TREMPETTE2);
        pkTr_.getMoves().add(TREMPETTE3);
        pkTr_.getMoves().add(LUTTE);
        team_.getTeam().add(pkTr_);
        tr_.getTeamsRewards().add(team_);
        tr_.getTeamsRewards().add(Instances.newPokemonTeam());
        r_.getLevelRoad().getCharacters().addEntry(new Point((short)1,(short)1), tr_);
        TrainerMultiFights trTwo_ = Instances.newTrainerMultiFights();
        trTwo_.setMultiplicityFight((byte)0);
        r_.getLevelRoad().getCharacters().addEntry(new Point((short)2,(short)2), trTwo_);
        DealerItem deal_ = Instances.newDealerItem();
        deal_.getItems().add(ELECTRICK);
        deal_.getTechnicalMoves().add((short)100);
        r_.getLevelRoad().getCharacters().addEntry(new Point((short)5,(short)5), deal_);
        DualFight dual_ = Instances.newDualFight();
        dual_.setPt(new Point((short)4,(short)4));
        r_.getLevelRoad().getDualFights().addEntry(new Point((short)3,(short)3), dual_);
        r_.getLevelRoad().getItems().addEntry(new Point((short)5,(short)5),ELECTRICK);
        map_.getPlaces().addEntry((short)0, r_);
        map_.getPlaces().addEntry((short)1, Instances.newCity());
        City city_ = Instances.newCity();
        PokemonCenter pokemonCenter_ = Instances.newPokemonCenter();
        pokemonCenter_.getIndoor().getBlocks().addEntry(new Point((short)0,(short)0),Instances.newBlock());
        Seller seller_ = Instances.newSeller();
        pokemonCenter_.getIndoor().getGerants().addEntry(new Point((short)1,(short)1), seller_);
        seller_ = Instances.newSeller();
        seller_.getItems().add(ELECTRICK);
        seller_.setSell(SellType.TM);
        pokemonCenter_.getIndoor().getGerants().addEntry(new Point((short)1,(short)2),seller_);
        seller_ = Instances.newSeller();
        seller_.getTm().add((short)100);
        seller_.setSell(SellType.ITEM);
        pokemonCenter_.getIndoor().getGerants().addEntry(new Point((short)1,(short)3),seller_);
        seller_ = Instances.newSeller();
        seller_.getItems().add(ELECTRICK);
        seller_.getTm().add((short)100);
        seller_.setSell(SellType.MOVE);
        pokemonCenter_.getIndoor().getGerants().addEntry(new Point((short)1,(short)4),seller_);
        pokemonCenter_.getIndoor().getGerants().addEntry(new Point((short)1,(short)5),Instances.newGymTrainer());
        pokemonCenter_.getIndoor().setStorageCoords(new Point((short)1,(short)5));
        city_.getBuildings().addEntry(new Point((short)0,(short)0), pokemonCenter_);
        Gym gym_ = Instances.newGym();
        GymLeader gymLeader_ = Instances.newGymLeader();
        gymLeader_.setTm((short)100);
        block_ = Instances.newBlock();
        block_.setType(EnvironmentType.NOTHING);
        block_.setWidth((short)1);
        block_.setHeight((short)1);
        gym_.getIndoor().getBlocks().addEntry(new Point((short)0,(short)0),block_);
        gym_.getIndoor().setGymLeader(gymLeader_);
        gym_.getIndoor().getGymTrainers().addEntry(new Point((short)2,(short)2),Instances.newGymTrainer());
        gym_.getIndoor().setGymLeaderCoords(new Point((short)2,(short)2));
        gym_.setExitCity(new Point((short)10,(short)10));
        city_.getBuildings().addEntry(new Point((short)1,(short)1), gym_);
        map_.getPlaces().addEntry((short)2, city_);
        city_ = Instances.newCity();
        block_ = Instances.newBlock();
        block_.setHeight((short) 2);
        block_.setWidth((short) 2);
        city_.getLevelOutdoor().getBlocks().addEntry(new Point((short)1,(short)1),block_);
        block_ = Instances.newBlock();
        block_.setHeight((short) 2);
        block_.setWidth((short) 2);
        city_.getLevelOutdoor().getBlocks().addEntry(new Point((short)0,(short)0),block_);
        block_ = Instances.newBlock();
        block_.setHeight((short) -2);
        block_.setWidth((short) 2);
        city_.getLevelOutdoor().getBlocks().addEntry(new Point((short)5,(short)5),block_);
        block_ = Instances.newBlock();
        block_.setType(EnvironmentType.NOTHING);
        block_.setHeight((short) 2);
        block_.setWidth((short) 2);
        block_.setIndexApparition((short) 0);
        city_.getLevelOutdoor().getBlocks().addEntry(new Point((short)10,(short)0),block_);
        map_.getPlaces().addEntry((short)3, city_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail4Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Road r_ = Instances.newRoad();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 1);
        block_.setIndexApparition((short)0);
        AreaApparition area_ = Instances.newAreaApparition();
        WildPk wpk_ = Instances.newWildPk();
        wpk_.setAbility(ELECTRICK);
        area_.getWildPokemonFishing().add(wpk_);
        wpk_ = Instances.newWildPk();
        wpk_.setItem(ELECTRICK);
        area_.getWildPokemonFishing().add(wpk_);
        wpk_ = Instances.newWildPk();
        wpk_.setAbility(ELECTRICK);
        wpk_.setItem(ELECTRICK);
        area_.getWildPokemonFishing().add(wpk_);
        area_.setMultFight((byte)5);
        r_.getLevelRoad().getWildPokemonAreas().add(area_);
        area_ = Instances.newAreaApparition();
        area_.setMultFight((byte)-1);
        r_.getLevelRoad().getWildPokemonAreas().add(area_);
        r_.getLevelRoad().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        DualFight dual_ = Instances.newDualFight();
        dual_.setPt(new Point((short)4,(short)4));
        r_.getLevelRoad().getDualFights().addEntry(new Point((short)3,(short)3), dual_);
        map_.getPlaces().addEntry((short)0, r_);
        map_.getPlaces().addEntry((short)1, Instances.newCity());
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        data_.initializeWildPokemon();
        assertTrue(data_.isError());
    }

    @Test
    public void fail5Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Road r_ = Instances.newRoad();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 1);
        block_.setIndexApparition((short)0);
        r_.getLevelRoad().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        map_.getPlaces().addEntry((short)0, r_);
        League league_ = Instances.newLeague();
        LevelLeague room_ = Instances.newLevelLeague();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 1);
        block_.setType(EnvironmentType.NOTHING);
        room_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        room_.setAccessPoint(new Point((short)1,(short)1));
        room_.setTrainerCoords(new Point((short)1,(short)1));
        room_.setNextLevelTarget(new Point((short)1,(short)1));
        league_.getRooms().add(room_);
        room_ = Instances.newLevelLeague();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 1);
        block_.setType(EnvironmentType.NOTHING);
        room_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        room_.setAccessPoint(new Point((short)1,(short)1));
        room_.setTrainerCoords(new Point((short)1,(short)1));
        room_.setNextLevelTarget(new Point((short)1,(short)1));
        league_.getRooms().add(room_);
        league_.setBegin(new Point((short)1,(short)1));
        map_.getPlaces().addEntry((short)1, league_);
        league_ = Instances.newLeague();
        league_.setAccessCoords(newCoords(1,5,2,2));
        map_.getPlaces().addEntry((short)2, league_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        data_.initializeWildPokemon();
        assertTrue(data_.isError());
        ShortMap<EqList<PlaceInterConnect>> v_ = new ShortMap<EqList<PlaceInterConnect>>();
        DataMap.merge(v_,new PlaceInterConnect(new Point((short)0,(short)0),Direction.RIGHT),new Point((short)0,(short)0),(byte)0);
        DataMap.merge(v_,new PlaceInterConnect(new Point((short)0,(short)0),Direction.RIGHT),new Point((short)0,(short)0),(byte)0);
    }

    @Test
    public void fail6Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Road r_ = Instances.newRoad();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 1);
        block_.setIndexApparition((short)10);
        r_.getLevelRoad().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        DealerItem deal_ = Instances.newDealerItem();
        deal_.getItems().add(ELECTRICK);
        deal_.getTechnicalMoves().add((short)100);
        r_.getLevelRoad().getCharacters().addEntry(new Point((short)5,(short)5), deal_);
        DualFight dual_ = Instances.newDualFight();
        dual_.setPt(new Point((short)5,(short)5));
        r_.getLevelRoad().getDualFights().addEntry(new Point((short)5,(short)5), dual_);
        r_.getLevelRoad().getLegendaryPks().addEntry(new Point((short)5,(short)5),Instances.newWildPk());
        r_.getLevelRoad().getTm().addEntry(new Point((short)5,(short)5),(short)100);
        r_.getLevelRoad().getHm().addEntry(new Point((short)5,(short)5),(short)100);
        map_.getPlaces().addEntry((short)0, r_);
        map_.getPlaces().addEntry((short)1, Instances.newCity());
        City city_ = Instances.newCity();
        Gym gym_ = Instances.newGym();
        gym_.setExitCity(new Point((short)10,(short)10));
        city_.getBuildings().addEntry(new Point((short)1,(short)1), gym_);
        city_.getBuildings().addEntry(new Point((short)1,(short)2), Instances.newGym());
        city_.getBuildings().addEntry(new Point((short)1,(short)3), Instances.newPokemonCenter());
        map_.getPlaces().addEntry((short)2, city_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail7Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Cave r_ = Instances.newCave();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 1);
        block_.setIndexApparition((short)10);
        LevelCave levelCave_ = Instances.newLevelCave();
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(5,2,5,8,4,9)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        r_.getLevels().addEntry((byte)0, levelCave_);
        levelCave_ = Instances.newLevelCave();
        r_.getLevels().addEntry((byte)1,levelCave_);
        LevelPoint lPt_ = new LevelPoint();
        lPt_.setLevelIndex((byte) 5);
        r_.getLinksWithOtherPlaces().addEntry(lPt_,new Link(ELECTRICK,newCoords(5,2,5,8,4,9)));
        map_.getPlaces().addEntry((short)0, r_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail8Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Cave r_ = Instances.newCave();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 1);
        block_.setIndexApparition((short)10);
        LevelCave levelCave_ = Instances.newLevelCave();
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,0,5,8,4,9)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        r_.getLevels().addEntry((byte)0, levelCave_);
        levelCave_ = Instances.newLevelCave();
        r_.getLevels().addEntry((byte)1,levelCave_);
        LevelPoint lPt_ = new LevelPoint();
        lPt_.setLevelIndex((byte) 1);
        r_.getLinksWithOtherPlaces().addEntry(lPt_,new Link(ELECTRICK,newCoords(5,2,5,8,4,9)));
        map_.getPlaces().addEntry((short)0, r_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail9Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Cave r_ = Instances.newCave();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 1);
        LevelCave levelCave_ = Instances.newLevelCave();
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,0,5,8,4,9)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        levelCave_.getDualFights().addEntry(new Point((short)0,(short)0),Instances.newDualFight());
        levelCave_.getCharacters().addEntry(new Point((short)0,(short)0),Instances.newTrainerMultiFights());
        levelCave_.getItems().addEntry(new Point((short)0,(short)0),ELECTRICK);
        levelCave_.getTm().addEntry(new Point((short)0,(short)0),(short)0);
        levelCave_.getHm().addEntry(new Point((short)0,(short)0),(short)0);
        levelCave_.getLegendaryPks().addEntry(new Point((short)0,(short)0),Instances.newWildPk());
        r_.getLevels().addEntry((byte)0, levelCave_);
        levelCave_ = Instances.newLevelCave();
        r_.getLevels().addEntry((byte)1,levelCave_);
        LevelPoint lPt_ = new LevelPoint();
        lPt_.setPoint(new Point((short)1,(short)1));
        lPt_.setLevelIndex((byte) 1);
        r_.getLinksWithOtherPlaces().addEntry(lPt_,new Link(ELECTRICK,newCoords(5,2,5,8,4,9)));
        map_.getPlaces().addEntry((short)0, r_);
        Road road_ = Instances.newRoad();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 1);
        road_.getLevelRoad().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        road_.getLinksWithCaves().add(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,0,5,8,4,9)));
        road_.getLinksWithCaves().add(new Point((short)1,(short)0),new Link(ELECTRICK,newCoords(0,0,0,0)));
        map_.getPlaces().addEntry((short)1, road_);
        City city_ = Instances.newCity();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 1);
        city_.getLevelOutdoor().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        city_.getLinksWithCaves().add(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,0,5,8,4,9)));
        city_.getLinksWithCaves().add(new Point((short)1,(short)0),new Link(ELECTRICK,newCoords(0,0,0,0)));
        map_.getPlaces().addEntry((short)2, city_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail10Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Cave r_ = Instances.newCave();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        LevelCave levelCave_ = Instances.newLevelCave();
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,0,5,8,4,9)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        levelCave_.getItems().addEntry(new Point((short)1,(short)0),ELECTRICK);
        r_.getLevels().addEntry((byte)0, levelCave_);
        levelCave_ = Instances.newLevelCave();
        r_.getLevels().addEntry((byte)1,levelCave_);
        LevelPoint lPt_ = new LevelPoint();
        lPt_.setPoint(new Point((short)1,(short)1));
        lPt_.setLevelIndex((byte) 1);
        r_.getLinksWithOtherPlaces().addEntry(lPt_,new Link(ELECTRICK,newCoords(5,2,5,8,4,9)));
        map_.getPlaces().addEntry((short)0, r_);
        Road road_ = Instances.newRoad();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 1);
        road_.getLevelRoad().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        road_.getLinksWithCaves().add(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,0,5,8,4,9)));
        road_.getLinksWithCaves().add(new Point((short)1,(short)0),new Link(ELECTRICK,newCoords(0,0,1,0)));
        map_.getPlaces().addEntry((short)1, road_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail11Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Cave r_ = Instances.newCave();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        LevelCave levelCave_ = Instances.newLevelCave();
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,0,5,8,4,9)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        levelCave_.getItems().addEntry(new Point((short)1,(short)0),ELECTRICK);
        r_.getLevels().addEntry((byte)0, levelCave_);
        levelCave_ = Instances.newLevelCave();
        r_.getLevels().addEntry((byte)1,levelCave_);
        LevelPoint lPt_ = new LevelPoint();
        lPt_.setPoint(new Point((short)1,(short)1));
        lPt_.setLevelIndex((byte) 1);
        r_.getLinksWithOtherPlaces().addEntry(lPt_,new Link(ELECTRICK,newCoords(1,0,1,0)));
        map_.getPlaces().addEntry((short)0, r_);
        Road road_ = Instances.newRoad();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        road_.getLevelRoad().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        road_.getLinksWithCaves().add(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,0,5,8,4,9)));
        road_.getLinksWithCaves().add(new Point((short)1,(short)0),new Link(ELECTRICK,newCoords(0,0,1,0)));
        road_.getLevelRoad().getItems().addEntry(new Point((short)1,(short)0),ELECTRICK);
        map_.getPlaces().addEntry((short)1, road_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail112Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Cave r_ = Instances.newCave();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        LevelCave levelCave_ = Instances.newLevelCave();
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,1,1,0)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        levelCave_.getItems().addEntry(new Point((short)1,(short)0),ELECTRICK);
        r_.getLevels().addEntry((byte)0, levelCave_);
        levelCave_ = Instances.newLevelCave();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        levelCave_.getItems().addEntry(new Point((short)1,(short)0),ELECTRICK);
        r_.getLevels().addEntry((byte)1,levelCave_);
        LevelPoint lPt_ = new LevelPoint();
        lPt_.setPoint(new Point((short)1,(short)1));
        lPt_.setLevelIndex((byte) 1);
        r_.getLinksWithOtherPlaces().addEntry(lPt_,new Link(ELECTRICK,newCoords(1,0,1,0)));
        map_.getPlaces().addEntry((short)0, r_);
        Road road_ = Instances.newRoad();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        road_.getLevelRoad().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        road_.getLinksWithCaves().add(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,0,5,8,4,9)));
        road_.getLinksWithCaves().add(new Point((short)1,(short)0),new Link(ELECTRICK,newCoords(0,0,1,0)));
        road_.getLevelRoad().getItems().addEntry(new Point((short)1,(short)0),ELECTRICK);
        map_.getPlaces().addEntry((short)1, road_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail13Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Cave r_ = Instances.newCave();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        LevelCave levelCave_ = Instances.newLevelCave();
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,1,1,0)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        levelCave_.getItems().addEntry(new Point((short)1,(short)1),ELECTRICK);
        r_.getLevels().addEntry((byte)0, levelCave_);
        levelCave_ = Instances.newLevelCave();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        levelCave_.getItems().addEntry(new Point((short)1,(short)0),ELECTRICK);
        r_.getLevels().addEntry((byte)1,levelCave_);
        LevelPoint lPt_ = new LevelPoint();
        lPt_.setPoint(new Point((short)1,(short)1));
        lPt_.setLevelIndex((byte) 1);
        r_.getLinksWithOtherPlaces().addEntry(lPt_,new Link(ELECTRICK,newCoords(1,0,1,0)));
        map_.getPlaces().addEntry((short)0, r_);
        Road road_ = Instances.newRoad();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        road_.getLevelRoad().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        road_.getLinksWithCaves().add(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,0,5,8,4,9)));
        road_.getLinksWithCaves().add(new Point((short)1,(short)0),new Link(ELECTRICK,newCoords(0,0,1,0)));
        road_.getLevelRoad().getItems().addEntry(new Point((short)1,(short)0),ELECTRICK);
        map_.getPlaces().addEntry((short)1, road_);
        map_.getPlaces().addEntry((short)2, Instances.newCave());
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail14Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Cave r_ = Instances.newCave();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        LevelCave levelCave_ = Instances.newLevelCave();
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,1,1,0)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        levelCave_.getItems().addEntry(new Point((short)1,(short)0),ELECTRICK);
        r_.getLevels().addEntry((byte)0, levelCave_);
        levelCave_ = Instances.newLevelCave();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        levelCave_.getItems().addEntry(new Point((short)1,(short)0),ELECTRICK);
        r_.getLevels().addEntry((byte)1,levelCave_);
        LevelPoint lPt_ = new LevelPoint();
        lPt_.setPoint(new Point((short)1,(short)1));
        lPt_.setLevelIndex((byte) 1);
        r_.getLinksWithOtherPlaces().addEntry(lPt_,new Link(ELECTRICK,newCoords(1,0,1,0)));
        map_.getPlaces().addEntry((short)0, r_);
        City city_ = Instances.newCity();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        city_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        city_.getLinksWithCaves().add(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,0,5,8,4,9)));
        city_.getLinksWithCaves().add(new Point((short)1,(short)0),new Link(ELECTRICK,newCoords(0,0,1,0)));
        map_.getPlaces().addEntry((short)1, city_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail15Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Cave r_ = Instances.newCave();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        LevelCave levelCave_ = Instances.newLevelCave();
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,1,1,0)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        r_.getLevels().addEntry((byte)0, levelCave_);
        levelCave_ = Instances.newLevelCave();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)0),new Link(ELECTRICK,newCoords(0,1,1,0)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        r_.getLevels().addEntry((byte)1,levelCave_);
        LevelPoint lPt_ = new LevelPoint();
        lPt_.setPoint(new Point((short)1,(short)1));
        lPt_.setLevelIndex((byte) 1);
        r_.getLinksWithOtherPlaces().addEntry(lPt_,new Link(ELECTRICK,newCoords(1,0,1,0)));
        map_.getPlaces().addEntry((short)0, r_);
        City city_ = Instances.newCity();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        city_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        city_.getLinksWithCaves().add(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,0,5,8,4,9)));
        city_.getLinksWithCaves().add(new Point((short)1,(short)0),new Link(ELECTRICK,newCoords(0,0,1,0)));
        map_.getPlaces().addEntry((short)1, city_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail16Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Cave r_ = Instances.newCave();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        LevelCave levelCave_ = Instances.newLevelCave();
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,1,1,0)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        r_.getLevels().addEntry((byte)0, levelCave_);
        levelCave_ = Instances.newLevelCave();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,1,1,0)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        r_.getLevels().addEntry((byte)1,levelCave_);
        LevelPoint lPt_ = new LevelPoint();
        lPt_.setPoint(new Point((short)1,(short)1));
        lPt_.setLevelIndex((byte) 1);
        r_.getLinksWithOtherPlaces().addEntry(lPt_,new Link(ELECTRICK,newCoords(1,0,1,0)));
        map_.getPlaces().addEntry((short)0, r_);
        City city_ = Instances.newCity();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        city_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        city_.setPointsWithCitiesAndOtherRoads(new ObjectMap<PlaceInterConnect, Coords>());
        city_.getPointsWithCitiesAndOtherRoads().addEntry(new PlaceInterConnect(new Point((short)2,(short)2),Direction.RIGHT),newCoords(2,0,5,5));
        map_.getPlaces().addEntry((short)1, city_);
        Road road_ = Instances.newRoad();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        road_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        road_.setPointsWithCitiesAndOtherRoads(new ObjectMap<PlaceInterConnect, Coords>());
        road_.getPointsWithCitiesAndOtherRoads().addEntry(new PlaceInterConnect(new Point((short)2,(short)2),Direction.RIGHT),newCoords(1,0,5,5));
        map_.getPlaces().addEntry((short)2, road_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail17Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        map_.getPlaces().addEntry((short)0,Instances.newCity());
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) -1);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0,2,2, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail18Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        City city_ = Instances.newCity();
        city_.getBuildings().addEntry(new Point((short)2,(short)2),Instances.newPokemonCenter());
        map_.getPlaces().addEntry((short)0, city_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) -1);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0,2,2, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
        assertTrue(data_.getMap().getAreaByCoords(new Coords()).isVirtual());
    }

    @Test
    public void fail19Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Cave r_ = Instances.newCave();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        LevelCave levelCave_ = Instances.newLevelCave();
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,1,1,0)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        r_.getLevels().addEntry((byte)0, levelCave_);
        levelCave_ = Instances.newLevelCave();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,1,1,0)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        r_.getLevels().addEntry((byte)1,levelCave_);
        LevelPoint lPt_ = new LevelPoint();
        lPt_.setPoint(new Point((short)1,(short)1));
        lPt_.setLevelIndex((byte) 1);
        r_.getLinksWithOtherPlaces().addEntry(lPt_,new Link(ELECTRICK,newCoords(1,0,1,0)));
        map_.getPlaces().addEntry((short)0, r_);
        City city_ = Instances.newCity();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        city_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        Link lk_ = new Link(ELECTRICK, newCoords(2, 0, 0, 0));
        lk_.setDir(Direction.RIGHT);
        city_.getLinksWithCaves().addEntry(new Point((short)0,(short)0), lk_);
        city_.setPointsWithCitiesAndOtherRoads(new ObjectMap<PlaceInterConnect, Coords>());
        city_.getPointsWithCitiesAndOtherRoads().addEntry(new PlaceInterConnect(new Point((short)2,(short)2),Direction.RIGHT),newCoords(2,0,5,5));
        map_.getPlaces().addEntry((short)1, city_);
        Road road_ = Instances.newRoad();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        road_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        road_.setPointsWithCitiesAndOtherRoads(new ObjectMap<PlaceInterConnect, Coords>());
        road_.getPointsWithCitiesAndOtherRoads().addEntry(new PlaceInterConnect(new Point((short)2,(short)2),Direction.RIGHT),newCoords(1,0,5,5));
        map_.getPlaces().addEntry((short)2, road_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail20Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Cave r_ = Instances.newCave();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        LevelCave levelCave_ = Instances.newLevelCave();
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,1,1,0)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        r_.getLevels().addEntry((byte)0, levelCave_);
        levelCave_ = Instances.newLevelCave();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,1,1,0)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        r_.getLevels().addEntry((byte)1,levelCave_);
        LevelPoint lPt_ = new LevelPoint();
        lPt_.setPoint(new Point((short)1,(short)1));
        lPt_.setLevelIndex((byte) 1);
        r_.getLinksWithOtherPlaces().addEntry(lPt_,new Link(ELECTRICK,newCoords(1,0,1,10)));
        map_.getPlaces().addEntry((short)0, r_);
        City city_ = Instances.newCity();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        city_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        Link lk_ = new Link(ELECTRICK, newCoords(0, 0, 1, 1));
        lk_.setDir(Direction.RIGHT);
        city_.getLinksWithCaves().addEntry(new Point((short)0,(short)0), lk_);
        city_.setPointsWithCitiesAndOtherRoads(new ObjectMap<PlaceInterConnect, Coords>());
        city_.getPointsWithCitiesAndOtherRoads().addEntry(new PlaceInterConnect(new Point((short)2,(short)2),Direction.RIGHT),newCoords(2,0,5,5));
        map_.getPlaces().addEntry((short)1, city_);
        Road road_ = Instances.newRoad();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        road_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        road_.setPointsWithCitiesAndOtherRoads(new ObjectMap<PlaceInterConnect, Coords>());
        road_.getPointsWithCitiesAndOtherRoads().addEntry(new PlaceInterConnect(new Point((short)2,(short)2),Direction.RIGHT),newCoords(1,0,5,5));
        map_.getPlaces().addEntry((short)2, road_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail21Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        Cave r_ = Instances.newCave();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        LevelCave levelCave_ = Instances.newLevelCave();
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,1,1,0)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        r_.getLevels().addEntry((byte)0, levelCave_);
        levelCave_ = Instances.newLevelCave();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        levelCave_.getLinksOtherLevels().addEntry(new Point((short)1,(short)1),new Link(ELECTRICK,newCoords(0,1,1,0)));
        levelCave_.getBlocks().addEntry(new Point((short)0,(short)0), block_);
        r_.getLevels().addEntry((byte)1,levelCave_);
        LevelPoint lPt_ = new LevelPoint();
        lPt_.setPoint(new Point((short)1,(short)1));
        lPt_.setLevelIndex((byte) 1);
        r_.getLinksWithOtherPlaces().addEntry(lPt_,new Link(ELECTRICK,newCoords(1,0,1,10)));
        map_.getPlaces().addEntry((short)0, r_);
        City city_ = Instances.newCity();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        city_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        Link lk_ = new Link(ELECTRICK, newCoords(0, 1, 1, 1));
        city_.getLinksWithCaves().addEntry(new Point((short)0,(short)0), lk_);
        city_.setPointsWithCitiesAndOtherRoads(new ObjectMap<PlaceInterConnect, Coords>());
        city_.getPointsWithCitiesAndOtherRoads().addEntry(new PlaceInterConnect(new Point((short)2,(short)2),Direction.RIGHT),newCoords(2,0,5,5));
        map_.getPlaces().addEntry((short)1, city_);
        Road road_ = Instances.newRoad();
        block_ = Instances.newBlock();
        block_.setHeight((short) 1);
        block_.setWidth((short) 2);
        road_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        road_.setPointsWithCitiesAndOtherRoads(new ObjectMap<PlaceInterConnect, Coords>());
        road_.getPointsWithCitiesAndOtherRoads().addEntry(new PlaceInterConnect(new Point((short)2,(short)2),Direction.RIGHT),newCoords(1,0,5,5));
        map_.getPlaces().addEntry((short)2, road_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail22Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        City city_ = Instances.newCity();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 2);
        block_.setWidth((short) 2);
        city_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        city_.getBuildings().addEntry(new Point((short)1,(short)1),Instances.newPokemonCenter());
        city_.setPointsWithCitiesAndOtherRoads(new ObjectMap<PlaceInterConnect, Coords>());
        city_.getPointsWithCitiesAndOtherRoads().addEntry(new PlaceInterConnect(new Point((short)0,(short)0),Direction.LEFT),newCoords(0,0,1,1));
        map_.getPlaces().addEntry((short)1, city_);
        Road road_ = Instances.newRoad();
        block_ = Instances.newBlock();
        block_.setHeight((short) 2);
        block_.setWidth((short) 2);
        road_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        road_.setPointsWithCitiesAndOtherRoads(new ObjectMap<PlaceInterConnect, Coords>());
        road_.getPointsWithCitiesAndOtherRoads().addEntry(new PlaceInterConnect(new Point((short)1,(short)1),Direction.RIGHT),newCoords(1,0,0,0));
        map_.getPlaces().addEntry((short)0, road_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }

    @Test
    public void fail23Test() {
        DataBase data_ =new DataBase();
        data_.setLanguage(LANGUAGE);
        data_.setLanguages(new StringList(LANGUAGE));
        data_.initializeMembers();
        DataMap map_ = data_.getMap();
        map_.setAccessCondition(new ObjectMap<Coords, EqList<Coords>>());
        map_.setPlaces(new ShortMap<Place>());
        map_.setMiniMap(new ObjectMap<MiniMapCoords,TileMiniMap>());
        City city_ = Instances.newCity();
        Block block_ = Instances.newBlock();
        block_.setHeight((short) 2);
        block_.setWidth((short) 2);
        city_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        city_.getBuildings().addEntry(new Point((short)1,(short)0),Instances.newPokemonCenter());
        city_.setPointsWithCitiesAndOtherRoads(new ObjectMap<PlaceInterConnect, Coords>());
        city_.getPointsWithCitiesAndOtherRoads().addEntry(new PlaceInterConnect(new Point((short)0,(short)0),Direction.LEFT),newCoords(0,0,1,1));
        map_.getPlaces().addEntry((short)1, city_);
        Road road_ = Instances.newRoad();
        block_ = Instances.newBlock();
        block_.setHeight((short) 2);
        block_.setWidth((short) 2);
        road_.getLevel().getBlocks().addEntry(new Point((short)0,(short)0), block_);
        road_.setPointsWithCitiesAndOtherRoads(new ObjectMap<PlaceInterConnect, Coords>());
        road_.getPointsWithCitiesAndOtherRoads().addEntry(new PlaceInterConnect(new Point((short)1,(short)1),Direction.RIGHT),newCoords(1,0,0,0));
        DualFight dualFight_ = Instances.newDualFight();
        dualFight_.setPt(new Point((short)1,(short)1));
        road_.getLevelRoad().getDualFights().addEntry(new Point((short)0, (short) 1),dualFight_);
        map_.getPlaces().addEntry((short)0, road_);
        map_.setUnlockedCity(NULL_REF);
        map_.setSideLength(2);
        map_.getAccessCondition().put(newCoords(1,0,1,1),new EqList<Coords>(newCoords(0,0,0,1)));
        WildPk pkm_ = new WildPk();
        pkm_.setName(ELECTRICK);
        pkm_.setAbility(ELECTRICK);
        pkm_.setItem(ELECTRICK);
        pkm_.setLevel((short) 1200);
        map_.setFirstPokemon(pkm_);
        map_.setBegin(newCoords(0, 0, 0, 0));
        data_.completeVariables();
        initConstants(data_);
        initRandomLaws(data_);
        initExpPoints(data_);
        data_.getMap().validate(data_);
        data_.validateImages();
        assertTrue(data_.isError());
    }
}
